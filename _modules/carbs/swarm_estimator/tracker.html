

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>carbs.swarm_estimator.tracker &mdash; CARBS 1.0.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />

  
    <link rel="canonical" href="https://drjdlarson.github.io/carbs/_modules/carbs/swarm_estimator/tracker.html" />
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=baaebd52"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=cbcfbdad"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #9E1B32" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            CARBS
              <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../_autosummary/carbs.html">carbs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/carbs/carbs.guidance.html">guidance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/carbs/guidance/carbs.guidance.gaussian_density_cost.html">carbs.guidance.gaussian_density_cost</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/carbs/guidance/carbs.guidance.ELQR.html">ELQR</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/carbs/guidance/carbs.guidance.ELQROSPA.html">ELQROSPA</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/carbs/carbs.swarm_estimator.html">swarm_estimator</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/carbs/swarm_estimator/carbs.swarm_estimator.slam.html">slam</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/carbs/swarm_estimator/carbs.swarm_estimator.tracker.html">tracker</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/carbs/carbs.utilities.html">utilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/carbs/utilities/carbs.utilities.graphs.html">graphs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/carbs/utilities/carbs.utilities.graphs_subroutines.html">graphs_subroutines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/carbs/utilities/carbs.utilities.sampling.html">sampling</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/elqr.html">ELQR Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../usage/elqr.html#gaussian-mixture-based">Gaussian Mixture Based</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../usage/elqr.html#optimal-sub-pattern-assignment-based">Optimal Sub-Pattern Assignment Based</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../usage/elqr.html#ospa-based-with-obstacles">OSPA Based with Obstacles</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../toolchain.html">Toolchain Setup</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../toolchain.html#development-environment-setup">Development Environment Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../toolchain.html#example-workflow">Example Workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../toolchain.html#notes-on-tox">Notes on tox</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../cicd.html">CI/CD Pipeline</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../cicd.html#github-actions-quick-guide">Github Actions Quick Guide</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="./reports/coverage/index.html#http://">Test Coverage Report</a></li>
<li class="toctree-l1"><a class="reference external" href="./reports/junit/junit.html#http://">Test Results Report</a></li>
<li class="toctree-l1"><a class="reference external" href="http://lager.ua.edu/">LAGER Homepage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../References.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #9E1B32" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CARBS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">carbs.swarm_estimator.tracker</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for carbs.swarm_estimator.tracker</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Implements RFS tracking algorithms.</span>

<span class="sd">This module contains the classes and data structures</span>
<span class="sd">for RFS tracking related algorithms.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">gncpy.filters</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">la</span>
<span class="kn">import</span> <span class="nn">numpy.random</span> <span class="k">as</span> <span class="nn">rnd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Ellipse</span>
<span class="kn">import</span> <span class="nn">matplotlib.animation</span> <span class="k">as</span> <span class="nn">animation</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">from</span> <span class="nn">carbs.utilities.graphs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">k_shortest</span><span class="p">,</span>
    <span class="n">murty_m_best</span><span class="p">,</span>
    <span class="n">murty_m_best_all_meas_assigned</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">carbs.utilities.sampling</span> <span class="kn">import</span> <span class="n">gibbs</span><span class="p">,</span> <span class="n">mm_gibbs</span>

<span class="kn">from</span> <span class="nn">gncpy.math</span> <span class="kn">import</span> <span class="n">log_sum_exp</span><span class="p">,</span> <span class="n">get_elem_sym_fnc</span>
<span class="kn">import</span> <span class="nn">gncpy.plotting</span> <span class="k">as</span> <span class="nn">pltUtil</span>
<span class="kn">import</span> <span class="nn">gncpy.filters</span> <span class="k">as</span> <span class="nn">gfilts</span>
<span class="kn">import</span> <span class="nn">gncpy.errors</span> <span class="k">as</span> <span class="nn">gerr</span>

<span class="kn">import</span> <span class="nn">serums.models</span> <span class="k">as</span> <span class="nn">smodels</span>
<span class="kn">from</span> <span class="nn">serums.enums</span> <span class="kn">import</span> <span class="n">SingleObjectDistance</span>
<span class="kn">from</span> <span class="nn">serums.distances</span> <span class="kn">import</span> <span class="n">calculate_ospa</span><span class="p">,</span> <span class="n">calculate_ospa2</span><span class="p">,</span> <span class="n">calculate_gospa</span>


<div class="viewcode-block" id="RandomFiniteSetBase">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.RandomFiniteSetBase.html#carbs.swarm_estimator.tracker.RandomFiniteSetBase">[docs]</a>
<span class="k">class</span> <span class="nc">RandomFiniteSetBase</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generic base class for RFS based filters.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    filter : gncpy.filters.BayesFilter</span>
<span class="sd">        Filter handling dynamics</span>
<span class="sd">    prob_detection : float</span>
<span class="sd">        Modeled probability an object is detected</span>
<span class="sd">    prob_survive : float</span>
<span class="sd">        Modeled probability of object survival</span>
<span class="sd">    birth_terms : list</span>
<span class="sd">        List of terms in the birth model</span>
<span class="sd">    clutter_rate : float</span>
<span class="sd">        Rate of clutter</span>
<span class="sd">    clutter_density : float</span>
<span class="sd">        Density of clutter distribution</span>
<span class="sd">    inv_chi2_gate : float</span>
<span class="sd">        Chi squared threshold for gating the measurements</span>
<span class="sd">    save_covs : bool</span>
<span class="sd">        Save covariance matrix for each state during state extraction</span>
<span class="sd">    debug_plots : bool</span>
<span class="sd">        Saves data needed for extra debugging plots</span>
<span class="sd">    ospa : numpy array</span>
<span class="sd">        Calculated OSPA value for the given truth data. Must be manually updated</span>
<span class="sd">        by a function call.</span>
<span class="sd">    ospa_localization : numpy array</span>
<span class="sd">        Calculated OSPA value for the given truth data. Must be manually updated</span>
<span class="sd">        by a function call.</span>
<span class="sd">    ospa_cardinality : numpy array</span>
<span class="sd">        Calculated OSPA value for the given truth data. Must be manually updated</span>
<span class="sd">        by a function call.</span>
<span class="sd">    enable_spawning : bool</span>
<span class="sd">            Flag for enabling spawning.</span>
<span class="sd">    spawn_cov : N x N numpy array</span>
<span class="sd">        Covariance for spawned targets.</span>
<span class="sd">    spawn_weight : float</span>
<span class="sd">        Weight for spawned targets.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RandomFiniteSetBase.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.RandomFiniteSetBase.html#carbs.swarm_estimator.tracker.RandomFiniteSetBase.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">in_filter</span><span class="p">:</span> <span class="n">gncpy</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">BayesFilter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prob_detection</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">prob_survive</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">birth_terms</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">clutter_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">clutter_den</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">inv_chi2_gate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">save_covs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">debug_plots</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">enable_spawning</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">spawn_cov</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">spawn_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize an object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_filter</span>
<span class="sd">            Inner filter object.</span>
<span class="sd">        prob_detection</span>
<span class="sd">            Probability of detection.</span>
<span class="sd">        prob_survive</span>
<span class="sd">            Probability of survival.</span>
<span class="sd">        birth_terms</span>
<span class="sd">            Birth model.</span>
<span class="sd">        clutter_rate</span>
<span class="sd">            Clutter rate per scan.</span>
<span class="sd">        clutter_den</span>
<span class="sd">            Clutter density.</span>
<span class="sd">        inv_chi2_gate</span>
<span class="sd">            Inverse Chi^2 gating threshold.</span>
<span class="sd">        save_covs</span>
<span class="sd">            Flag for saving covariances.</span>
<span class="sd">        debug_plots</span>
<span class="sd">            Flag for enabling debug plots.</span>
<span class="sd">        enable_spawning</span>
<span class="sd">            Flag for enabling spawning.</span>
<span class="sd">        spawn_cov</span>
<span class="sd">            Covariance for spawned targets.</span>
<span class="sd">        spawn_weight</span>
<span class="sd">            Weight for spawned targets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">birth_terms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">birth_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">in_filter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">=</span> <span class="n">prob_detection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob_survive</span> <span class="o">=</span> <span class="n">prob_survive</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">birth_terms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">=</span> <span class="n">clutter_rate</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clutter_den</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">clutter_den</span> <span class="o">=</span> <span class="n">clutter_den</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span> <span class="o">=</span> <span class="n">clutter_den</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inv_chi2_gate</span> <span class="o">=</span> <span class="n">inv_chi2_gate</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span> <span class="o">=</span> <span class="n">save_covs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_plots</span> <span class="o">=</span> <span class="n">debug_plots</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ospa</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa_localization</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa_cardinality</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># local copy for internal modification</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[]</span>
        <span class="p">)</span>  <span class="c1"># list of lists, one per timestep, inner is all meas at time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># local copy for internal modification</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enable_spawning</span> <span class="o">=</span> <span class="n">enable_spawning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spawn_cov</span> <span class="o">=</span> <span class="n">spawn_cov</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spawn_weight</span> <span class="o">=</span> <span class="n">spawn_weight</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ospa_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The distance metric used in the OSPA calculation (read only).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;core&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@ospa_method</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ospa_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;OSPA method is read only. SKIPPING&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="RandomFiniteSetBase.save_filter_state">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.RandomFiniteSetBase.html#carbs.swarm_estimator.tracker.RandomFiniteSetBase.save_filter_state">[docs]</a>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">save_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generic method for saving key filter variables.</span>

<span class="sd">        This must be overridden in the inherited class. It is recommended to keep</span>
<span class="sd">        the signature the same to allow for standardized implemenation of</span>
<span class="sd">        wrapper classes. This should return a single variable that can be passed</span>
<span class="sd">        to the loading function to setup a filter to the same internal state</span>
<span class="sd">        as the current instance when this function was called.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filt_state</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">)</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;prob_detection&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;prob_survive&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_survive</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;birth_terms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;clutter_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;clutter_den&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;inv_chi2_gate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_chi2_gate</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;save_covs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;debug_plots&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_plots</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa_localization&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa_localization</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa_cardinality&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa_cardinality</span>

        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_states&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_meas_tab&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_covs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_ospa_params&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span>

        <span class="k">return</span> <span class="n">filt_state</span></div>


<div class="viewcode-block" id="RandomFiniteSetBase.load_filter_state">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.RandomFiniteSetBase.html#carbs.swarm_estimator.tracker.RandomFiniteSetBase.load_filter_state">[docs]</a>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generic method for saving key filter variables.</span>

<span class="sd">        This must be overridden in the inherited class. It is recommended to keep</span>
<span class="sd">        the signature the same to allow for standardized implemenation of</span>
<span class="sd">        wrapper classes. This initialize all internal variables saved by the</span>
<span class="sd">        filter save function such that a new instance would generate the same</span>
<span class="sd">        output as the original instance that called the save function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls_type</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;filter&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cls_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">cls_type</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;filter&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;filter&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;prob_detection&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob_survive</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;prob_survive&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;birth_terms&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;clutter_rate&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;clutter_den&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_chi2_gate</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;inv_chi2_gate&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;save_covs&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_plots</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;debug_plots&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa_localization</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa_localization&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa_cardinality</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa_cardinality&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_states&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_meas_tab&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_covs&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_ospa_params&quot;</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prob_miss_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compliment of :py:attr:`.swarm_estimator.RandomFiniteSetBase.prob_detection`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prob_death</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compliment of :attr:`carbs.swarm_estimator.RandomFinitSetBase.prob_survive`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_survive</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_birth_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of terms in the birth model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">)</span>

<div class="viewcode-block" id="RandomFiniteSetBase.predict">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.RandomFiniteSetBase.html#carbs.swarm_estimator.tracker.RandomFiniteSetBase.predict">[docs]</a>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Abstract method for the prediction step.</span>

<span class="sd">        This must be overridden in the inherited class. It is recommended to</span>
<span class="sd">        keep the same structure/order for the arguments for consistency</span>
<span class="sd">        between the inherited classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="RandomFiniteSetBase.correct">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.RandomFiniteSetBase.html#carbs.swarm_estimator.tracker.RandomFiniteSetBase.correct">[docs]</a>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Abstract method for the correction step.</span>

<span class="sd">        This must be overridden in the inherited class. It is recommended to</span>
<span class="sd">        keep the same structure/order for the arguments for consistency</span>
<span class="sd">        between the inherited classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="RandomFiniteSetBase.extract_states">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.RandomFiniteSetBase.html#carbs.swarm_estimator.tracker.RandomFiniteSetBase.extract_states">[docs]</a>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">extract_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Abstract method for extracting states.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="RandomFiniteSetBase.cleanup">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.RandomFiniteSetBase.html#carbs.swarm_estimator.tracker.RandomFiniteSetBase.cleanup">[docs]</a>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Abstract method that performs the cleanup step of the filter.</span>

<span class="sd">        This must be overridden in the inherited class. It is recommended to</span>
<span class="sd">        keep the same structure/order for the arguments for consistency</span>
<span class="sd">        between the inherited classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


    <span class="k">def</span> <span class="nf">_gate_meas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covs</span><span class="p">,</span> <span class="n">meas_mat_args</span><span class="o">=</span><span class="p">{},</span> <span class="n">est_meas_args</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gates measurements based on current estimates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Gating is performed based on a Gaussian noise model.</span>
<span class="sd">        See :cite:`Cox1993_AReviewofStatisticalDataAssociationTechniquesforMotionCorrespondence`</span>
<span class="sd">        for details on the chi squared test used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meas : list</span>
<span class="sd">            2d numpy arrrays of each measurement.</span>
<span class="sd">        means : list</span>
<span class="sd">            2d numpy arrays of each mean.</span>
<span class="sd">        covs : list</span>
<span class="sd">            2d numpy array of each covariance.</span>
<span class="sd">        meas_mat_args : dict, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters get measurement</span>
<span class="sd">            matrix function. The default is {}.</span>
<span class="sd">        est_meas_args : TYPE, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters get estimate</span>
<span class="sd">            matrix function. The default is {}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            2d numpy arrays of valid measurements.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">covs</span><span class="p">):</span>
            <span class="n">meas_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">get_meas_mat</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">meas_mat_args</span><span class="p">)</span>
            <span class="n">est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">get_est_meas</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">est_meas_args</span><span class="p">)</span>
            <span class="n">meas_pred_cov</span> <span class="o">=</span> <span class="n">meas_mat</span> <span class="o">@</span> <span class="n">p</span> <span class="o">@</span> <span class="n">meas_mat</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">meas_noise</span>
            <span class="n">meas_pred_cov</span> <span class="o">=</span> <span class="p">(</span><span class="n">meas_pred_cov</span> <span class="o">+</span> <span class="n">meas_pred_cov</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">v_s</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">meas_pred_cov</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">inv_sqrt_m_cov</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">v_s</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">valid</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">inov</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">est</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">inv_sqrt_m_cov</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">inov</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_chi2_gate</span><span class="p">:</span>
                    <span class="n">valid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="n">valid</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">meas</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">valid</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_ospa_setup_tmat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truth</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">true_covs</span><span class="p">,</span> <span class="n">state_inds</span><span class="p">):</span>
        <span class="c1"># get sizes</span>
        <span class="n">num_timesteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">truth</span><span class="p">)</span>
        <span class="n">num_objs</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">truth</span><span class="p">:</span>
            <span class="n">num_objs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">num_objs</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="c1"># create matrices</span>
        <span class="n">true_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">num_objs</span><span class="p">))</span>
        <span class="n">true_cov_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">num_objs</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">lst</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">truth</span><span class="p">):</span>
            <span class="n">obj_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">true_mat</span><span class="p">[:,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">obj_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">state_inds</span><span class="p">]</span>
                    <span class="n">obj_num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">true_covs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">lst</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">true_covs</span><span class="p">):</span>
                <span class="n">obj_num</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">truth</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">obj_num</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">true_cov_mat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">obj_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">state_inds</span><span class="p">][:,</span> <span class="n">state_inds</span><span class="p">]</span>
                        <span class="n">obj_num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">true_mat</span><span class="p">,</span> <span class="n">true_cov_mat</span>

    <span class="k">def</span> <span class="nf">_ospa_setup_emat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">state_inds</span><span class="p">):</span>
        <span class="c1"># get sizes</span>
        <span class="n">num_timesteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">)</span>
        <span class="n">num_objs</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">:</span>
            <span class="n">num_objs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="p">[</span><span class="n">num_objs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">_x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
            <span class="p">)</span>
        <span class="c1"># create matrices</span>
        <span class="n">est_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">num_objs</span><span class="p">))</span>
        <span class="n">est_cov_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">num_objs</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">lst</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">obj_num</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">est_mat</span><span class="p">[:,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">obj_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">state_inds</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">lst</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">obj_num</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">obj_num</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">est_cov_mat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">obj_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">state_inds</span><span class="p">][:,</span> <span class="n">state_inds</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">est_mat</span><span class="p">,</span> <span class="n">est_cov_mat</span>

    <span class="k">def</span> <span class="nf">_ospa_input_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">core_method</span><span class="p">,</span> <span class="n">truth</span><span class="p">,</span> <span class="n">true_covs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">core_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">core_method</span> <span class="o">=</span> <span class="n">SingleObjectDistance</span><span class="o">.</span><span class="n">EUCLIDEAN</span>
        <span class="k">elif</span> <span class="n">core_method</span> <span class="ow">is</span> <span class="n">SingleObjectDistance</span><span class="o">.</span><span class="n">MAHALANOBIS</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Must save covariances to calculate </span><span class="si">{:s}</span><span class="s2"> OSPA. Using </span><span class="si">{:s}</span><span class="s2"> instead&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">core_method</span><span class="p">,</span> <span class="n">SingleObjectDistance</span><span class="o">.</span><span class="n">EUCLIDEAN</span><span class="p">))</span>
            <span class="n">core_method</span> <span class="o">=</span> <span class="n">SingleObjectDistance</span><span class="o">.</span><span class="n">EUCLIDEAN</span>
        <span class="k">elif</span> <span class="n">core_method</span> <span class="ow">is</span> <span class="n">SingleObjectDistance</span><span class="o">.</span><span class="n">HELLINGER</span> <span class="ow">and</span> <span class="n">true_covs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Must save covariances to calculate </span><span class="si">{:s}</span><span class="s2"> OSPA. Using </span><span class="si">{:s}</span><span class="s2"> instead&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">core_method</span><span class="p">,</span> <span class="n">SingleObjectDistance</span><span class="o">.</span><span class="n">EUCLIDEAN</span><span class="p">))</span>
            <span class="n">core_method</span> <span class="o">=</span> <span class="n">SingleObjectDistance</span><span class="o">.</span><span class="n">EUCLIDEAN</span>
        <span class="k">return</span> <span class="n">core_method</span>

    <span class="k">def</span> <span class="nf">_ospa_find_s_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truth</span><span class="p">):</span>
        <span class="n">state_dim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">truth</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">state_dim</span> <span class="o">=</span> <span class="n">_x</span><span class="o">.</span><span class="n">size</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">state_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">state_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">state_dim</span> <span class="o">=</span> <span class="n">_x</span><span class="o">.</span><span class="n">size</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">state_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">state_dim</span>

<div class="viewcode-block" id="RandomFiniteSetBase.calculate_ospa">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.RandomFiniteSetBase.html#carbs.swarm_estimator.tracker.RandomFiniteSetBase.calculate_ospa">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_ospa</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">truth</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">core_method</span><span class="p">:</span> <span class="n">SingleObjectDistance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">true_covs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">state_inds</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the OSPA distance between the truth at all timesteps.</span>

<span class="sd">        Wrapper for :func:`serums.distances.calculate_ospa`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        truth : list</span>
<span class="sd">            Each element represents a timestep and is a list of N x 1 numpy array,</span>
<span class="sd">            one per true agent in the swarm.</span>
<span class="sd">        c : float</span>
<span class="sd">            Distance cutoff for considering a point properly assigned. This</span>
<span class="sd">            influences how cardinality errors are penalized. For :math:`p = 1`</span>
<span class="sd">            it is the penalty given false point estimate.</span>
<span class="sd">        p : int</span>
<span class="sd">            The power of the distance term. Higher values penalize outliers</span>
<span class="sd">            more.</span>
<span class="sd">        core_method : :class:`serums.enums.SingleObjectDistance`, Optional</span>
<span class="sd">            The main distance measure to use for the localization component.</span>
<span class="sd">            The default value of None implies :attr:`.SingleObjectDistance.EUCLIDEAN`.</span>
<span class="sd">        true_covs : list, Optional</span>
<span class="sd">            Each element represents a timestep and is a list of N x N numpy arrays</span>
<span class="sd">            corresonponding to the uncertainty about the true states. Note the</span>
<span class="sd">            order must be consistent with the truth data given. This is only</span>
<span class="sd">            needed for core methods :attr:`SingleObjectDistance.HELLINGER`. The defautl</span>
<span class="sd">            value is None.</span>
<span class="sd">        state_inds : list, optional</span>
<span class="sd">            Indices in the state vector to use, will be applied to the truth</span>
<span class="sd">            data as well. The default is None which means the full state is</span>
<span class="sd">            used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># error checking on optional input arguments</span>
        <span class="n">core_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_input_check</span><span class="p">(</span><span class="n">core_method</span><span class="p">,</span> <span class="n">truth</span><span class="p">,</span> <span class="n">true_covs</span><span class="p">)</span>

        <span class="c1"># setup data structures</span>
        <span class="k">if</span> <span class="n">state_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_find_s_dim</span><span class="p">(</span><span class="n">truth</span><span class="p">)</span>
            <span class="n">state_inds</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">state_dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">state_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_inds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Failed to get state dimension. SKIPPING OSPA calculation&quot;</span><span class="p">)</span>

            <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa_localization</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa_cardinality</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">return</span>
        <span class="n">true_mat</span><span class="p">,</span> <span class="n">true_cov_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_setup_tmat</span><span class="p">(</span>
            <span class="n">truth</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">true_covs</span><span class="p">,</span> <span class="n">state_inds</span>
        <span class="p">)</span>
        <span class="n">est_mat</span><span class="p">,</span> <span class="n">est_cov_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_setup_emat</span><span class="p">(</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">state_inds</span><span class="p">)</span>

        <span class="c1"># find OSPA</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa_localization</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa_cardinality</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">calculate_ospa</span><span class="p">(</span>
            <span class="n">est_mat</span><span class="p">,</span>
            <span class="n">true_mat</span><span class="p">,</span>
            <span class="n">c</span><span class="p">,</span>
            <span class="n">p</span><span class="p">,</span>
            <span class="n">use_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">core_method</span><span class="o">=</span><span class="n">core_method</span><span class="p">,</span>
            <span class="n">true_cov_mat</span><span class="o">=</span><span class="n">true_cov_mat</span><span class="p">,</span>
            <span class="n">est_cov_mat</span><span class="o">=</span><span class="n">est_cov_mat</span><span class="p">,</span>
        <span class="p">)[</span>
            <span class="mi">0</span><span class="p">:</span><span class="mi">6</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="RandomFiniteSetBase.calculate_gospa">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.RandomFiniteSetBase.html#carbs.swarm_estimator.tracker.RandomFiniteSetBase.calculate_gospa">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_gospa</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">truth</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">core_method</span><span class="p">:</span> <span class="n">SingleObjectDistance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">true_covs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">state_inds</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the OSPA distance between the truth at all timesteps.</span>

<span class="sd">        Wrapper for :func:`serums.distances.calculate_ospa`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        truth : list</span>
<span class="sd">            Each element represents a timestep and is a list of N x 1 numpy array,</span>
<span class="sd">            one per true agent in the swarm.</span>
<span class="sd">        c : float</span>
<span class="sd">            Distance cutoff for considering a point properly assigned. This</span>
<span class="sd">            influences how cardinality errors are penalized. For :math:`p = 1`</span>
<span class="sd">            it is the penalty given false point estimate.</span>
<span class="sd">        p : int</span>
<span class="sd">            The power of the distance term. Higher values penalize outliers</span>
<span class="sd">            more.</span>
<span class="sd">        a : int</span>
<span class="sd">            The normalization factor of the distance term. Appropriately penalizes missed</span>
<span class="sd">            or false detection of tracks rather than normalizing by the total maximum</span>
<span class="sd">            cardinality.</span>
<span class="sd">        core_method : :class:`serums.enums.SingleObjectDistance`, Optional</span>
<span class="sd">            The main distance measure to use for the localization component.</span>
<span class="sd">            The default value of None implies :attr:`.SingleObjectDistance.EUCLIDEAN`.</span>
<span class="sd">        true_covs : list, Optional</span>
<span class="sd">            Each element represents a timestep and is a list of N x N numpy arrays</span>
<span class="sd">            corresonponding to the uncertainty about the true states. Note the</span>
<span class="sd">            order must be consistent with the truth data given. This is only</span>
<span class="sd">            needed for core methods :attr:`SingleObjectDistance.HELLINGER`. The defautl</span>
<span class="sd">            value is None.</span>
<span class="sd">        state_inds : list, optional</span>
<span class="sd">            Indices in the state vector to use, will be applied to the truth</span>
<span class="sd">            data as well. The default is None which means the full state is</span>
<span class="sd">            used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># error checking on optional input arguments</span>
        <span class="n">core_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_input_check</span><span class="p">(</span><span class="n">core_method</span><span class="p">,</span> <span class="n">truth</span><span class="p">,</span> <span class="n">true_covs</span><span class="p">)</span>

        <span class="c1"># setup data structures</span>
        <span class="k">if</span> <span class="n">state_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_find_s_dim</span><span class="p">(</span><span class="n">truth</span><span class="p">)</span>
            <span class="n">state_inds</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">state_dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">state_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_inds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Failed to get state dimension. SKIPPING OSPA calculation&quot;</span><span class="p">)</span>

            <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gospa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gospa_localization</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gospa_cardinality</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;normalization&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">return</span>
        <span class="n">true_mat</span><span class="p">,</span> <span class="n">true_cov_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_setup_tmat</span><span class="p">(</span>
            <span class="n">truth</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">true_covs</span><span class="p">,</span> <span class="n">state_inds</span>
        <span class="p">)</span>
        <span class="n">est_mat</span><span class="p">,</span> <span class="n">est_cov_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_setup_emat</span><span class="p">(</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">state_inds</span><span class="p">)</span>

        <span class="c1"># find OSPA</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gospa</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gospa_localization</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gospa_cardinality</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;normalization&quot;</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">calculate_gospa</span><span class="p">(</span>
            <span class="n">est_mat</span><span class="p">,</span>
            <span class="n">true_mat</span><span class="p">,</span>
            <span class="n">c</span><span class="p">,</span>
            <span class="n">p</span><span class="p">,</span>
            <span class="n">a</span><span class="p">,</span>
            <span class="n">use_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">core_method</span><span class="o">=</span><span class="n">core_method</span><span class="p">,</span>
            <span class="n">true_cov_mat</span><span class="o">=</span><span class="n">true_cov_mat</span><span class="p">,</span>
            <span class="n">est_cov_mat</span><span class="o">=</span><span class="n">est_cov_mat</span><span class="p">,</span>
        <span class="p">)[</span>
            <span class="mi">0</span><span class="p">:</span><span class="mi">7</span>
        <span class="p">]</span></div>


    <span class="k">def</span> <span class="nf">_plt_ospa_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">time_units</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">ttl</span><span class="p">,</span> <span class="n">y_lbl</span><span class="p">,</span> <span class="n">opts</span><span class="p">):</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y_val</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">useOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span>

        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span>
            <span class="n">fig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="n">ttl</span><span class="p">,</span> <span class="n">x_lbl</span><span class="o">=</span><span class="s2">&quot;Time (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_units</span><span class="p">),</span> <span class="n">y_lbl</span><span class="o">=</span><span class="n">y_lbl</span>
        <span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span>

    <span class="k">def</span> <span class="nf">_plt_ospa_hist_subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_vals</span><span class="p">,</span> <span class="n">time_units</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">ttl</span><span class="p">,</span> <span class="n">y_lbls</span><span class="p">,</span> <span class="n">opts</span><span class="p">):</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>
        <span class="n">new_plot</span> <span class="o">=</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">num_subs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_vals</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_plot</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="n">ttl</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">y_lbl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">y_vals</span><span class="p">,</span> <span class="n">y_lbls</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">new_plot</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ax</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sharex&quot;</span><span class="p">:</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">num_subs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">useOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;y_lbl&quot;</span><span class="p">:</span> <span class="n">y_lbl</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_vals</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;x_lbl&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Time (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_units</span><span class="p">)</span>
                <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y_val</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_plot</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span>

<div class="viewcode-block" id="RandomFiniteSetBase.plot_ospa_history">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.RandomFiniteSetBase.html#carbs.swarm_estimator.tracker.RandomFiniteSetBase.plot_ospa_history">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_ospa_history</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time_units</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">main_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sub_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_subs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the OSPA history.</span>

<span class="sd">        This requires that the OSPA has been calcualted by the approriate</span>
<span class="sd">        function first.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_units : string, optional</span>
<span class="sd">            Text representing the units of time in the plot. The default is</span>
<span class="sd">            &#39;index&#39;.</span>
<span class="sd">        time : numpy array, optional</span>
<span class="sd">            Vector to use for the x-axis of the plot. If none is given then</span>
<span class="sd">            vector indices are used. The default is None.</span>
<span class="sd">        main_opts : dict, optional</span>
<span class="sd">            Additional plotting options for :meth:`gncpy.plotting.init_plotting_opts`</span>
<span class="sd">            function. Values implemented here are `f_hndl`, and any values</span>
<span class="sd">            relating to title/axis text formatting. The default of None implies</span>
<span class="sd">            the default options are used for the main plot.</span>
<span class="sd">        sub_opts : dict, optional</span>
<span class="sd">            Additional plotting options for :meth:`gncpy.plotting.init_plotting_opts`</span>
<span class="sd">            function. Values implemented here are `f_hndl`, and any values</span>
<span class="sd">            relating to title/axis text formatting. The default of None implies</span>
<span class="sd">            the default options are used for the sub plot.</span>
<span class="sd">        plot_subs : bool, optional</span>
<span class="sd">            Flag indicating if the component statistics (cardinality and</span>
<span class="sd">            localization) should also be plotted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        figs : dict</span>
<span class="sd">            Dictionary of matplotlib figure objects the data was plotted on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;OSPA must be calculated before plotting&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">main_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">main_opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sub_opts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">plot_subs</span><span class="p">:</span>
            <span class="n">sub_opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">()</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2"> OSPA (c = </span><span class="si">{:.1f}</span><span class="s2">, p = </span><span class="si">{:d}</span><span class="s2">)&quot;</span>
        <span class="n">ttl</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">y_lbl</span> <span class="o">=</span> <span class="s2">&quot;OSPA&quot;</span>

        <span class="n">figs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">figs</span><span class="p">[</span><span class="s2">&quot;OSPA&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plt_ospa_hist</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa</span><span class="p">,</span> <span class="n">time_units</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">ttl</span><span class="p">,</span> <span class="n">y_lbl</span><span class="p">,</span> <span class="n">main_opts</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_subs</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2"> OSPA Components (c = </span><span class="si">{:.1f}</span><span class="s2">, p = </span><span class="si">{:d}</span><span class="s2">)&quot;</span>
            <span class="n">ttl</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">y_lbls</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Localiztion&quot;</span><span class="p">,</span> <span class="s2">&quot;Cardinality&quot;</span><span class="p">]</span>
            <span class="n">figs</span><span class="p">[</span><span class="s2">&quot;OSPA_subs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plt_ospa_hist_subs</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ospa_localization</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa_cardinality</span><span class="p">],</span>
                <span class="n">time_units</span><span class="p">,</span>
                <span class="n">time</span><span class="p">,</span>
                <span class="n">ttl</span><span class="p">,</span>
                <span class="n">y_lbls</span><span class="p">,</span>
                <span class="n">main_opts</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">figs</span></div>


<div class="viewcode-block" id="RandomFiniteSetBase.plot_gospa_history">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.RandomFiniteSetBase.html#carbs.swarm_estimator.tracker.RandomFiniteSetBase.plot_gospa_history">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_gospa_history</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time_units</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">main_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sub_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_subs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the GOSPA history.</span>

<span class="sd">        This requires that the GOSPA has been calcualted by the approriate</span>
<span class="sd">        function first.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_units : string, optional</span>
<span class="sd">            Text representing the units of time in the plot. The default is</span>
<span class="sd">            &#39;index&#39;.</span>
<span class="sd">        time : numpy array, optional</span>
<span class="sd">            Vector to use for the x-axis of the plot. If none is given then</span>
<span class="sd">            vector indices are used. The default is None.</span>
<span class="sd">        main_opts : dict, optional</span>
<span class="sd">            Additional plotting options for :meth:`gncpy.plotting.init_plotting_opts`</span>
<span class="sd">            function. Values implemented here are `f_hndl`, and any values</span>
<span class="sd">            relating to title/axis text formatting. The default of None implies</span>
<span class="sd">            the default options are used for the main plot.</span>
<span class="sd">        sub_opts : dict, optional</span>
<span class="sd">            Additional plotting options for :meth:`gncpy.plotting.init_plotting_opts`</span>
<span class="sd">            function. Values implemented here are `f_hndl`, and any values</span>
<span class="sd">            relating to title/axis text formatting. The default of None implies</span>
<span class="sd">            the default options are used for the sub plot.</span>
<span class="sd">        plot_subs : bool, optional</span>
<span class="sd">            Flag indicating if the component statistics (cardinality and</span>
<span class="sd">            localization) should also be plotted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        figs : dict</span>
<span class="sd">            Dictionary of matplotlib figure objects the data was plotted on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;GOSPA must be calculated before plotting&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">main_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">main_opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sub_opts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">plot_subs</span><span class="p">:</span>
            <span class="n">sub_opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">()</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2"> GOSPA (c = </span><span class="si">{:.1f}</span><span class="s2">, p = </span><span class="si">{:d}</span><span class="s2">, a = </span><span class="si">{:d}</span><span class="s2">)&quot;</span>
        <span class="n">ttl</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;normalization&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">y_lbl</span> <span class="o">=</span> <span class="s2">&quot;GOSPA&quot;</span>

        <span class="n">figs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">figs</span><span class="p">[</span><span class="s2">&quot;GOSPA&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plt_ospa_hist</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gospa</span><span class="p">,</span> <span class="n">time_units</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">ttl</span><span class="p">,</span> <span class="n">y_lbl</span><span class="p">,</span> <span class="n">main_opts</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_subs</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2"> GOSPA Components (c = </span><span class="si">{:.1f}</span><span class="s2">, p = </span><span class="si">{:d}</span><span class="s2">, a = </span><span class="si">{:d}</span><span class="s2">)&quot;</span>
            <span class="n">ttl</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gospa_params</span><span class="p">[</span><span class="s2">&quot;normalization&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">y_lbls</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Localiztion&quot;</span><span class="p">,</span> <span class="s2">&quot;Cardinality&quot;</span><span class="p">]</span>
            <span class="n">figs</span><span class="p">[</span><span class="s2">&quot;GOSPA_subs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plt_ospa_hist_subs</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gospa_localization</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gospa_cardinality</span><span class="p">],</span>
                <span class="n">time_units</span><span class="p">,</span>
                <span class="n">time</span><span class="p">,</span>
                <span class="n">ttl</span><span class="p">,</span>
                <span class="n">y_lbls</span><span class="p">,</span>
                <span class="n">main_opts</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">figs</span></div>
</div>



<div class="viewcode-block" id="ProbabilityHypothesisDensity">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity">[docs]</a>
<span class="k">class</span> <span class="nc">ProbabilityHypothesisDensity</span><span class="p">(</span><span class="n">RandomFiniteSetBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the Probability Hypothesis Density filter.</span>

<span class="sd">    The kwargs in the constructor are passed through to the parent constructor.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The filter implementation is based on :cite:`Vo2006_TheGaussianMixtureProbabilityHypothesisDensityFilter`</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    gating_on : bool</span>
<span class="sd">        flag indicating if measurement gating should be performed. The</span>
<span class="sd">        default is False.</span>
<span class="sd">    inv_chi2_gate : float</span>
<span class="sd">        threshold for the chi squared test in the measurement gating. The</span>
<span class="sd">        default is 0.</span>
<span class="sd">    extract_threshold : float</span>
<span class="sd">        threshold for extracting the state. The default is 0.5.</span>
<span class="sd">    prune_threshold : float</span>
<span class="sd">        threshold for removing hypotheses. The default is 10**-5.</span>
<span class="sd">    merge_threshold : float</span>
<span class="sd">        threshold for merging hypotheses. The default is 4.</span>
<span class="sd">    max_gauss : int</span>
<span class="sd">        max number of gaussians to use. The default is 100.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ProbabilityHypothesisDensity.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gating_on</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">inv_chi2_gate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">extract_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">prune_threshold</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
        <span class="n">merge_threshold</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">max_gauss</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span> <span class="o">=</span> <span class="n">gating_on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_chi2_gate</span> <span class="o">=</span> <span class="n">inv_chi2_gate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extract_threshold</span> <span class="o">=</span> <span class="n">extract_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prune_threshold</span> <span class="o">=</span> <span class="n">prune_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge_threshold</span> <span class="o">=</span> <span class="n">merge_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_gauss</span> <span class="o">=</span> <span class="n">max_gauss</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span> <span class="o">=</span> <span class="n">smodels</span><span class="o">.</span><span class="n">GaussianMixture</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProbabilityHypothesisDensity.save_filter_state">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.save_filter_state">[docs]</a>
    <span class="k">def</span> <span class="nf">save_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves filter variables so they can be restored later.&quot;&quot;&quot;</span>
        <span class="n">filt_state</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>

        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Not implmented yet&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filt_state</span></div>


<div class="viewcode-block" id="ProbabilityHypothesisDensity.load_filter_state">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.load_filter_state">[docs]</a>
    <span class="k">def</span> <span class="nf">load_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes filter using saved filter state.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        filt_state : dict</span>
<span class="sd">            Dictionary generated by :meth:`save_filter_state`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Not implmented yet&quot;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read only list of extracted states.</span>

<span class="sd">        This is a list with 1 element per timestep, and each element is a list</span>
<span class="sd">        of the best states extracted at that timestep. The order of each</span>
<span class="sd">        element corresponds to the label order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">covariances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read only list of extracted covariances.</span>

<span class="sd">        This is a list with 1 element per timestep, and each element is a list</span>
<span class="sd">        of the best covariances extracted at that timestep. The order of each</span>
<span class="sd">        element corresponds to the state order.</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">            RuntimeWarning</span>
<span class="sd">                If the class is not saving the covariances, and returns an</span>
<span class="sd">                empty list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Not saving covariances&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read only cardinality of the RFS.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_gen_spawned_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gaussMix</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spawn_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">spawn_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gauss_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">smodels</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">covariance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spawn_cov</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">gaussMix</span><span class="o">.</span><span class="n">means</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">smodels</span><span class="o">.</span><span class="n">GaussianMixture</span><span class="p">(</span>
                <span class="n">distributions</span><span class="o">=</span><span class="n">gauss_list</span><span class="p">,</span>
                <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spawn_weight</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gauss_list</span><span class="p">))],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;self.spawn_cov and self.spawn_weight must be specified.&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="ProbabilityHypothesisDensity.predict">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.predict">[docs]</a>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prediction step of the PHD filter.</span>

<span class="sd">        This predicts new hypothesis, and propogates them to the next time</span>
<span class="sd">        step. It also updates the cardinality distribution. Because this calls</span>
<span class="sd">        the inner filter&#39;s predict function, the keyword arguments must contain</span>
<span class="sd">        any information needed by that function.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            current timestep</span>
<span class="sd">        filt_args : dict, optional</span>
<span class="sd">            Passed to the inner filter. The default is {}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_spawning</span><span class="p">:</span>
            <span class="n">spawn_mix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_spawned_targets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_prob_density</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_spawning</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">add_components</span><span class="p">(</span>
                <span class="n">spawn_mix</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">spawn_mix</span><span class="o">.</span><span class="n">covariances</span><span class="p">,</span> <span class="n">spawn_mix</span><span class="o">.</span><span class="n">weights</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">gm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">add_components</span><span class="p">(</span><span class="n">gm</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">gm</span><span class="o">.</span><span class="n">covariances</span><span class="p">,</span> <span class="n">gm</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_predict_prob_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">probDensity</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Predicts the probability density.</span>

<span class="sd">        Loops over all elements in a probability distribution and performs</span>
<span class="sd">        the filter prediction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            current timestep</span>
<span class="sd">        probDensity : :class:`serums.models.GaussianMixture`</span>
<span class="sd">            Probability density to perform prediction on.</span>
<span class="sd">        filt_args : dict</span>
<span class="sd">            Passed directly to the inner filter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gm : :class:`serums.models.GaussianMixture`</span>
<span class="sd">            predicted Gaussian mixture.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_survive</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>
        <span class="n">n_terms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="n">covariances</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_terms</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_terms</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">covariances</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="n">P</span>
            <span class="n">n_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>
            <span class="n">covariances</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">means</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_mean</span>
        <span class="k">return</span> <span class="n">smodels</span><span class="o">.</span><span class="n">GaussianMixture</span><span class="p">(</span>
            <span class="n">means</span><span class="o">=</span><span class="n">means</span><span class="p">,</span> <span class="n">covariances</span><span class="o">=</span><span class="n">covariances</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span>
        <span class="p">)</span>

<div class="viewcode-block" id="ProbabilityHypothesisDensity.correct">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.correct">[docs]</a>
    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas_in</span><span class="p">,</span> <span class="n">meas_mat_args</span><span class="o">=</span><span class="p">{},</span> <span class="n">est_meas_args</span><span class="o">=</span><span class="p">{},</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correction step of the PHD filter.</span>

<span class="sd">        This corrects the hypotheses based on the measurements and gates the</span>
<span class="sd">        measurements according to the class settings. It also updates the</span>
<span class="sd">        cardinality distribution.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            current timestep</span>
<span class="sd">        meas_in : list</span>
<span class="sd">            2d numpy arrays representing a measurement.</span>
<span class="sd">        meas_mat_args : dict, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters get measurement</span>
<span class="sd">            matrix function. Only used if gating is on. The default is {}.</span>
<span class="sd">        est_meas_args : TYPE, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters estimate</span>
<span class="sd">            measurements function. Only used if gating is on. The default is {}.</span>
<span class="sd">        filt_args : dict, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters correct function.</span>
<span class="sd">            The default is {}.</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">            Fix the measurement gating</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meas</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">meas_in</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span><span class="p">:</span>
            <span class="n">meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gate_meas</span><span class="p">(</span>
                <span class="n">meas</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">covariances</span><span class="p">,</span>
                <span class="n">meas_mat_args</span><span class="p">,</span>
                <span class="n">est_meas_args</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>

        <span class="n">gmix</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="p">)</span>
        <span class="n">gmix</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gmix</span><span class="o">.</span><span class="n">weights</span><span class="p">]</span>
        <span class="n">gm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_prob_density</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>
        <span class="n">gm</span><span class="o">.</span><span class="n">add_components</span><span class="p">(</span><span class="n">gmix</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">gmix</span><span class="o">.</span><span class="n">covariances</span><span class="p">,</span> <span class="n">gmix</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span> <span class="o">=</span> <span class="n">gm</span></div>


    <span class="k">def</span> <span class="nf">_correct_prob_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">probDensity</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Corrects the probability densities.</span>

<span class="sd">        Loops over all elements in a probability distribution and preforms</span>
<span class="sd">        the filter correction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meas : list</span>
<span class="sd">            2d numpy arrays of each measurement.</span>
<span class="sd">        probDensity : :py:class:`serums.models.GaussianMixture`</span>
<span class="sd">            probability density to run correction on.</span>
<span class="sd">        filt_args : dict</span>
<span class="sd">            arguements to pass to the inner filter correct function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gm : :py:class:`serums.models.GaussianMixture`</span>
<span class="sd">            corrected probability density.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">covariances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">det_weights</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">weights</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">meas</span><span class="p">:</span>
            <span class="n">w_lst</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">covariances</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">qz</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>
                <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">qz</span> <span class="o">*</span> <span class="n">det_weights</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>
                <span class="n">covariances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
                <span class="n">w_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">weights</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span><span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w_lst</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">w_lst</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">smodels</span><span class="o">.</span><span class="n">GaussianMixture</span><span class="p">(</span>
            <span class="n">means</span><span class="o">=</span><span class="n">means</span><span class="p">,</span> <span class="n">covariances</span><span class="o">=</span><span class="n">covariances</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prune</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes hypotheses below a threshold.</span>

<span class="sd">        This should be called once per time step after the correction and</span>
<span class="sd">        before the state extraction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">prune_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">remove_components</span><span class="p">(</span><span class="n">inds</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">inds</span>

    <span class="k">def</span> <span class="nf">_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merges nearby hypotheses.&quot;&quot;&quot;</span>
        <span class="n">loop_inds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">)))</span>

        <span class="n">w_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">m_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">p_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">loop_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">))</span>
            <span class="n">comp_inds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">inv_cov</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">covariances</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">loop_inds</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">inv_cov</span> <span class="o">@</span> <span class="n">diff</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_threshold</span><span class="p">:</span>
                    <span class="n">comp_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
            <span class="n">w_new</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">comp_inds</span><span class="p">])</span>
            <span class="n">m_new</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">comp_inds</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="o">/</span> <span class="n">w_new</span>
            <span class="p">)</span>
            <span class="n">p_new</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">covariances</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">comp_inds</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="o">/</span> <span class="n">w_new</span>
            <span class="p">)</span>

            <span class="n">w_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w_new</span><span class="p">)</span>
            <span class="n">m_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m_new</span><span class="p">)</span>
            <span class="n">p_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_new</span><span class="p">)</span>

            <span class="n">loop_inds</span> <span class="o">=</span> <span class="n">loop_inds</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">comp_inds</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">comp_inds</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span> <span class="o">=</span> <span class="n">smodels</span><span class="o">.</span><span class="n">GaussianMixture</span><span class="p">(</span>
            <span class="n">means</span><span class="o">=</span><span class="n">m_lst</span><span class="p">,</span> <span class="n">covariances</span><span class="o">=</span><span class="n">p_lst</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w_lst</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes least likely hypotheses until a maximum number is reached.</span>

<span class="sd">        This should be called once per time step after pruning and</span>
<span class="sd">        before the state extraction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_gauss</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">remove_components</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">max_gauss</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">max_gauss</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[]</span>

<div class="viewcode-block" id="ProbabilityHypothesisDensity.extract_states">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.extract_states">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts the best state estimates.</span>

<span class="sd">        This extracts the best states from the distribution. It should be</span>
<span class="sd">        called once per time step after the correction function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_threshold</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">s_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">c_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">:</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span>
            <span class="n">num_reps</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
            <span class="n">s_lst</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">jj</span><span class="p">]]</span> <span class="o">*</span> <span class="n">num_reps</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
                <span class="n">c_lst</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">covariances</span><span class="p">[</span><span class="n">jj</span><span class="p">]]</span> <span class="o">*</span> <span class="n">num_reps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_lst</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_lst</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProbabilityHypothesisDensity.cleanup">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.cleanup">[docs]</a>
    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">enable_prune</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">enable_cap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">enable_merge</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">enable_extract</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">extract_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs the cleanup step of the filter.</span>

<span class="sd">        This can prune, cap, and extract states. It must be called once per</span>
<span class="sd">        timestep. If this is called with `enable_extract` set to true then</span>
<span class="sd">        the extract states method does not need to be called separately. It is</span>
<span class="sd">        recommended to call this function instead of</span>
<span class="sd">        :meth:`carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.extract_states`</span>
<span class="sd">        directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        enable_prune : bool, optional</span>
<span class="sd">            Flag indicating if prunning should be performed. The default is True.</span>
<span class="sd">        enable_cap : bool, optional</span>
<span class="sd">            Flag indicating if capping should be performed. The default is True.</span>
<span class="sd">        enable_merge : bool, optional</span>
<span class="sd">            Flag indicating if merging should be performed. The default is True.</span>
<span class="sd">        enable_extract : bool, optional</span>
<span class="sd">            Flag indicating if state extraction should be performed. The default is True.</span>
<span class="sd">        extract_kwargs : dict, optional</span>
<span class="sd">            Extra arguments to pass to the extract function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">enable_prune</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prune</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">enable_merge</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_merge</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">enable_cap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cap</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">enable_extract</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extract_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">extract_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extract_states</span><span class="p">(</span><span class="o">**</span><span class="n">extract_kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">__ani_state_plotting</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">f_hndl</span><span class="p">,</span>
        <span class="n">tt</span><span class="p">,</span>
        <span class="n">states</span><span class="p">,</span>
        <span class="n">show_sig</span><span class="p">,</span>
        <span class="n">plt_inds</span><span class="p">,</span>
        <span class="n">sig_bnd</span><span class="p">,</span>
        <span class="n">color</span><span class="p">,</span>
        <span class="n">marker</span><span class="p">,</span>
        <span class="n">state_lbl</span><span class="p">,</span>
        <span class="n">added_sig_lbl</span><span class="p">,</span>
        <span class="n">added_state_lbl</span><span class="p">,</span>
        <span class="n">scat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">scat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">added_state_lbl</span><span class="p">:</span>
                <span class="n">scat</span> <span class="o">=</span> <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                    <span class="p">[],</span> <span class="p">[],</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scat</span> <span class="o">=</span> <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                    <span class="p">[],</span>
                    <span class="p">[],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="n">state_lbl</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scat</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_sig</span><span class="p">:</span>
            <span class="n">sigs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">cov</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">]):</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">sigs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span>
            <span class="c1"># plot</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">sig</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sigs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">calc_error_ellipse</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig_bnd</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">added_sig_lbl</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$</span><span class="si">{}</span><span class="s2">\sigma$ Error Ellipses&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sig_bnd</span><span class="p">)</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">Ellipse</span><span class="p">(</span>
                        <span class="n">xy</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                        <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                        <span class="n">angle</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                        <span class="n">zorder</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span>
                        <span class="n">animated</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">Ellipse</span><span class="p">(</span>
                        <span class="n">xy</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                        <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                        <span class="n">angle</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                        <span class="n">zorder</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span>
                        <span class="n">animated</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">e</span><span class="o">.</span><span class="n">set_clip_box</span><span class="p">(</span><span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>
                <span class="n">e</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.15</span><span class="p">)</span>
                <span class="n">e</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">scat</span><span class="o">.</span><span class="n">set_offsets</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scat</span>

<div class="viewcode-block" id="ProbabilityHypothesisDensity.plot_states">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.plot_states">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">plt_inds</span><span class="p">,</span>
        <span class="n">state_lbl</span><span class="o">=</span><span class="s2">&quot;States&quot;</span><span class="p">,</span>
        <span class="n">ttl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">state_color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_lbl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_lbl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the best estimate for the states.</span>

<span class="sd">        This assumes that the states have been extracted. It&#39;s designed to plot</span>
<span class="sd">        two of the state variables (typically x/y position). The error ellipses</span>
<span class="sd">        are calculated according to :cite:`Hoover1984_AlgorithmsforConfidenceCirclesandEllipses`</span>

<span class="sd">        Keyword arguments are processed with</span>
<span class="sd">        :meth:`gncpy.plotting.init_plotting_opts`. This function</span>
<span class="sd">        implements</span>

<span class="sd">            - f_hndl</span>
<span class="sd">            - true_states</span>
<span class="sd">            - sig_bnd</span>
<span class="sd">            - rng</span>
<span class="sd">            - meas_inds</span>
<span class="sd">            - lgnd_loc</span>
<span class="sd">            - marker</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plt_inds : list</span>
<span class="sd">            List of indices in the state vector to plot</span>
<span class="sd">        state_lbl : string</span>
<span class="sd">            Value to appear in legend for the states. Only appears if the</span>
<span class="sd">            legend is shown</span>
<span class="sd">        ttl : string, optional</span>
<span class="sd">            Title for the plot, if None a default title is generated. The default</span>
<span class="sd">            is None.</span>
<span class="sd">        x_lbl : string</span>
<span class="sd">            Label for the x-axis.</span>
<span class="sd">        y_lbl : string</span>
<span class="sd">            Label for the y-axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Matplotlib figure</span>
<span class="sd">            Instance of the matplotlib figure used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>
        <span class="n">true_states</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;true_states&quot;</span><span class="p">]</span>
        <span class="n">sig_bnd</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;sig_bnd&quot;</span><span class="p">]</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;rng&quot;</span><span class="p">]</span>
        <span class="n">meas_inds</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;meas_inds&quot;</span><span class="p">]</span>
        <span class="n">lgnd_loc</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;lgnd_loc&quot;</span><span class="p">]</span>
        <span class="n">marker</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;marker&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ttl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ttl</span> <span class="o">=</span> <span class="s2">&quot;State Estimates&quot;</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_lbl</span> <span class="o">=</span> <span class="s2">&quot;x-position&quot;</span>
        <span class="k">if</span> <span class="n">y_lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_lbl</span> <span class="o">=</span> <span class="s2">&quot;y-position&quot;</span>
        <span class="n">plt_meas</span> <span class="o">=</span> <span class="n">meas_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">show_sig</span> <span class="o">=</span> <span class="n">sig_bnd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span>

        <span class="n">s_lst</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">)</span>
        <span class="n">x_dim</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">f_hndl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># get state dimension</span>
        <span class="k">for</span> <span class="n">states</span> <span class="ow">in</span> <span class="n">s_lst</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x_dim</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                <span class="k">break</span>
        <span class="c1"># get array of all state values for each label</span>
        <span class="n">added_sig_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_true_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_state_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_meas_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">state_color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">state_color</span>
        <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">states</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_lst</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">show_sig</span><span class="p">:</span>
                <span class="n">sigs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">cov</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">]):</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">sigs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span>
                <span class="c1"># plot</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">sig</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sigs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">calc_error_ellipse</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig_bnd</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">added_sig_lbl</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$</span><span class="si">{}</span><span class="s2">\sigma$ Error Ellipses&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sig_bnd</span><span class="p">)</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">Ellipse</span><span class="p">(</span>
                            <span class="n">xy</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">,</span> <span class="n">ii</span><span class="p">],</span>
                            <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                            <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                            <span class="n">angle</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                            <span class="n">zorder</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span>
                            <span class="n">label</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">added_sig_lbl</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">Ellipse</span><span class="p">(</span>
                            <span class="n">xy</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">,</span> <span class="n">ii</span><span class="p">],</span>
                            <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                            <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                            <span class="n">angle</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                            <span class="n">zorder</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">set_clip_box</span><span class="p">(</span><span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.15</span><span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">added_state_lbl</span><span class="p">:</span>
                <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:],</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="n">state_lbl</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">added_state_lbl</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:],</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># if true states are available then plot them</span>
        <span class="k">if</span> <span class="n">true_states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">states</span> <span class="ow">in</span> <span class="n">true_states</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x_dim</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                        <span class="k">break</span>
            <span class="n">max_true</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">true_states</span><span class="p">])</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x_dim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_states</span><span class="p">),</span> <span class="n">max_true</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">states</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">true_states</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">states</span><span class="p">):</span>
                    <span class="n">x</span><span class="p">[:,</span> <span class="p">[</span><span class="n">tt</span><span class="p">],</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_true</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">added_true_lbl</span><span class="p">:</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;True Trajectories&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">added_true_lbl</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">if</span> <span class="n">plt_meas</span><span class="p">:</span>
            <span class="n">meas_x</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">meas_y</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">meas_tt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="p">:</span>
                <span class="n">mx_ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">meas_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meas_tt</span><span class="p">]</span>
                <span class="n">my_ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">meas_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meas_tt</span><span class="p">]</span>
                <span class="n">meas_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">mx_ii</span><span class="p">)</span>
                <span class="n">meas_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">my_ii</span><span class="p">)</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">)</span>
            <span class="n">meas_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">meas_x</span><span class="p">)</span>
            <span class="n">meas_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">meas_y</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">added_meas_lbl</span><span class="p">:</span>
                <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                    <span class="n">meas_x</span><span class="p">,</span>
                    <span class="n">meas_y</span><span class="p">,</span>
                    <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Measurements&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                    <span class="n">meas_x</span><span class="p">,</span>
                    <span class="n">meas_y</span><span class="p">,</span>
                    <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span><span class="n">f_hndl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="n">ttl</span><span class="p">,</span> <span class="n">x_lbl</span><span class="o">=</span><span class="n">x_lbl</span><span class="p">,</span> <span class="n">y_lbl</span><span class="o">=</span><span class="n">y_lbl</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lgnd_loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">lgnd_loc</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">f_hndl</span></div>


<div class="viewcode-block" id="ProbabilityHypothesisDensity.animate_state_plot">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.animate_state_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">animate_state_plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">plt_inds</span><span class="p">,</span>
        <span class="n">state_lbl</span><span class="o">=</span><span class="s2">&quot;States&quot;</span><span class="p">,</span>
        <span class="n">state_color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">interval</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span>
        <span class="n">repeat</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">repeat_delay</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">save_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates an animated plot of the states.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plt_inds : list</span>
<span class="sd">            indices of the state vector to plot.</span>
<span class="sd">        state_lbl : string, optional</span>
<span class="sd">            label for the states. The default is &#39;States&#39;.</span>
<span class="sd">        state_color : tuple, optional</span>
<span class="sd">            3-tuple for rgb value. The default is None.</span>
<span class="sd">        interval : int, optional</span>
<span class="sd">            interval of the animation in ms. The default is 250.</span>
<span class="sd">        repeat : bool, optional</span>
<span class="sd">            flag indicating if the animation loops. The default is True.</span>
<span class="sd">        repeat_delay : int, optional</span>
<span class="sd">            delay between loops in ms. The default is 1000.</span>
<span class="sd">        save_path : string, optional</span>
<span class="sd">            file path and name to save the gif, does not save if not given.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Standard plotting options for</span>
<span class="sd">            :meth:`gncpy.plotting.init_plotting_opts`. This function</span>
<span class="sd">            implements</span>

<span class="sd">                - f_hndl</span>
<span class="sd">                - sig_bnd</span>
<span class="sd">                - rng</span>
<span class="sd">                - meas_inds</span>
<span class="sd">                - lgnd_loc</span>
<span class="sd">                - marker</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        anim :</span>
<span class="sd">            handle to the animation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>
        <span class="n">sig_bnd</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;sig_bnd&quot;</span><span class="p">]</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;rng&quot;</span><span class="p">]</span>
        <span class="n">meas_inds</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;meas_inds&quot;</span><span class="p">]</span>
        <span class="n">lgnd_loc</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;lgnd_loc&quot;</span><span class="p">]</span>
        <span class="n">marker</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;marker&quot;</span><span class="p">]</span>

        <span class="n">plt_meas</span> <span class="o">=</span> <span class="n">meas_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">show_sig</span> <span class="o">=</span> <span class="n">sig_bnd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span>

        <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span>
            <span class="n">f_hndl</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">opts</span><span class="p">,</span>
            <span class="n">ttl</span><span class="o">=</span><span class="s2">&quot;State Estimates&quot;</span><span class="p">,</span>
            <span class="n">x_lbl</span><span class="o">=</span><span class="s2">&quot;x-position&quot;</span><span class="p">,</span>
            <span class="n">y_lbl</span><span class="o">=</span><span class="s2">&quot;y-position&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">fr_number</span> <span class="o">=</span> <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="s2">&quot;0&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">xycoords</span><span class="o">=</span><span class="s2">&quot;axes fraction&quot;</span><span class="p">,</span>
            <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">),</span>
            <span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
            <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
            <span class="n">va</span><span class="o">=</span><span class="s2">&quot;top&quot;</span><span class="p">,</span>
            <span class="n">animated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">added_sig_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_state_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_meas_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">state_color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s_color</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s_color</span> <span class="o">=</span> <span class="n">state_color</span>
        <span class="n">state_scat</span> <span class="o">=</span> <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="p">[],</span> <span class="p">[],</span> <span class="n">color</span><span class="o">=</span><span class="n">s_color</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">state_lbl</span>
        <span class="p">)</span>
        <span class="n">meas_scat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">plt_meas</span><span class="p">:</span>
            <span class="n">m_color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">meas_scat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">added_meas_lbl</span><span class="p">:</span>
                    <span class="n">lbl</span> <span class="o">=</span> <span class="s2">&quot;Measurements&quot;</span>
                    <span class="n">meas_scat</span> <span class="o">=</span> <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                        <span class="p">[],</span>
                        <span class="p">[],</span>
                        <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">m_color</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span>
                        <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="n">lbl</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">added_meas_lbl</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">meas_scat</span> <span class="o">=</span> <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                        <span class="p">[],</span>
                        <span class="p">[],</span>
                        <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">m_color</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span>
                        <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="o">*</span><span class="n">fargs</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">added_sig_lbl</span>
            <span class="k">nonlocal</span> <span class="n">added_state_lbl</span>
            <span class="k">nonlocal</span> <span class="n">added_meas_lbl</span>
            <span class="k">nonlocal</span> <span class="n">state_scat</span>
            <span class="k">nonlocal</span> <span class="n">meas_scat</span>
            <span class="k">nonlocal</span> <span class="n">fr_number</span>

            <span class="n">fr_number</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s2">&quot;Timestep: </span><span class="si">{j}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">tt</span><span class="p">))</span>

            <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span>
            <span class="n">state_scat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ani_state_plotting</span><span class="p">(</span>
                <span class="n">f_hndl</span><span class="p">,</span>
                <span class="n">tt</span><span class="p">,</span>
                <span class="n">states</span><span class="p">,</span>
                <span class="n">show_sig</span><span class="p">,</span>
                <span class="n">plt_inds</span><span class="p">,</span>
                <span class="n">sig_bnd</span><span class="p">,</span>
                <span class="n">s_color</span><span class="p">,</span>
                <span class="n">marker</span><span class="p">,</span>
                <span class="n">state_lbl</span><span class="p">,</span>
                <span class="n">added_sig_lbl</span><span class="p">,</span>
                <span class="n">added_state_lbl</span><span class="p">,</span>
                <span class="n">scat</span><span class="o">=</span><span class="n">state_scat</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">added_sig_lbl</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">added_state_lbl</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">plt_meas</span><span class="p">:</span>
                <span class="n">meas_tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span>

                <span class="n">meas_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">meas_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meas_tt</span><span class="p">]</span>
                <span class="n">meas_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">meas_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meas_tt</span><span class="p">]</span>

                <span class="n">meas_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">meas_x</span><span class="p">)</span>
                <span class="n">meas_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">meas_y</span><span class="p">)</span>
                <span class="n">meas_scat</span><span class="o">.</span><span class="n">set_offsets</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">meas_x</span><span class="p">,</span> <span class="n">meas_y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># plt.figure(f_hndl.number)</span>
        <span class="n">anim</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span>
            <span class="n">f_hndl</span><span class="p">,</span>
            <span class="n">update</span><span class="p">,</span>
            <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">),</span>
            <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>
            <span class="n">repeat_delay</span><span class="o">=</span><span class="n">repeat_delay</span><span class="p">,</span>
            <span class="n">repeat</span><span class="o">=</span><span class="n">repeat</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">lgnd_loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">lgnd_loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">PillowWriter</span><span class="p">(</span><span class="n">fps</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
            <span class="n">anim</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="n">writer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">anim</span></div>
</div>



<div class="viewcode-block" id="CardinalizedPHD">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.CardinalizedPHD.html#carbs.swarm_estimator.tracker.CardinalizedPHD">[docs]</a>
<span class="k">class</span> <span class="nc">CardinalizedPHD</span><span class="p">(</span><span class="n">ProbabilityHypothesisDensity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the Cardinalized Probability Hypothesis Density filter.</span>

<span class="sd">    The kwargs in the constructor are passed through to the parent constructor.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The filter implementation is based on</span>
<span class="sd">    :cite:`Vo2006_TheCardinalizedProbabilityHypothesisDensityFilterforLinearGaussianMultiTargetModels`</span>
<span class="sd">    and :cite:`Vo2007_AnalyticImplementationsoftheCardinalizedProbabilityHypothesisDensityFilter`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    agents_per_state : list, optional</span>
<span class="sd">        number of agents per state. The default is [].</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CardinalizedPHD.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.CardinalizedPHD.html#carbs.swarm_estimator.tracker.CardinalizedPHD.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_expected_card</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agents_per_state</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_expected_card</span> <span class="o">=</span> <span class="n">max_expected_card</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># local copy for internal modification</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_time_hist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># local copy for internal modification</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_states_per_time</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_expected_card</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum expected cardinality. The default is 10.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_expected_card</span>

    <span class="nd">@max_expected_card</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">max_expected_card</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_expected_card</span> <span class="o">=</span> <span class="n">x</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cardinality of the RFS.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span>

<div class="viewcode-block" id="CardinalizedPHD.predict">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.CardinalizedPHD.html#carbs.swarm_estimator.tracker.CardinalizedPHD.predict">[docs]</a>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prediction step of the CPHD filter.</span>

<span class="sd">        This predicts new hypothesis, and propogates them to the next time</span>
<span class="sd">        step. It also updates the cardinality distribution.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            current timestep</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            See :meth:carbs.swarm_estimator.tracker.ProbabilityHypothesisDensity.predict`</span>
<span class="sd">            for the available arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">survive_cdn_predict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))),</span>
                        <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))),</span>
                        <span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_survive</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_death</span><span class="p">),</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">survive_cdn_predict</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
        <span class="n">cdn_predict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Only using the first birth term in cardinality update&quot;</span><span class="p">)</span>
        <span class="n">birth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">weights</span><span class="p">])</span>
        <span class="p">)</span>  <span class="c1"># NOTE: assumes 1 GM for the birth model</span>
        <span class="n">log_birth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">birth</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">birth</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">log_birth</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))]</span>
                <span class="p">)</span>
                <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span> <span class="o">*</span> <span class="n">survive_cdn_predict</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">cdn_predict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdn_predict</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cdn_predict</span><span class="p">))</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_card_time_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">))</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="CardinalizedPHD.correct">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.CardinalizedPHD.html#carbs.swarm_estimator.tracker.CardinalizedPHD.correct">[docs]</a>
    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas_in</span><span class="p">,</span> <span class="n">meas_mat_args</span><span class="o">=</span><span class="p">{},</span> <span class="n">est_meas_args</span><span class="o">=</span><span class="p">{},</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correction step of the CPHD filter.</span>

<span class="sd">        This corrects the hypotheses based on the measurements and gates the</span>
<span class="sd">        measurements according to the class settings. It also updates the</span>
<span class="sd">        cardinality distribution.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            current timestep</span>
<span class="sd">        meas_in : list</span>
<span class="sd">            2d numpy arrays representing a measurement.</span>
<span class="sd">        meas_mat_args : dict, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters get measurement</span>
<span class="sd">            matrix function. Only used if gating is on. The default is {}.</span>
<span class="sd">        est_meas_args : TYPE, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters estimate</span>
<span class="sd">            measurements function. Only used if gating is on. The default is {}.</span>
<span class="sd">        filt_args : TYPE, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters correct function.</span>
<span class="sd">            The default is {}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meas</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">meas_in</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span><span class="p">:</span>
            <span class="n">meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gate_meas</span><span class="p">(</span>
                <span class="n">meas</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">covariances</span><span class="p">,</span>
                <span class="n">meas_mat_args</span><span class="p">,</span>
                <span class="n">est_meas_args</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>

        <span class="n">gmix</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="p">)</span>  <span class="c1"># predicted gm</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_prob_density</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">gmix</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_correct_prob_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">probDensity</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function for correction step.</span>

<span class="sd">        Loops over all elements in a probability distribution and preforms</span>
<span class="sd">        the filter correction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">weights</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">weights</span><span class="p">)):</span>
            <span class="n">w_pred</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">xdim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">plen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="n">zlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>

        <span class="n">qz_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">plen</span><span class="p">,</span> <span class="n">zlen</span><span class="p">))</span>
        <span class="n">mean_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">zlen</span><span class="p">,</span> <span class="n">xdim</span><span class="p">,</span> <span class="n">plen</span><span class="p">))</span>
        <span class="n">cov_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">zlen</span><span class="p">,</span> <span class="n">plen</span><span class="p">,</span> <span class="n">xdim</span><span class="p">,</span> <span class="n">xdim</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">z_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zlen</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">p_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">plen</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">covariances</span><span class="p">[</span><span class="n">p_ind</span><span class="p">]</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">p_ind</span><span class="p">]</span>

                <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">qz</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span>
                    <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">[</span><span class="n">z_ind</span><span class="p">],</span> <span class="n">state</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span>
                <span class="p">)</span>
                <span class="n">qz_temp</span><span class="p">[</span><span class="n">p_ind</span><span class="p">,</span> <span class="n">z_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">qz</span>
                <span class="n">mean_temp</span><span class="p">[</span><span class="n">z_ind</span><span class="p">,</span> <span class="p">:,</span> <span class="n">p_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>
                <span class="n">cov_temp</span><span class="p">[</span><span class="n">z_ind</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">xivals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">zlen</span><span class="p">)</span>
        <span class="n">pdc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zlen</span><span class="p">):</span>
            <span class="n">xivals</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w_pred</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">qz_temp</span><span class="p">[:,</span> <span class="p">[</span><span class="n">e</span><span class="p">]])</span>
        <span class="n">esfvals_E</span> <span class="o">=</span> <span class="n">get_elem_sym_fnc</span><span class="p">(</span><span class="n">xivals</span><span class="p">)</span>
        <span class="n">esfvals_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">zlen</span><span class="p">,</span> <span class="n">zlen</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zlen</span><span class="p">):</span>
            <span class="n">xi_temp</span> <span class="o">=</span> <span class="n">xivals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">xi_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">xi_temp</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">esfvals_D</span><span class="p">[:,</span> <span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">get_elem_sym_fnc</span><span class="p">(</span><span class="n">xi_temp</span><span class="p">)</span>
        <span class="n">ups0_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ups1_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ups1_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">zlen</span><span class="p">))</span>

        <span class="n">tot_w_pred</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w_pred</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">terms0_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">zlen</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">zlen</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">+</span> <span class="p">(</span><span class="n">zlen</span> <span class="o">-</span> <span class="n">jj</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span><span class="p">)</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span> <span class="o">-</span> <span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                <span class="n">t4</span> <span class="o">=</span> <span class="p">(</span><span class="n">nn</span> <span class="o">-</span> <span class="n">jj</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_death</span><span class="p">)</span>
                <span class="n">t5</span> <span class="o">=</span> <span class="o">-</span><span class="n">jj</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tot_w_pred</span><span class="p">)</span>
                <span class="n">terms0_E</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span> <span class="o">+</span> <span class="n">t4</span> <span class="o">+</span> <span class="n">t5</span><span class="p">)</span> <span class="o">*</span> <span class="n">esfvals_E</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
            <span class="n">ups0_E</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">terms0_E</span><span class="p">)</span>

            <span class="n">terms1_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">zlen</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">zlen</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nn</span> <span class="o">&gt;=</span> <span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">+</span> <span class="p">(</span><span class="n">zlen</span> <span class="o">-</span> <span class="n">jj</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span><span class="p">)</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                    <span class="n">t3</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span> <span class="o">-</span> <span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                    <span class="n">t4</span> <span class="o">=</span> <span class="p">(</span><span class="n">nn</span> <span class="o">-</span> <span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_death</span><span class="p">)</span>
                    <span class="n">t5</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tot_w_pred</span><span class="p">)</span>
                    <span class="n">terms1_E</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span> <span class="o">+</span> <span class="n">t4</span> <span class="o">+</span> <span class="n">t5</span><span class="p">)</span> <span class="o">*</span> <span class="n">esfvals_E</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
            <span class="n">ups1_E</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">terms1_E</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">zlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">terms1_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">zlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">zlen</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">ell</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">zlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">((</span><span class="n">zlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">nn</span> <span class="o">&gt;=</span> <span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">t1</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">+</span> <span class="p">((</span><span class="n">zlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">jj</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span>
                            <span class="p">)</span>
                            <span class="n">t2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                            <span class="n">t3</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span> <span class="o">-</span> <span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                            <span class="p">)</span>
                            <span class="n">t4</span> <span class="o">=</span> <span class="p">(</span><span class="n">nn</span> <span class="o">-</span> <span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_death</span><span class="p">)</span>
                            <span class="n">t5</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tot_w_pred</span><span class="p">)</span>
                            <span class="n">terms1_D</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ell</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span> <span class="o">+</span> <span class="n">t4</span> <span class="o">+</span> <span class="n">t5</span><span class="p">)</span> <span class="o">*</span> <span class="n">esfvals_D</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ell</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="p">)</span>
                <span class="n">ups1_D</span><span class="p">[</span><span class="n">nn</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">terms1_D</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">gmix</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">probDensity</span><span class="p">)</span>
        <span class="n">w_update</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">((</span><span class="n">ups1_E</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ups0_E</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">))</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span>
            <span class="o">*</span> <span class="n">w_pred</span>
        <span class="p">)</span>

        <span class="n">gmix</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">w_update</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zlen</span><span class="p">):</span>
            <span class="n">wt_1</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">ups1_D</span><span class="p">[:,</span> <span class="p">[</span><span class="n">ee</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ups0_E</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">wt_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">*</span> <span class="n">qz_temp</span><span class="p">[:,</span> <span class="p">[</span><span class="n">ee</span><span class="p">]]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span> <span class="o">*</span> <span class="n">w_pred</span>
            <span class="n">w_temp</span> <span class="o">=</span> <span class="n">wt_1</span> <span class="o">*</span> <span class="n">wt_2</span>
            <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">w_temp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">gmix</span><span class="o">.</span><span class="n">add_components</span><span class="p">(</span>
                    <span class="n">mean_temp</span><span class="p">[</span><span class="n">ee</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ww</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">xdim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="n">cov_temp</span><span class="p">[</span><span class="n">ee</span><span class="p">,</span> <span class="n">ww</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                    <span class="n">w_temp</span><span class="p">[</span><span class="n">ww</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                <span class="p">)</span>
        <span class="n">cdn_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cdn_update</span><span class="p">)):</span>
            <span class="n">cdn_update</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">ups0_E</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="n">cdn_update</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cdn_update</span><span class="p">)</span>
        <span class="c1"># assumes predict is called before correct</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_time_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">gmix</span>

<div class="viewcode-block" id="CardinalizedPHD.extract_states">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.CardinalizedPHD.html#carbs.swarm_estimator.tracker.CardinalizedPHD.extract_states">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_multiple</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts the best state estimates.</span>

<span class="sd">        This extracts the best states from the distribution. It should be</span>
<span class="sd">        called once per time step after the correction function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        allow_multiple : bool</span>
<span class="sd">            Flag inicating if extraction is allowed to map a single Gaussian</span>
<span class="sd">            to multiple states. The default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">s_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">c_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agents_per_state</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tot_agents</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">s_weights</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">tot_agents</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cardinality</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s_weights</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">allow_multiple</span><span class="p">:</span>
                <span class="n">n_agents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">n_agents</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Gaussian weights are 0 before reaching cardinality&quot;</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">tot_agents</span> <span class="o">+</span> <span class="n">n_agents</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cardinality</span><span class="p">:</span>
                    <span class="n">n_agents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cardinality</span> <span class="o">-</span> <span class="n">tot_agents</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_agents</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">tot_agents</span> <span class="o">+=</span> <span class="n">n_agents</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">agents_per_state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_agents</span><span class="p">)</span>

            <span class="n">s_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
                <span class="n">c_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">covariances</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">tot_agents</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cardinality</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Failed to meet estimated cardinality when extracting!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_lst</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_lst</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_plots</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_states_per_time</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span></div>


<div class="viewcode-block" id="CardinalizedPHD.plot_card_dist">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.CardinalizedPHD.html#carbs.swarm_estimator.tracker.CardinalizedPHD.plot_card_dist">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the current cardinality distribution.</span>

<span class="sd">        This assumes that the cardinality distribution has been calculated by</span>
<span class="sd">        the class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Keyword arguments are processed with</span>
<span class="sd">            :meth:`gncpy.plotting.init_plotting_opts`. This function</span>
<span class="sd">            implements</span>

<span class="sd">                - f_hndl</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Matplotlib figure</span>
<span class="sd">            Instance of the matplotlib figure used</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeWarning</span>
<span class="sd">            If the cardinality distribution is empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeWarning</span><span class="p">(</span><span class="s2">&quot;Empty Cardinality&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f_hndl</span>
        <span class="k">if</span> <span class="n">f_hndl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">))</span>
        <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span>

        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span>
            <span class="n">f_hndl</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">opts</span><span class="p">,</span>
            <span class="n">ttl</span><span class="o">=</span><span class="s2">&quot;Cardinality Distribution&quot;</span><span class="p">,</span>
            <span class="n">x_lbl</span><span class="o">=</span><span class="s2">&quot;Cardinality&quot;</span><span class="p">,</span>
            <span class="n">y_lbl</span><span class="o">=</span><span class="s2">&quot;Probability&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">f_hndl</span></div>


<div class="viewcode-block" id="CardinalizedPHD.plot_card_history">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.CardinalizedPHD.html#carbs.swarm_estimator.tracker.CardinalizedPHD.plot_card_history">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_card_history</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">true_card</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_units</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the current cardinality time history.</span>

<span class="sd">        This assumes that the cardinality distribution has been calculated by</span>
<span class="sd">        the class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ttl : string</span>
<span class="sd">            String for the title, if None a default is created. The default is</span>
<span class="sd">            None.</span>
<span class="sd">        true_card : array like</span>
<span class="sd">            List of the true cardinality at each time</span>
<span class="sd">        time_units : string, optional</span>
<span class="sd">            Text representing the units of time in the plot. The default is</span>
<span class="sd">            &#39;index&#39;.</span>
<span class="sd">        time : numpy array, optional</span>
<span class="sd">            Vector to use for the x-axis of the plot. If none is given then</span>
<span class="sd">            vector indices are used. The default is None.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Keyword arguments are processed with</span>
<span class="sd">            :meth:`gncpy.plotting.init_plotting_opts`. This function</span>
<span class="sd">            implements</span>

<span class="sd">                - f_hndl</span>
<span class="sd">                - sig_bnd</span>
<span class="sd">                - time_vec</span>
<span class="sd">                - lgnd_loc</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Matplotlib figure</span>
<span class="sd">            Instance of the matplotlib figure used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>
        <span class="n">sig_bnd</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;sig_bnd&quot;</span><span class="p">]</span>
        <span class="c1"># time_vec = opts[&quot;time_vec&quot;]</span>
        <span class="n">lgnd_loc</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;lgnd_loc&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ttl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ttl</span> <span class="o">=</span> <span class="s2">&quot;Cardinality History&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_time_hist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeWarning</span><span class="p">(</span><span class="s2">&quot;Empty Cardinality&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f_hndl</span>
        <span class="k">if</span> <span class="n">sig_bnd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stds</span> <span class="o">=</span> <span class="p">[</span><span class="n">sig_bnd</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_time_hist</span><span class="p">]</span>
        <span class="n">card</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_time_hist</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">f_hndl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">card</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_vals</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span>
            <span class="n">x_vals</span><span class="p">,</span>
            <span class="n">card</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Cardinality&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">true_card</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_card</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_vals</span><span class="p">):</span>
                <span class="n">c_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_card</span><span class="p">)</span>
                <span class="n">t_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_vals</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;True Cardinality vector length (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">c_len</span>
                <span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; does not match time vector length (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t_len</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span>
                    <span class="n">x_vals</span><span class="p">,</span>
                    <span class="n">true_card</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;True Cardinality&quot;</span><span class="p">,</span>
                    <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
                    <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">sig_bnd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lbl</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$</span><span class="si">{}</span><span class="s2">\sigma$ Bound&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sig_bnd</span><span class="p">)</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">x_vals</span><span class="p">,</span>
                <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">s</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">stds</span><span class="p">)],</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">lbl</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">x_vals</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">s</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">stds</span><span class="p">)],</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span>
            <span class="p">)</span>
        <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">useOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lgnd_loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">lgnd_loc</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span>
            <span class="n">f_hndl</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">opts</span><span class="p">,</span>
            <span class="n">ttl</span><span class="o">=</span><span class="n">ttl</span><span class="p">,</span>
            <span class="n">x_lbl</span><span class="o">=</span><span class="s2">&quot;Time (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_units</span><span class="p">),</span>
            <span class="n">y_lbl</span><span class="o">=</span><span class="s2">&quot;Cardinality&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">f_hndl</span></div>


<div class="viewcode-block" id="CardinalizedPHD.plot_number_states_per_time">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.CardinalizedPHD.html#carbs.swarm_estimator.tracker.CardinalizedPHD.plot_number_states_per_time">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_number_states_per_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the number of states per timestep.</span>

<span class="sd">        This is a debug plot for if there are 0 weights in the GM but the</span>
<span class="sd">        cardinality is not reached. Debug plots must be turned on prior to</span>
<span class="sd">        running the filter.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Keyword arguments are processed with</span>
<span class="sd">            :meth:`gncpy.plotting.init_plotting_opts`. This function</span>
<span class="sd">            implements</span>

<span class="sd">                - f_hndl</span>
<span class="sd">                - lgnd_loc</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        f_hndl : matplotlib figure</span>
<span class="sd">            handle to the current figure.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>
        <span class="n">lgnd_loc</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;lgnd_loc&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_plots</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Debug plots turned off&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f_hndl</span>
        <span class="k">if</span> <span class="n">f_hndl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lgnd_loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">lgnd_loc</span><span class="p">)</span>
        <span class="n">x_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_states_per_time</span><span class="p">))]</span>

        <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_states_per_time</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span>
            <span class="n">f_hndl</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">opts</span><span class="p">,</span>
            <span class="n">ttl</span><span class="o">=</span><span class="s2">&quot;Gaussians per Timestep&quot;</span><span class="p">,</span>
            <span class="n">x_lbl</span><span class="o">=</span><span class="s2">&quot;Time&quot;</span><span class="p">,</span>
            <span class="n">y_lbl</span><span class="o">=</span><span class="s2">&quot;Number of Gaussians&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">f_hndl</span></div>
</div>



<span class="k">class</span> <span class="nc">_IMMPHDBase</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filter_lst</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">model_trans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">init_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">init_means</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">init_covs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">,</span> <span class="n">gfilts</span><span class="o">.</span><span class="n">InteractingMultipleModel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Filter must be InteractingMultipleModel&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filter_lst</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">model_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">initialize_filter</span><span class="p">(</span><span class="n">filter_lst</span><span class="p">,</span> <span class="n">model_trans</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">init_means</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">init_covs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">initialize_states</span><span class="p">(</span>
                <span class="n">init_means</span><span class="p">,</span> <span class="n">init_covs</span><span class="p">,</span> <span class="n">init_weights</span><span class="o">=</span><span class="n">init_weights</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_predict_prob_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">probDensity</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Predicts the probability density.</span>

<span class="sd">        Loops over all elements in a probability distribution and performs</span>
<span class="sd">        the filter prediction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            current timestep</span>
<span class="sd">        probDensity : :class:`serums.models.GaussianMixture`</span>
<span class="sd">            Probability density to perform prediction on.</span>
<span class="sd">        filt_args : dict</span>
<span class="sd">            Passed directly to the inner filter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gm : :class:`serums.models.GaussianMixture`</span>
<span class="sd">            predicted Gaussian mixture.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_survive</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>
        <span class="n">n_terms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="n">covariances</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_terms</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_terms</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">covariances</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="n">n_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">covariances</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">means</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_mean</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">smodels</span><span class="o">.</span><span class="n">GaussianMixture</span><span class="p">(</span>
            <span class="n">means</span><span class="o">=</span><span class="n">means</span><span class="p">,</span> <span class="n">covariances</span><span class="o">=</span><span class="n">covariances</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="o">=</span><span class="n">filt_args</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">gm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gm</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">gm</span><span class="o">.</span><span class="n">covariances</span><span class="p">):</span>
                <span class="c1"># if len(m) != 1 or len(c) != 1:</span>
                <span class="c1">#     raise ValueError(&quot;only one mean and covariance per filter is supported&quot;)</span>
                <span class="n">init_means</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">init_covs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">in_filt_list</span><span class="p">)):</span>
                    <span class="n">init_means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                    <span class="n">init_covs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">initialize_states</span><span class="p">(</span><span class="n">init_means</span><span class="p">,</span> <span class="n">init_covs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">())</span>
        <span class="c1"># new imm filter state to represent new means</span>

    <span class="k">def</span> <span class="nf">_prune</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_prune</span><span class="p">()</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Pruned index is greater than filter state length&quot;</span><span class="p">)</span>

        <span class="c1"># remove pruned indices from filter state indicies</span>

    <span class="k">def</span> <span class="nf">_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merges nearby hypotheses.&quot;&quot;&quot;</span>
        <span class="n">loop_inds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">)))</span>

        <span class="n">w_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">m_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">p_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fs_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">loop_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">))</span>
            <span class="n">comp_inds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">inv_cov</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">covariances</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">loop_inds</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">inv_cov</span> <span class="o">@</span> <span class="n">diff</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_threshold</span><span class="p">:</span>
                    <span class="n">comp_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
            <span class="n">w_new</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">comp_inds</span><span class="p">])</span>
            <span class="n">m_new</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">comp_inds</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="o">/</span> <span class="n">w_new</span>
            <span class="p">)</span>
            <span class="n">p_new</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">covariances</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">comp_inds</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="o">/</span> <span class="n">w_new</span>
            <span class="p">)</span>

            <span class="n">new_mean_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">new_cov_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">new_filt_weights</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">in_filt_list</span><span class="p">)):</span>
                <span class="c1"># ml_new = ( sum([self._gaussMix.weights[ii] * self._filter_states[ii][&quot;mean_list&quot;][kk]]))</span>
                <span class="n">ml_new</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">cl_new</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">fw_new</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">comp_inds</span><span class="p">:</span>
                    <span class="n">ml_new</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">ml_new</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                        <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="s2">&quot;mean_list&quot;</span><span class="p">][</span><span class="n">kk</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">cl_new</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">cl_new</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                        <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="s2">&quot;cov_list&quot;</span><span class="p">][</span><span class="n">kk</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">fw_new</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">fw_new</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                        <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="s2">&quot;filt_weights&quot;</span><span class="p">][</span><span class="n">kk</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="n">new_mean_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ml_new</span> <span class="o">/</span> <span class="n">w_new</span><span class="p">)</span>
                <span class="n">new_cov_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cl_new</span> <span class="o">/</span> <span class="n">w_new</span><span class="p">)</span>
                <span class="n">new_filt_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fw_new</span> <span class="o">/</span> <span class="n">w_new</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">initialize_states</span><span class="p">(</span>
                <span class="n">new_mean_list</span><span class="p">,</span> <span class="n">new_cov_list</span><span class="p">,</span> <span class="n">init_weights</span><span class="o">=</span><span class="n">new_filt_weights</span>
            <span class="p">)</span>
            <span class="n">fs_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">())</span>
            <span class="n">w_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w_new</span><span class="p">)</span>
            <span class="n">m_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m_new</span><span class="p">)</span>
            <span class="n">p_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_new</span><span class="p">)</span>

            <span class="n">loop_inds</span> <span class="o">=</span> <span class="n">loop_inds</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">comp_inds</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">comp_inds</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span> <span class="o">=</span> <span class="n">fs_lst</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span> <span class="o">=</span> <span class="n">smodels</span><span class="o">.</span><span class="n">GaussianMixture</span><span class="p">(</span>
            <span class="n">means</span><span class="o">=</span><span class="n">m_lst</span><span class="p">,</span> <span class="n">covariances</span><span class="o">=</span><span class="n">p_lst</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w_lst</span>
        <span class="p">)</span>
        <span class="c1"># probably need to overwrite, do this later</span>

    <span class="k">def</span> <span class="nf">_cap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_cap</span><span class="p">()</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Capped index is greater than filter state length&quot;</span><span class="p">)</span>
        <span class="c1"># remove capped indices from filter state indicies</span>


<div class="viewcode-block" id="IMMProbabilityHypothesisDensity">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.IMMProbabilityHypothesisDensity">[docs]</a>
<span class="k">class</span> <span class="nc">IMMProbabilityHypothesisDensity</span><span class="p">(</span><span class="n">_IMMPHDBase</span><span class="p">,</span> <span class="n">ProbabilityHypothesisDensity</span><span class="p">):</span>
<div class="viewcode-block" id="IMMProbabilityHypothesisDensity.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.IMMProbabilityHypothesisDensity.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

        <span class="c1"># TODO: init_filter_states_for_imm</span>

    <span class="k">def</span> <span class="nf">_correct_prob_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">probDensity</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Corrects the probability densities.</span>

<span class="sd">        Loops over all elements in a probability distribution and preforms</span>
<span class="sd">        the filter correction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meas : list</span>
<span class="sd">            2d numpy arrays of each measurement.</span>
<span class="sd">        probDensity : :py:class:`serums.models.GaussianMixture`</span>
<span class="sd">            probability density to run correction on.</span>
<span class="sd">        filt_args : dict</span>
<span class="sd">            arguements to pass to the inner filter correct function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gm : :py:class:`serums.models.GaussianMixture`</span>
<span class="sd">            corrected probability density.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">covariances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># corr_filt_weights = np.zeros(np.shape(self.filter.filt_weights))</span>
        <span class="n">new_filter_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">det_weights</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">weights</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">meas</span><span class="p">:</span>
            <span class="n">w_lst</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
                <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">qz</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>
                <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">qz</span> <span class="o">*</span> <span class="n">det_weights</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="n">covariances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
                <span class="n">w_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="n">new_filter_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">())</span>
            <span class="n">weights</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span><span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w_lst</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">w_lst</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span> <span class="o">=</span> <span class="n">new_filter_states</span>
        <span class="k">return</span> <span class="n">smodels</span><span class="o">.</span><span class="n">GaussianMixture</span><span class="p">(</span>
            <span class="n">means</span><span class="o">=</span><span class="n">means</span><span class="p">,</span> <span class="n">covariances</span><span class="o">=</span><span class="n">covariances</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span>
        <span class="p">)</span>

<div class="viewcode-block" id="IMMProbabilityHypothesisDensity.correct">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMProbabilityHypothesisDensity.html#carbs.swarm_estimator.tracker.IMMProbabilityHypothesisDensity.correct">[docs]</a>
    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas_in</span><span class="p">,</span> <span class="n">meas_mat_args</span><span class="o">=</span><span class="p">{},</span> <span class="n">est_meas_args</span><span class="o">=</span><span class="p">{},</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}</span>
    <span class="p">):</span>
        <span class="n">meas</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">meas_in</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span><span class="p">:</span>
            <span class="n">meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gate_meas</span><span class="p">(</span>
                <span class="n">meas</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">means</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="o">.</span><span class="n">covariances</span><span class="p">,</span>
                <span class="n">meas_mat_args</span><span class="p">,</span>
                <span class="n">est_meas_args</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>

        <span class="n">gmix</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="p">)</span>
        <span class="n">gmix</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gmix</span><span class="o">.</span><span class="n">weights</span><span class="p">]</span>
        <span class="n">saved_filt_weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">filt_state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="p">:</span>
            <span class="n">saved_filt_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;filt_weights&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">gm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_prob_density</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>
        <span class="n">gm</span><span class="o">.</span><span class="n">add_components</span><span class="p">(</span><span class="n">gmix</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">gmix</span><span class="o">.</span><span class="n">covariances</span><span class="p">,</span> <span class="n">gmix</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gmix</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">gmix</span><span class="o">.</span><span class="n">covariances</span><span class="p">)):</span>
            <span class="c1"># for m, c in zip(m_list, c_list):</span>
            <span class="n">m_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">c_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">in_filt_list</span><span class="p">)):</span>
                <span class="n">m_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">c_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">initialize_states</span><span class="p">(</span>
                <span class="n">m_list</span><span class="p">,</span> <span class="n">c_list</span><span class="p">,</span> <span class="n">init_weights</span><span class="o">=</span><span class="n">saved_filt_weights</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussMix</span> <span class="o">=</span> <span class="n">gm</span></div>
</div>



<div class="viewcode-block" id="IMMCardinalizedPHD">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMCardinalizedPHD.html#carbs.swarm_estimator.tracker.IMMCardinalizedPHD">[docs]</a>
<span class="k">class</span> <span class="nc">IMMCardinalizedPHD</span><span class="p">(</span><span class="n">_IMMPHDBase</span><span class="p">,</span> <span class="n">CardinalizedPHD</span><span class="p">):</span>
<div class="viewcode-block" id="IMMCardinalizedPHD.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMCardinalizedPHD.html#carbs.swarm_estimator.tracker.IMMCardinalizedPHD.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_correct_prob_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">probDensity</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function for correction step.</span>

<span class="sd">        Loops over all elements in a probability distribution and preforms</span>
<span class="sd">        the filter correction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">weights</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">weights</span><span class="p">)):</span>
            <span class="n">w_pred</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">xdim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">plen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="n">zlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>

        <span class="n">qz_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">plen</span><span class="p">,</span> <span class="n">zlen</span><span class="p">))</span>
        <span class="n">mean_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">zlen</span><span class="p">,</span> <span class="n">xdim</span><span class="p">,</span> <span class="n">plen</span><span class="p">))</span>
        <span class="n">cov_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">zlen</span><span class="p">,</span> <span class="n">plen</span><span class="p">,</span> <span class="n">xdim</span><span class="p">,</span> <span class="n">xdim</span><span class="p">))</span>
        <span class="n">saved_filt_weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">filt_state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="p">:</span>
            <span class="n">saved_filt_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;filt_weights&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">new_filter_states</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">z_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zlen</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">p_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">plen</span><span class="p">):</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">probDensity</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">p_ind</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span><span class="p">[</span><span class="n">p_ind</span><span class="p">])</span>
                <span class="c1"># self.filter.initialize_states(probDensity.means[p_ind], probDensity.covariances[p_ind],</span>
                <span class="c1">#                               init_weights=self.weight_list[p_ind])</span>

                <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">qz</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">[</span><span class="n">z_ind</span><span class="p">],</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>
                <span class="n">qz_temp</span><span class="p">[</span><span class="n">p_ind</span><span class="p">,</span> <span class="n">z_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">qz</span>
                <span class="n">mean_temp</span><span class="p">[</span><span class="n">z_ind</span><span class="p">,</span> <span class="p">:,</span> <span class="n">p_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>
                <span class="n">cov_temp</span><span class="p">[</span><span class="n">z_ind</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_filter_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">())</span>
                <span class="c1"># self._filter_states[p_ind] = self.filter.save_filter_state()</span>
        <span class="n">xivals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">zlen</span><span class="p">)</span>
        <span class="n">pdc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zlen</span><span class="p">):</span>
            <span class="n">xivals</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w_pred</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">qz_temp</span><span class="p">[:,</span> <span class="p">[</span><span class="n">e</span><span class="p">]])</span>
        <span class="n">esfvals_E</span> <span class="o">=</span> <span class="n">get_elem_sym_fnc</span><span class="p">(</span><span class="n">xivals</span><span class="p">)</span>
        <span class="n">esfvals_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">zlen</span><span class="p">,</span> <span class="n">zlen</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zlen</span><span class="p">):</span>
            <span class="n">xi_temp</span> <span class="o">=</span> <span class="n">xivals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">xi_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">xi_temp</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">esfvals_D</span><span class="p">[:,</span> <span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">get_elem_sym_fnc</span><span class="p">(</span><span class="n">xi_temp</span><span class="p">)</span>
        <span class="n">ups0_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ups1_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ups1_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">zlen</span><span class="p">))</span>

        <span class="n">tot_w_pred</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w_pred</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_expected_card</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">terms0_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">zlen</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">zlen</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">+</span> <span class="p">(</span><span class="n">zlen</span> <span class="o">-</span> <span class="n">jj</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span><span class="p">)</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span> <span class="o">-</span> <span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                <span class="n">t4</span> <span class="o">=</span> <span class="p">(</span><span class="n">nn</span> <span class="o">-</span> <span class="n">jj</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_death</span><span class="p">)</span>
                <span class="n">t5</span> <span class="o">=</span> <span class="o">-</span><span class="n">jj</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tot_w_pred</span><span class="p">)</span>
                <span class="n">terms0_E</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span> <span class="o">+</span> <span class="n">t4</span> <span class="o">+</span> <span class="n">t5</span><span class="p">)</span> <span class="o">*</span> <span class="n">esfvals_E</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
            <span class="n">ups0_E</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">terms0_E</span><span class="p">)</span>

            <span class="n">terms1_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">zlen</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">zlen</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nn</span> <span class="o">&gt;=</span> <span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">+</span> <span class="p">(</span><span class="n">zlen</span> <span class="o">-</span> <span class="n">jj</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span><span class="p">)</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                    <span class="n">t3</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span> <span class="o">-</span> <span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                    <span class="n">t4</span> <span class="o">=</span> <span class="p">(</span><span class="n">nn</span> <span class="o">-</span> <span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_death</span><span class="p">)</span>
                    <span class="n">t5</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tot_w_pred</span><span class="p">)</span>
                    <span class="n">terms1_E</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span> <span class="o">+</span> <span class="n">t4</span> <span class="o">+</span> <span class="n">t5</span><span class="p">)</span> <span class="o">*</span> <span class="n">esfvals_E</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
            <span class="n">ups1_E</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">terms1_E</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">zlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">terms1_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">zlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">zlen</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">ell</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">zlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">((</span><span class="n">zlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">nn</span> <span class="o">&gt;=</span> <span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">t1</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">+</span> <span class="p">((</span><span class="n">zlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">jj</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span>
                            <span class="p">)</span>
                            <span class="n">t2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                            <span class="n">t3</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span> <span class="o">-</span> <span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                            <span class="p">)</span>
                            <span class="n">t4</span> <span class="o">=</span> <span class="p">(</span><span class="n">nn</span> <span class="o">-</span> <span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob_death</span><span class="p">)</span>
                            <span class="n">t5</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tot_w_pred</span><span class="p">)</span>
                            <span class="n">terms1_D</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ell</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span> <span class="o">+</span> <span class="n">t4</span> <span class="o">+</span> <span class="n">t5</span><span class="p">)</span> <span class="o">*</span> <span class="n">esfvals_D</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ell</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="p">)</span>
                <span class="n">ups1_D</span><span class="p">[</span><span class="n">nn</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">terms1_D</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">gmix</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">probDensity</span><span class="p">)</span>
        <span class="n">w_update</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">((</span><span class="n">ups1_E</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ups0_E</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">))</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span>
            <span class="o">*</span> <span class="n">w_pred</span>
        <span class="p">)</span>

        <span class="n">old_filt_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">gmix</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">w_update</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gmix</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">gmix</span><span class="o">.</span><span class="n">covariances</span><span class="p">)):</span>
            <span class="n">m_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">c_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">in_filt_list</span><span class="p">)):</span>
                <span class="n">m_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">c_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">initialize_states</span><span class="p">(</span>
                <span class="n">m_list</span><span class="p">,</span> <span class="n">c_list</span><span class="p">,</span> <span class="n">init_weights</span><span class="o">=</span><span class="n">saved_filt_weights</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">old_filt_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zlen</span><span class="p">):</span>
            <span class="n">wt_1</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">ups1_D</span><span class="p">[:,</span> <span class="p">[</span><span class="n">ee</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ups0_E</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">wt_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">*</span> <span class="n">qz_temp</span><span class="p">[:,</span> <span class="p">[</span><span class="n">ee</span><span class="p">]]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span> <span class="o">*</span> <span class="n">w_pred</span>
            <span class="n">w_temp</span> <span class="o">=</span> <span class="n">wt_1</span> <span class="o">*</span> <span class="n">wt_2</span>
            <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">w_temp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">gmix</span><span class="o">.</span><span class="n">add_components</span><span class="p">(</span>
                    <span class="n">mean_temp</span><span class="p">[</span><span class="n">ee</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ww</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">xdim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="n">cov_temp</span><span class="p">[</span><span class="n">ee</span><span class="p">,</span> <span class="n">ww</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                    <span class="n">w_temp</span><span class="p">[</span><span class="n">ww</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                <span class="p">)</span>
        <span class="n">cdn_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cdn_update</span><span class="p">)):</span>
            <span class="n">cdn_update</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">ups0_E</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="n">cdn_update</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cdn_update</span><span class="p">)</span>
        <span class="c1"># assumes predict is called before correct</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_time_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">filt_state</span> <span class="ow">in</span> <span class="n">new_filter_states</span><span class="p">:</span>
            <span class="n">old_filt_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter_states</span> <span class="o">=</span> <span class="n">old_filt_states</span>
        <span class="k">return</span> <span class="n">gmix</span></div>



<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli">[docs]</a>
<span class="k">class</span> <span class="nc">GeneralizedLabeledMultiBernoulli</span><span class="p">(</span><span class="n">RandomFiniteSetBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Delta-Generalized Labeled Multi-Bernoulli filter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is based on :cite:`Vo2013_LabeledRandomFiniteSetsandMultiObjectConjugatePriors`</span>
<span class="sd">    and :cite:`Vo2014_LabeledRandomFiniteSetsandtheBayesMultiTargetTrackingFilter`</span>
<span class="sd">    It does not account for agents spawned from existing tracks, only agents</span>
<span class="sd">    birthed from the given birth model.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    req_births : int</span>
<span class="sd">        Number of requested birth hypotheses</span>
<span class="sd">    req_surv : int</span>
<span class="sd">        Number of requested surviving hypotheses</span>
<span class="sd">    req_upd : int</span>
<span class="sd">        Number of requested updated hypotheses</span>
<span class="sd">    gating_on : bool</span>
<span class="sd">        Determines if measurements are gated</span>
<span class="sd">    birth_terms :list</span>
<span class="sd">        List of tuples where the first element is a</span>
<span class="sd">        :py:class:`gncpy.distributions.GaussianMixture` and</span>
<span class="sd">        the second is the birth probability for that term</span>
<span class="sd">    prune_threshold : float</span>
<span class="sd">        Minimum association probability to keep when pruning</span>
<span class="sd">    max_hyps : int</span>
<span class="sd">        Maximum number of hypotheses to keep when capping</span>
<span class="sd">    decimal_places : int</span>
<span class="sd">        Number of decimal places to keep in label. The default is 2.</span>
<span class="sd">    save_measurements : bool</span>
<span class="sd">        Flag indicating if measurments should be saved. Useful for some extra</span>
<span class="sd">        plots.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">_TabEntry</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="p">()</span>  <span class="c1"># time step born, index of birth model born from</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distrib_weights_hist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of weights of the probDensity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filt_states</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of dictionaries from filters save function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meas_assoc_hist</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[]</span>
            <span class="p">)</span>  <span class="c1"># list indices into measurement list per time step</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">state_hist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of lists of numpy arrays for each timestep</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_hist</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[]</span>
            <span class="p">)</span>  <span class="c1"># list of lists of numpy arrays for each timestep (or None)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot; linear index corresponding to timestep, manually updated. Used</span>
<span class="sd">            to index things since timestep in label can have decimals.&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tab</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Use to avoid expensive deepcopy.&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="n">label</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distrib_weights_hist</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filt_states</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">tab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meas_assoc_hist</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">state_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tab</span><span class="o">.</span><span class="n">state_hist</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_hist</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">s_lst</span> <span class="k">for</span> <span class="n">s_lst</span> <span class="ow">in</span> <span class="n">tab</span><span class="o">.</span><span class="n">state_hist</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_hist</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c_lst</span> <span class="k">for</span> <span class="n">c_lst</span> <span class="ow">in</span> <span class="n">tab</span><span class="o">.</span><span class="n">cov_hist</span><span class="p">]</span>
            <span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="n">time_index</span>

            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">class</span> <span class="nc">_HypothesisHelper</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># indices in lookup table</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">num_tracks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">_ExtractHistHelper</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meas_ind_hist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covs</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">req_births</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">req_surv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">req_upd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gating_on</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">prune_threshold</span><span class="o">=</span><span class="mi">10</span><span class="o">**-</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">max_hyps</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
        <span class="n">decimal_places</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">save_measurements</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_births</span> <span class="o">=</span> <span class="n">req_births</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_surv</span> <span class="o">=</span> <span class="n">req_surv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_upd</span> <span class="o">=</span> <span class="n">req_upd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span> <span class="o">=</span> <span class="n">gating_on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prune_threshold</span> <span class="o">=</span> <span class="n">prune_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_hyps</span> <span class="o">=</span> <span class="n">max_hyps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimal_places</span> <span class="o">=</span> <span class="n">decimal_places</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span> <span class="o">=</span> <span class="n">save_measurements</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of all possible tracks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># local copy for internal modification</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">hyp0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
        <span class="n">hyp0</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">hyp0</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="p">[</span><span class="n">hyp0</span><span class="p">]</span>  <span class="c1"># list of _HypothesisHelper objects</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># probability of having index # as cardinality</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot; linear index corresponding to timestep, manually updated. Used</span>
<span class="sd">            to index things since timestep in label can have decimals. Must</span>
<span class="sd">            be updated once per time step.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="p">[[]]</span></div>


<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.save_filter_state">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.save_filter_state">[docs]</a>
    <span class="k">def</span> <span class="nf">save_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves filter variables so they can be restored later.</span>

<span class="sd">        Note that to pickle the resulting dictionary the :code:`dill` package</span>
<span class="sd">        may need to be used due to potential pickling of functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filt_state</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>

        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;req_births&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">req_births</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;req_surv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">req_surv</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;req_upd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">req_upd</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;gating_on&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;prune_threshold&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prune_threshold</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;max_hyps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_hyps</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;decimal_places&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimal_places</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;save_measurements&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span>

        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_track_tab&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_extractable_hists&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_baseFilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_baseFilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="p">)</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_hypotheses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_card_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_time_index_cntr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span>

        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa2_localization&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa2_cardinality&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_ospa2_params&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span>

        <span class="k">return</span> <span class="n">filt_state</span></div>


<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.load_filter_state">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.load_filter_state">[docs]</a>
    <span class="k">def</span> <span class="nf">load_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes filter using saved filter state.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        filt_state : dict</span>
<span class="sd">            Dictionary generated by :meth:`save_filter_state`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">req_births</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;req_births&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_surv</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;req_surv&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_upd</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;req_upd&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;gating_on&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prune_threshold</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;prune_threshold&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_hyps</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;max_hyps&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimal_places</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;decimal_places&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;save_measurements&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_track_tab&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_labels&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_extractable_hists&quot;</span><span class="p">]</span>

        <span class="n">cls_type</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_baseFilter&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cls_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span> <span class="o">=</span> <span class="n">cls_type</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_baseFilter&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_hypotheses&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_card_dist&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_time_index_cntr&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa2&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa2_localization&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa2_cardinality&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_ospa2_params&quot;</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read only list of extracted states.</span>

<span class="sd">        This is a list with 1 element per timestep, and each element is a list</span>
<span class="sd">        of the best states extracted at that timestep. The order of each</span>
<span class="sd">        element corresponds to the label order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read only list of extracted labels.</span>

<span class="sd">        This is a list with 1 element per timestep, and each element is a list</span>
<span class="sd">        of the best labels extracted at that timestep. The order of each</span>
<span class="sd">        element corresponds to the state order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">covariances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read only list of extracted covariances.</span>

<span class="sd">        This is a list with 1 element per timestep, and each element is a list</span>
<span class="sd">        of the best covariances extracted at that timestep. The order of each</span>
<span class="sd">        element corresponds to the state order.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeWarning</span>
<span class="sd">            If the class is not saving the covariances, and returns an empty list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeWarning</span><span class="p">(</span><span class="s2">&quot;Not saving covariances&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inner filter handling dynamics, must be a gncpy.filters.BayesFilter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span>

    <span class="nd">@filter</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cardinality estimate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_filt_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distrib</span><span class="p">):</span>
        <span class="n">filt_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">distrib</span><span class="o">.</span><span class="n">covariances</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">distrib</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">distrib</span><span class="o">.</span><span class="n">covariances</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="p">,</span> <span class="n">gfilts</span><span class="o">.</span><span class="n">UnscentedKalmanFilter</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="p">,</span> <span class="n">gfilts</span><span class="o">.</span><span class="n">UKFGaussianScaleMixtureFilter</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">init_sigma_points</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">filt_states</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">filt_states</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">covs</span>

    <span class="k">def</span> <span class="nf">_gen_birth_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">):</span>
        <span class="n">log_cost</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">birth_tab</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">distrib</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">):</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
            <span class="n">log_cost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cost</span><span class="p">))</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span>
            <span class="n">entry</span><span class="o">.</span><span class="n">state_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="n">entry</span><span class="o">.</span><span class="n">cov_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="n">entry</span><span class="o">.</span><span class="n">distrib_weights_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="p">(</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">filt_states</span><span class="p">,</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">state_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">cov_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_filt_states</span><span class="p">(</span><span class="n">distrib</span><span class="p">)</span>
            <span class="n">entry</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimal_places</span><span class="p">),</span> <span class="n">ii</span><span class="p">)</span>
            <span class="n">entry</span><span class="o">.</span><span class="n">time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span>
            <span class="n">birth_tab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">birth_tab</span><span class="p">,</span> <span class="n">log_cost</span>

    <span class="k">def</span> <span class="nf">_gen_birth_hyps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">hyp_costs</span><span class="p">):</span>
        <span class="n">birth_hyps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tot_b_prob</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">hyp_costs</span><span class="p">):</span>
            <span class="n">hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
            <span class="c1"># NOTE: this may suffer from underflow and can be improved</span>
            <span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">tot_b_prob</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">birth_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hyp</span><span class="p">)</span>
        <span class="n">lse</span> <span class="o">=</span> <span class="n">log_sum_exp</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">birth_hyps</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">birth_hyps</span><span class="p">)):</span>
            <span class="n">birth_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">birth_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">-</span> <span class="n">lse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">birth_hyps</span>

    <span class="k">def</span> <span class="nf">_inner_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="n">new_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>
        <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">new_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">new_f_state</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">new_cov</span>

    <span class="k">def</span> <span class="nf">_predict_track_tab_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tab</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates table entries probability density.&quot;&quot;&quot;</span>
        <span class="n">newTab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>
        <span class="n">new_f_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_s_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_c_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">f_state</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">,</span> <span class="n">newTab</span><span class="o">.</span><span class="n">state_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="p">(</span><span class="n">new_f_states</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">new_s_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">new_c_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_predict</span><span class="p">(</span>
                <span class="n">timestep</span><span class="p">,</span> <span class="n">f_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span>
            <span class="p">)</span>
        <span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span> <span class="o">=</span> <span class="n">new_f_states</span>
        <span class="n">newTab</span><span class="o">.</span><span class="n">state_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_s_hist</span><span class="p">)</span>
        <span class="n">newTab</span><span class="o">.</span><span class="n">cov_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_c_hist</span><span class="p">)</span>
        <span class="n">newTab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">newTab</span>

    <span class="k">def</span> <span class="nf">_gen_surv_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">surv_tab</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">track</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_track_tab_entry</span><span class="p">(</span><span class="n">track</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>

            <span class="n">surv_tab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">surv_tab</span>

    <span class="k">def</span> <span class="nf">_gen_surv_hyps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">avg_prob_survive</span><span class="p">,</span> <span class="n">avg_prob_death</span><span class="p">):</span>
        <span class="n">surv_hyps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sum_sqrt_w</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># avg_prob_mm =</span>
        <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
            <span class="n">sum_sqrt_w</span> <span class="o">=</span> <span class="n">sum_sqrt_w</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hyp</span><span class="o">.</span><span class="n">num_tracks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
                <span class="n">new_hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                <span class="n">new_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span>
                <span class="n">surv_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hyp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cost</span> <span class="o">=</span> <span class="n">avg_prob_survive</span><span class="p">[</span><span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span> <span class="o">/</span> <span class="n">avg_prob_death</span><span class="p">[</span><span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                <span class="n">log_cost</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>  <span class="c1"># this is length hyp.num_tracks</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">req_surv</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_sqrt_w</span><span class="p">)</span>
                <span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">hyp_cost</span><span class="p">)</span> <span class="o">=</span> <span class="n">k_shortest</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">log_cost</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>

                <span class="n">pdeath_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">avg_prob_death</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">hyp_cost</span><span class="p">):</span>
                    <span class="n">new_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
                    <span class="n">new_hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">pdeath_log</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">new_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">surv_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hyp</span><span class="p">)</span>
        <span class="n">lse</span> <span class="o">=</span> <span class="n">log_sum_exp</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">surv_hyps</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">surv_hyps</span><span class="p">)):</span>
            <span class="n">surv_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">surv_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">-</span> <span class="n">lse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">surv_hyps</span>

    <span class="k">def</span> <span class="nf">_calc_avg_prob_surv_death</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">avg_prob_survive</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_survive</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">))</span>
        <span class="n">avg_prob_death</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">avg_prob_survive</span>

        <span class="k">return</span> <span class="n">avg_prob_survive</span><span class="p">,</span> <span class="n">avg_prob_death</span>

    <span class="k">def</span> <span class="nf">_set_pred_hyps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">birth_tab</span><span class="p">,</span> <span class="n">birth_hyps</span><span class="p">,</span> <span class="n">surv_hyps</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tot_w</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">b_hyp</span> <span class="ow">in</span> <span class="n">birth_hyps</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s_hyp</span> <span class="ow">in</span> <span class="n">surv_hyps</span><span class="p">:</span>
                <span class="n">new_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
                <span class="n">new_hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">b_hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">*</span> <span class="n">s_hyp</span><span class="o">.</span><span class="n">assoc_prob</span>
                <span class="n">tot_w</span> <span class="o">=</span> <span class="n">tot_w</span> <span class="o">+</span> <span class="n">new_hyp</span><span class="o">.</span><span class="n">assoc_prob</span>
                <span class="n">surv_lst</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">:</span>
                    <span class="n">surv_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">birth_tab</span><span class="p">))</span>
                <span class="n">new_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="n">b_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">+</span> <span class="n">surv_lst</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hyp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)):</span>
            <span class="n">n_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">/</span> <span class="n">tot_w</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">n_val</span>

    <span class="k">def</span> <span class="nf">_calc_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hyp_lst</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calucaltes the cardinality distribution.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hyp_lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="mi">1</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="n">card_dist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">num_tracks</span><span class="p">,</span> <span class="n">hyp_lst</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="n">hyp_lst</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hyp</span><span class="o">.</span><span class="n">num_tracks</span> <span class="o">==</span> <span class="n">ii</span><span class="p">:</span>
                    <span class="n">card</span> <span class="o">=</span> <span class="n">card</span> <span class="o">+</span> <span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span>
            <span class="n">card_dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">card_dist</span>

    <span class="k">def</span> <span class="nf">_clean_predictions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">hash_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sorted_inds</span> <span class="o">=</span> <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">sorted_inds</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sorted_inds</span><span class="p">]</span>
            <span class="n">h</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">lst</span><span class="p">)))</span>
            <span class="n">hash_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">new_hyps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">used_hash</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hash_lst</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">h</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_hash</span><span class="p">:</span>
                <span class="n">used_hash</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                <span class="n">new_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_ii</span> <span class="o">=</span> <span class="n">used_hash</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                <span class="n">new_hyps</span><span class="p">[</span><span class="n">new_ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="n">new_hyps</span>

<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.predict">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.predict">[docs]</a>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prediction step of the GLMB filter.</span>

<span class="sd">        This predicts new hypothesis, and propogates them to the next time</span>
<span class="sd">        step. It also updates the cardinality distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            Current timestep.</span>
<span class="sd">        filt_args : dict, optional</span>
<span class="sd">            Passed to the inner filter. The default is {}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find cost for each birth track, and setup lookup table</span>
        <span class="n">birth_tab</span><span class="p">,</span> <span class="n">log_cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_birth_tab</span><span class="p">(</span><span class="n">timestep</span><span class="p">)</span>

        <span class="c1"># get K best hypothesis, and their index in the lookup table</span>
        <span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">hyp_costs</span><span class="p">)</span> <span class="o">=</span> <span class="n">k_shortest</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">log_cost</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">req_births</span><span class="p">)</span>

        <span class="c1"># calculate association probabilities for birth hypothesis</span>
        <span class="n">birth_hyps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_birth_hyps</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">hyp_costs</span><span class="p">)</span>

        <span class="c1"># Init and propagate surviving track table</span>
        <span class="n">surv_tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_surv_tab</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>

        <span class="c1"># Calculation for average survival/death probabilities</span>
        <span class="p">(</span><span class="n">avg_prob_survive</span><span class="p">,</span> <span class="n">avg_prob_death</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_avg_prob_surv_death</span><span class="p">()</span>

        <span class="c1"># loop over postierior components</span>
        <span class="n">surv_hyps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_surv_hyps</span><span class="p">(</span><span class="n">avg_prob_survive</span><span class="p">,</span> <span class="n">avg_prob_death</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_card_dist</span><span class="p">(</span><span class="n">surv_hyps</span><span class="p">)</span>

        <span class="c1"># Get  predicted hypothesis by convolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">birth_tab</span> <span class="o">+</span> <span class="n">surv_tab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_pred_hyps</span><span class="p">(</span><span class="n">birth_tab</span><span class="p">,</span> <span class="n">birth_hyps</span><span class="p">,</span> <span class="n">surv_hyps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_predictions</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_inner_correct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">,</span> <span class="n">distrib_weight</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="n">cor_state</span><span class="p">,</span> <span class="n">likely</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>
        <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="n">new_s</span> <span class="o">=</span> <span class="n">cor_state</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">new_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="n">distrib_weight</span> <span class="o">*</span> <span class="n">likely</span>

        <span class="k">return</span> <span class="n">new_f_state</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">new_c</span><span class="p">,</span> <span class="n">new_w</span>

    <span class="k">def</span> <span class="nf">_correct_track_tab_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">tab</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">newTab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>
        <span class="n">new_f_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_s_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_c_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">depleted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">f_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">,</span>
                <span class="n">newTab</span><span class="o">.</span><span class="n">state_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">newTab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">new_f_states</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_s_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_c_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_w</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">f_state</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ParticleDepletionError</span><span class="p">,</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ParticleEstimationDomainError</span><span class="p">,</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ExtremeMeasurementNoiseError</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span> <span class="o">=</span> <span class="n">new_f_states</span>
        <span class="n">newTab</span><span class="o">.</span><span class="n">state_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_s_hist</span>
        <span class="n">newTab</span><span class="o">.</span><span class="n">cov_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_c_hist</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">new_w</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">depleted</span><span class="p">:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">new_w</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">newTab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">/</span> <span class="n">cost</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">new_w</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">newTab</span><span class="p">,</span> <span class="n">cost</span>

    <span class="k">def</span> <span class="nf">_gen_cor_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">num_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="n">up_tab</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">track</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># measurement updated tracks</span>
        <span class="n">all_cost_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_pred</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">emm</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
                <span class="n">s_to_ii</span> <span class="o">=</span> <span class="n">num_pred</span> <span class="o">*</span> <span class="n">emm</span> <span class="o">+</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">num_pred</span>
                <span class="p">(</span><span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">],</span> <span class="n">cost</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_track_tab_entry</span><span class="p">(</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span>
                <span class="p">)</span>

                <span class="c1"># update association history with current measurement index</span>
                <span class="k">if</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">emm</span><span class="p">)</span>
                <span class="n">all_cost_m</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">emm</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="k">return</span> <span class="n">up_tab</span><span class="p">,</span> <span class="n">all_cost_m</span>

    <span class="k">def</span> <span class="nf">_gen_cor_hyps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">,</span> <span class="n">avg_prob_detect</span><span class="p">,</span> <span class="n">avg_prob_miss_detect</span><span class="p">,</span> <span class="n">all_cost_m</span>
    <span class="p">):</span>
        <span class="n">num_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="n">up_hyps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">num_meas</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
                <span class="n">pmd_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">avg_prob_miss_detect</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">+</span> <span class="n">pmd_log</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                <span class="n">up_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hyp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clutter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span>
            <span class="n">ss_w</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">p_hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
                <span class="n">ss_w</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p_hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">num_tracks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># all clutter</span>
                    <span class="n">new_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
                    <span class="n">new_hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span>
                        <span class="o">+</span> <span class="n">num_meas</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clutter</span><span class="p">)</span>
                        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">new_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">up_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hyp</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">avg_prob_detect</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">])</span>
                    <span class="n">pmd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">avg_prob_miss_detect</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">])</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">pd</span> <span class="o">/</span> <span class="n">pmd</span>

                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">ratio</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">))</span>

                    <span class="n">cost_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">all_cost_m</span><span class="p">[</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">):</span>
                        <span class="n">cost_m</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ratio</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="n">all_cost_m</span><span class="p">[</span><span class="n">ts</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">clutter</span>
                    <span class="n">max_row_inds</span><span class="p">,</span> <span class="n">max_col_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cost_m</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">max_row_inds</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">cost_m</span><span class="p">[</span><span class="n">max_row_inds</span><span class="p">,</span> <span class="n">max_col_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
                    <span class="n">min_row_inds</span><span class="p">,</span> <span class="n">min_col_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cost_m</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">min_row_inds</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">cost_m</span><span class="p">[</span><span class="n">min_row_inds</span><span class="p">,</span> <span class="n">min_col_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>  <span class="c1"># 1</span>
                    <span class="n">neg_log</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cost_m</span><span class="p">)</span>
                    <span class="c1"># if max_row_inds.size &gt; 0:</span>
                    <span class="c1">#     neg_log[max_row_inds, max_col_inds] = -np.inf</span>
                    <span class="c1"># if min_row_inds.size &gt; 0:</span>
                    <span class="c1">#     neg_log[min_row_inds, min_col_inds] = np.inf</span>

                    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">req_upd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span> <span class="o">/</span> <span class="n">ss_w</span><span class="p">)</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
                    <span class="p">[</span><span class="n">assigns</span><span class="p">,</span> <span class="n">costs</span><span class="p">]</span> <span class="o">=</span> <span class="n">murty_m_best</span><span class="p">(</span><span class="n">neg_log</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

                    <span class="n">pmd_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">avg_prob_miss_detect</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">assigns</span><span class="p">,</span> <span class="n">costs</span><span class="p">):</span>
                        <span class="n">new_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
                        <span class="n">new_hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span>
                            <span class="o">+</span> <span class="n">num_meas</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clutter</span><span class="p">)</span>
                            <span class="o">+</span> <span class="n">pmd_log</span>
                            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                            <span class="o">-</span> <span class="n">c</span>
                        <span class="p">)</span>
                        <span class="n">new_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_pred</span> <span class="o">*</span> <span class="n">a</span>
                        <span class="p">)</span>
                        <span class="n">up_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hyp</span><span class="p">)</span>
        <span class="n">lse</span> <span class="o">=</span> <span class="n">log_sum_exp</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">up_hyps</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">up_hyps</span><span class="p">)):</span>
            <span class="n">up_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">up_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">-</span> <span class="n">lse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">up_hyps</span>

    <span class="k">def</span> <span class="nf">_calc_avg_prob_det_mdet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">avg_prob_detect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">))</span>
        <span class="n">avg_prob_miss_detect</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">avg_prob_detect</span>

        <span class="k">return</span> <span class="n">avg_prob_detect</span><span class="p">,</span> <span class="n">avg_prob_miss_detect</span>

    <span class="k">def</span> <span class="nf">_clean_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">used</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">nnz_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">used</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">track_cnt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nnz_inds</span><span class="p">)</span>

        <span class="n">new_inds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nnz_inds</span><span class="p">,</span> <span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">track_cnt</span><span class="p">)]):</span>
            <span class="n">new_inds</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="c1"># new_tab = [self._TabEntry().setup(self._track_tab[ii]) for ii in nnz_inds]</span>
        <span class="n">new_tab</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">nnz_inds</span><span class="p">]</span>
        <span class="n">new_hyps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">track_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_inds</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">track_set</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="n">track_set</span>
            <span class="n">new_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hyp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">new_tab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="n">new_hyps</span>

<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.correct">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.correct">[docs]</a>
    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correction step of the GLMB filter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This corrects the hypotheses based on the measurements and gates the</span>
<span class="sd">        measurements according to the class settings. It also updates the</span>
<span class="sd">        cardinality distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            Current timestep.</span>
<span class="sd">        meas_in : list</span>
<span class="sd">            List of Nm x 1 numpy arrays each representing a measuremnt.</span>
<span class="sd">        filt_args : dict, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters correct function.</span>
<span class="sd">            The default is {}.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Fix the measurement gating</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># gate measurements by tracks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Gating not implemented yet. SKIPPING&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="c1"># means = []</span>
            <span class="c1"># covs = []</span>
            <span class="c1"># for ent in self._track_tab:</span>
            <span class="c1">#     means.extend(ent.probDensity.means)</span>
            <span class="c1">#     covs.extend(ent.probDensity.covariances)</span>
            <span class="c1"># meas = self._gate_meas(meas, means, covs)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">meas</span><span class="p">))</span>
        <span class="n">num_meas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>

        <span class="c1"># missed detection tracks</span>
        <span class="n">cor_tab</span><span class="p">,</span> <span class="n">all_cost_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_cor_tab</span><span class="p">(</span><span class="n">num_meas</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>

        <span class="c1"># Calculation for average detection/missed probabilities</span>
        <span class="n">avg_prob_det</span><span class="p">,</span> <span class="n">avg_prob_mdet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_avg_prob_det_mdet</span><span class="p">()</span>

        <span class="c1"># component updates</span>
        <span class="n">cor_hyps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_cor_hyps</span><span class="p">(</span><span class="n">num_meas</span><span class="p">,</span> <span class="n">avg_prob_det</span><span class="p">,</span> <span class="n">avg_prob_mdet</span><span class="p">,</span> <span class="n">all_cost_m</span><span class="p">)</span>

        <span class="c1"># save values and cleanup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">cor_tab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="n">cor_hyps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_updates</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_extract_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">track</span><span class="p">):</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">track</span><span class="o">.</span><span class="n">state_hist</span><span class="p">)</span>
        <span class="n">covs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">track</span><span class="o">.</span><span class="n">state_hist</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">w_lst</span><span class="p">,</span> <span class="n">s_lst</span><span class="p">,</span> <span class="n">c_lst</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">track</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">,</span> <span class="n">track</span><span class="o">.</span><span class="n">state_hist</span><span class="p">,</span> <span class="n">track</span><span class="o">.</span><span class="n">cov_hist</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">w_lst</span><span class="p">)</span>
            <span class="n">states</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_lst</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
                <span class="n">covs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_lst</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">covs</span>

    <span class="k">def</span> <span class="nf">_update_extract_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_cmp</span><span class="p">):</span>
        <span class="n">used_meas_inds</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span><span class="p">)]</span>
        <span class="n">used_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_extract_hists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">idx_cmp</span><span class="p">]</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">track</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">trk_ind</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">trk_ind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">idx_cmp</span><span class="p">]</span><span class="o">.</span><span class="n">track_set</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ExtractHistHelper</span><span class="p">()</span>
            <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="n">label</span>
            <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_ind_hist</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="n">time_index</span>
            <span class="p">(</span>
                <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">,</span>
                <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">covs</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_helper</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>

            <span class="n">used_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">track</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">t_inds_after_b</span><span class="p">,</span> <span class="n">meas_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_ind_hist</span>
            <span class="p">):</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">+</span> <span class="n">t_inds_after_b</span>
                <span class="k">if</span> <span class="n">meas_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">meas_ind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_meas_inds</span><span class="p">[</span><span class="n">tt</span><span class="p">]:</span>
                    <span class="n">used_meas_inds</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meas_ind</span><span class="p">)</span>
        <span class="n">good_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">existing</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span><span class="p">):</span>
            <span class="n">used</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">used_labels</span>
            <span class="k">if</span> <span class="n">used</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">t_inds_after_b</span><span class="p">,</span> <span class="n">meas_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">existing</span><span class="o">.</span><span class="n">meas_ind_hist</span><span class="p">):</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">+</span> <span class="n">t_inds_after_b</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">meas_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">meas_ind</span> <span class="ow">in</span> <span class="n">used_meas_inds</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">:</span>
                <span class="n">good_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">good_inds</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_extract_hists</span><span class="p">)</span>

<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.extract_states">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.extract_states">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">calc_states</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts the best state estimates.</span>

<span class="sd">        This extracts the best states from the distribution. It should be</span>
<span class="sd">        called once per time step after the correction function. This calls</span>
<span class="sd">        both the inner filters predict and correct functions so the keyword</span>
<span class="sd">        arguments must contain any additional variables needed by those</span>
<span class="sd">        functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        update : bool, optional</span>
<span class="sd">            Flag indicating if the label history should be updated. This should</span>
<span class="sd">            be done once per timestep and can be disabled if calculating states</span>
<span class="sd">            after the final timestep. The default is True.</span>
<span class="sd">        calc_states : bool, optional</span>
<span class="sd">            Flag indicating if the states should be calculated based on the</span>
<span class="sd">            label history. This only needs to be done before the states are used.</span>
<span class="sd">            It can simply be called once after the end of the simulation. The</span>
<span class="sd">            default is true.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx_cmp : int</span>
<span class="sd">            Index of the hypothesis table used when extracting states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">card</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span>
        <span class="n">tracks_per_hyp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">num_tracks</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">])</span>
        <span class="n">weight_per_hyp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tracks_per_hyp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">idx_cmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">weight_per_hyp</span> <span class="o">*</span> <span class="p">(</span><span class="n">tracks_per_hyp</span> <span class="o">==</span> <span class="n">card</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_extract_hist</span><span class="p">(</span><span class="n">idx_cmp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">calc_states</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">existing</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t_inds_after_b</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="n">existing</span><span class="o">.</span><span class="n">states</span><span class="p">,</span> <span class="n">existing</span><span class="o">.</span><span class="n">covs</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">tt</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">+</span> <span class="n">t_inds_after_b</span>
                    <span class="c1"># if len(self._labels[tt]) == 0:</span>
                    <span class="c1">#     self._states[tt] = [s]</span>
                    <span class="c1">#     self._labels[tt] = [existing.label]</span>
                    <span class="c1">#     self._covs[tt] = [c]</span>
                    <span class="c1"># else:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">existing</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">update</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">calc_states</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Extracting states performed no actions&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx_cmp</span></div>


<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.extract_most_prob_states">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.extract_most_prob_states">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_most_prob_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thresh</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts the most probable hypotheses up to a threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        thresh : float</span>
<span class="sd">            Minimum association probability to extract.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        state_sets : list</span>
<span class="sd">            Each element is the state list from the normal</span>
<span class="sd">            :meth:`carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.extract_states`.</span>
<span class="sd">        label_sets : list</span>
<span class="sd">            Each element is the label list from the normal</span>
<span class="sd">            :meth:`carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.extract_states`</span>
<span class="sd">        cov_sets : list</span>
<span class="sd">            Each element is the covariance list from the normal</span>
<span class="sd">            :meth:`carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.extract_states`</span>
<span class="sd">            if the covariances are saved.</span>
<span class="sd">        probs : list</span>
<span class="sd">            Each element is the association probability for the extracted states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loc_self</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">state_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cov_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">label_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">loc_self</span><span class="o">.</span><span class="n">extract_states</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">state_sets</span><span class="p">,</span> <span class="n">label_sets</span><span class="p">,</span> <span class="n">cov_sets</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>
        <span class="n">state_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loc_self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">label_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loc_self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">loc_self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">cov_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loc_self</span><span class="o">.</span><span class="n">covariances</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loc_self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
        <span class="n">loc_self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">loc_self</span><span class="o">.</span><span class="n">extract_states</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">loc_self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">:</span>
                <span class="n">state_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loc_self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="n">label_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loc_self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">loc_self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
                    <span class="n">cov_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loc_self</span><span class="o">.</span><span class="n">covariances</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="n">probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loc_self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                <span class="n">loc_self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">state_sets</span><span class="p">,</span> <span class="n">label_sets</span><span class="p">,</span> <span class="n">cov_sets</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_prune</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes hypotheses below a threshold.</span>

<span class="sd">        This should be called once per time step after the correction and</span>
<span class="sd">        before the state extraction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find hypotheses with low association probabilities</span>
        <span class="n">temp_assoc_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)):</span>
            <span class="n">temp_assoc_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">temp_assoc_probs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span>
            <span class="p">)</span>
        <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">temp_assoc_probs</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">prune_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">keep_indices</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># For re-weighing association probabilities</span>
        <span class="n">new_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp_assoc_probs</span><span class="p">[</span><span class="n">keep_indices</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_indices</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">/</span> <span class="n">new_sum</span>
        <span class="c1"># Re-calculate cardinality</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes least likely hypotheses until a maximum number is reached.</span>

<span class="sd">        This should be called once per time step after pruning and</span>
<span class="sd">        before the state extraction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine if there are too many hypotheses</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_hyps</span><span class="p">:</span>
            <span class="n">temp_assoc_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)):</span>
                <span class="n">temp_assoc_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">temp_assoc_probs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span>
                <span class="p">)</span>
            <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">temp_assoc_probs</span><span class="p">)</span>

            <span class="c1"># Reverse order to get descending array</span>
            <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">sorted_indices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Take the top n assoc_probs, where n = max_hyps</span>
            <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_hyps</span><span class="p">):</span>
                <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keep_indices</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">sorted_indices</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span>
            <span class="c1"># Assign to class</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>

            <span class="c1"># Normalize association probabilities</span>
            <span class="n">new_sum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)):</span>
                <span class="n">new_sum</span> <span class="o">=</span> <span class="n">new_sum</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">/</span> <span class="n">new_sum</span>
                <span class="p">)</span>
            <span class="c1"># Re-calculate cardinality</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)</span>

<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.cleanup">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.cleanup">[docs]</a>
    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">enable_prune</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">enable_cap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">enable_extract</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">extract_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs the cleanup step of the filter.</span>

<span class="sd">        This can prune, cap, and extract states. It must be called once per</span>
<span class="sd">        timestep, even if all three functions are disabled. This is to ensure</span>
<span class="sd">        that internal counters for tracking linear timestep indices are properly</span>
<span class="sd">        incremented. If this is called with `enable_extract` set to true then</span>
<span class="sd">        the extract states method does not need to be called separately. It is</span>
<span class="sd">        recommended to call this function instead of</span>
<span class="sd">        :meth:`carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.extract_states`</span>
<span class="sd">        directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        enable_prune : bool, optional</span>
<span class="sd">            Flag indicating if prunning should be performed. The default is True.</span>
<span class="sd">        enable_cap : bool, optional</span>
<span class="sd">            Flag indicating if capping should be performed. The default is True.</span>
<span class="sd">        enable_extract : bool, optional</span>
<span class="sd">            Flag indicating if state extraction should be performed. The default is True.</span>
<span class="sd">        extract_kwargs : dict, optional</span>
<span class="sd">            Additional arguments to pass to :meth:`.extract_states`. The</span>
<span class="sd">            default is None. Only used if extracting states.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">enable_prune</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prune</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">enable_cap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cap</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">enable_extract</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extract_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">extract_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extract_states</span><span class="p">(</span><span class="o">**</span><span class="n">extract_kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_ospa_setup_emat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">state_inds</span><span class="p">):</span>
        <span class="c1"># get sizes</span>
        <span class="n">num_timesteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="n">num_objs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lbl_to_ind</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lbl_to_ind</span><span class="p">:</span>
                    <span class="n">lbl_to_ind</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_objs</span>
                    <span class="n">num_objs</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># create matrices</span>
        <span class="n">est_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">num_objs</span><span class="p">))</span>
        <span class="n">est_cov_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">num_objs</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="p">(</span><span class="n">lbl_lst</span><span class="p">,</span> <span class="n">s_lst</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lbl_lst</span><span class="p">,</span> <span class="n">s_lst</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">obj_num</span> <span class="o">=</span> <span class="n">lbl_to_ind</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]</span>
                <span class="n">est_mat</span><span class="p">[:,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">obj_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">state_inds</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="p">(</span><span class="n">lbl_lst</span><span class="p">,</span> <span class="n">c_lst</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariances</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lbl_lst</span><span class="p">,</span> <span class="n">c_lst</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">est_cov_mat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">lbl_to_ind</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">state_inds</span><span class="p">][</span>
                        <span class="p">:,</span> <span class="n">state_inds</span>
                    <span class="p">]</span>
        <span class="k">return</span> <span class="n">est_mat</span><span class="p">,</span> <span class="n">est_cov_mat</span>

<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.calculate_ospa2">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.calculate_ospa2">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_ospa2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">truth</span><span class="p">,</span>
        <span class="n">c</span><span class="p">,</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">win_len</span><span class="p">,</span>
        <span class="n">true_covs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">core_method</span><span class="o">=</span><span class="n">SingleObjectDistance</span><span class="o">.</span><span class="n">MANHATTAN</span><span class="p">,</span>
        <span class="n">state_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the OSPA(2) distance between the truth at all timesteps.</span>

<span class="sd">        Wrapper for :func:`serums.distances.calculate_ospa2`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        truth : list</span>
<span class="sd">            Each element represents a timestep and is a list of N x 1 numpy array,</span>
<span class="sd">            one per true agent in the swarm.</span>
<span class="sd">        c : float</span>
<span class="sd">            Distance cutoff for considering a point properly assigned. This</span>
<span class="sd">            influences how cardinality errors are penalized. For :math:`p = 1`</span>
<span class="sd">            it is the penalty given false point estimate.</span>
<span class="sd">        p : int</span>
<span class="sd">            The power of the distance term. Higher values penalize outliers</span>
<span class="sd">            more.</span>
<span class="sd">        win_len : int</span>
<span class="sd">            Number of samples to include in window.</span>
<span class="sd">        core_method : :class:`serums.enums.SingleObjectDistance`, Optional</span>
<span class="sd">            The main distance measure to use for the localization component.</span>
<span class="sd">            The default value is :attr:`.SingleObjectDistance.MANHATTAN`.</span>
<span class="sd">        true_covs : list, Optional</span>
<span class="sd">            Each element represents a timestep and is a list of N x N numpy arrays</span>
<span class="sd">            corresonponding to the uncertainty about the true states. Note the</span>
<span class="sd">            order must be consistent with the truth data given. This is only</span>
<span class="sd">            needed for core methods :attr:`SingleObjectDistance.HELLINGER`. The defautl</span>
<span class="sd">            value is None.</span>
<span class="sd">        state_inds : list, optional</span>
<span class="sd">            Indices in the state vector to use, will be applied to the truth</span>
<span class="sd">            data as well. The default is None which means the full state is</span>
<span class="sd">            used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># error checking on optional input arguments</span>
        <span class="n">core_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_input_check</span><span class="p">(</span><span class="n">core_method</span><span class="p">,</span> <span class="n">truth</span><span class="p">,</span> <span class="n">true_covs</span><span class="p">)</span>

        <span class="c1"># setup data structures</span>
        <span class="k">if</span> <span class="n">state_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_find_s_dim</span><span class="p">(</span><span class="n">truth</span><span class="p">)</span>
            <span class="n">state_inds</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">state_dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">state_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_inds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Failed to get state dimension. SKIPPING OSPA(2) calculation&quot;</span><span class="p">)</span>

            <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;win_len&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">win_len</span>
            <span class="k">return</span>
        <span class="n">true_mat</span><span class="p">,</span> <span class="n">true_cov_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_setup_tmat</span><span class="p">(</span>
            <span class="n">truth</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">true_covs</span><span class="p">,</span> <span class="n">state_inds</span>
        <span class="p">)</span>
        <span class="n">est_mat</span><span class="p">,</span> <span class="n">est_cov_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_setup_emat</span><span class="p">(</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">state_inds</span><span class="p">)</span>

        <span class="c1"># find OSPA</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;win_len&quot;</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">calculate_ospa2</span><span class="p">(</span>
            <span class="n">est_mat</span><span class="p">,</span>
            <span class="n">true_mat</span><span class="p">,</span>
            <span class="n">c</span><span class="p">,</span>
            <span class="n">p</span><span class="p">,</span>
            <span class="n">win_len</span><span class="p">,</span>
            <span class="n">core_method</span><span class="o">=</span><span class="n">core_method</span><span class="p">,</span>
            <span class="n">true_cov_mat</span><span class="o">=</span><span class="n">true_cov_mat</span><span class="p">,</span>
            <span class="n">est_cov_mat</span><span class="o">=</span><span class="n">est_cov_mat</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.plot_states_labels">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.plot_states_labels">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_states_labels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">plt_inds</span><span class="p">,</span>
        <span class="n">ttl</span><span class="o">=</span><span class="s2">&quot;Labeled State Trajectories&quot;</span><span class="p">,</span>
        <span class="n">x_lbl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_lbl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">meas_tx_fnc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the best estimate for the states and labels.</span>

<span class="sd">        This assumes that the states have been extracted. It&#39;s designed to plot</span>
<span class="sd">        two of the state variables (typically x/y position). The error ellipses</span>
<span class="sd">        are calculated according to :cite:`Hoover1984_AlgorithmsforConfidenceCirclesandEllipses`</span>

<span class="sd">        Keywrod arguments are processed with</span>
<span class="sd">        :meth:`gncpy.plotting.init_plotting_opts`. This function</span>
<span class="sd">        implements</span>

<span class="sd">            - f_hndl</span>
<span class="sd">            - true_states</span>
<span class="sd">            - sig_bnd</span>
<span class="sd">            - rng</span>
<span class="sd">            - meas_inds</span>
<span class="sd">            - lgnd_loc</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plt_inds : list</span>
<span class="sd">            List of indices in the state vector to plot</span>
<span class="sd">        ttl : string, optional</span>
<span class="sd">            Title of the plot.</span>
<span class="sd">        x_lbl : string, optional</span>
<span class="sd">            X-axis label for the plot.</span>
<span class="sd">        y_lbl : string, optional</span>
<span class="sd">            Y-axis label for the plot.</span>
<span class="sd">        meas_tx_fnc : callable, optional</span>
<span class="sd">            Takes in the measurement vector as an Nm x 1 numpy array and</span>
<span class="sd">            returns a numpy array representing the states to plot (size 2). The</span>
<span class="sd">            default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Matplotlib figure</span>
<span class="sd">            Instance of the matplotlib figure used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>
        <span class="n">true_states</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;true_states&quot;</span><span class="p">]</span>
        <span class="n">sig_bnd</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;sig_bnd&quot;</span><span class="p">]</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;rng&quot;</span><span class="p">]</span>
        <span class="n">meas_inds</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;meas_inds&quot;</span><span class="p">]</span>
        <span class="n">lgnd_loc</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;lgnd_loc&quot;</span><span class="p">]</span>
        <span class="n">mrkr</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;marker&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_lbl</span> <span class="o">=</span> <span class="s2">&quot;x-position&quot;</span>
        <span class="k">if</span> <span class="n">y_lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_lbl</span> <span class="o">=</span> <span class="s2">&quot;y-position&quot;</span>
        <span class="n">meas_specs_given</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">meas_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas_inds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="n">meas_tx_fnc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">plt_meas</span> <span class="o">=</span> <span class="n">meas_specs_given</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span>
        <span class="n">show_sig</span> <span class="o">=</span> <span class="n">sig_bnd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span>

        <span class="n">s_lst</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="n">l_lst</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">x_dim</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">f_hndl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># get state dimension</span>
        <span class="k">for</span> <span class="n">states</span> <span class="ow">in</span> <span class="n">s_lst</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x_dim</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                <span class="k">break</span>
        <span class="c1"># get unique labels</span>
        <span class="n">u_lbls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lbls</span> <span class="ow">in</span> <span class="n">l_lst</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lbls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">lbls</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">u_lbls</span><span class="p">:</span>
                    <span class="n">u_lbls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u_lbls</span><span class="p">))</span>

        <span class="c1"># get array of all state values for each label</span>
        <span class="n">added_sig_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_true_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_state_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_meas_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">c_idx</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">u_lbls</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x_dim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_lst</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">show_sig</span><span class="p">:</span>
                <span class="n">sigs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_lst</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">lbls</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l_lst</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lbls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">lbls</span><span class="p">:</span>
                    <span class="n">ii</span> <span class="o">=</span> <span class="n">lbls</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">s_lst</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">[:,</span> <span class="p">[</span><span class="n">tt</span><span class="p">]]</span> <span class="o">=</span> <span class="n">s_lst</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">show_sig</span><span class="p">:</span>
                        <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                            <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                            <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                            <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">sig</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">sigs</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span>
            <span class="c1"># plot</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">c_idx</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">show_sig</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">sig</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sigs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">calc_error_ellipse</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig_bnd</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">added_sig_lbl</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$</span><span class="si">{}</span><span class="s2">\sigma$ Error Ellipses&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sig_bnd</span><span class="p">)</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">Ellipse</span><span class="p">(</span>
                            <span class="n">xy</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">,</span> <span class="n">tt</span><span class="p">],</span>
                            <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                            <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                            <span class="n">angle</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                            <span class="n">zorder</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span>
                            <span class="n">label</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">added_sig_lbl</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">Ellipse</span><span class="p">(</span>
                            <span class="n">xy</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">,</span> <span class="n">tt</span><span class="p">],</span>
                            <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                            <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                            <span class="n">angle</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                            <span class="n">zorder</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">set_clip_box</span><span class="p">(</span><span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="n">color</span><span class="p">,</span>
                <span class="s2">&quot;markeredgecolor&quot;</span><span class="p">:</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
                <span class="s2">&quot;marker&quot;</span><span class="p">:</span> <span class="n">mrkr</span><span class="p">,</span>
                <span class="s2">&quot;ls&quot;</span><span class="p">:</span> <span class="s2">&quot;--&quot;</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">added_state_lbl</span><span class="p">:</span>
                <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;States&quot;</span>
                <span class="c1"># f_hndl.axes[0].scatter(x[plt_inds[0], :], x[plt_inds[1], :],</span>
                <span class="c1">#                        color=color, edgecolors=&#39;k&#39;,</span>
                <span class="c1">#                        label=&#39;States&#39;)</span>
                <span class="n">added_state_lbl</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># else:</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:],</span> <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span> <span class="o">**</span><span class="n">settings</span><span class="p">)</span>

            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lbl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
                <span class="n">tmp</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span>
            <span class="p">)</span>
        <span class="c1"># if true states are available then plot them</span>
        <span class="k">if</span> <span class="n">true_states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">true_states</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">x_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">states</span> <span class="ow">in</span> <span class="n">true_states</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x_dim</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                        <span class="k">break</span>
            <span class="n">max_true</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">true_states</span><span class="p">])</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x_dim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_states</span><span class="p">),</span> <span class="n">max_true</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">states</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">true_states</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">states</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">[:,</span> <span class="p">[</span><span class="n">tt</span><span class="p">],</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_true</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">added_true_lbl</span><span class="p">:</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;True Trajectories&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">added_true_lbl</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">if</span> <span class="n">plt_meas</span><span class="p">:</span>
            <span class="n">meas_x</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">meas_y</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">meas_tt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">meas_tx_fnc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tx_meas</span> <span class="o">=</span> <span class="p">[</span><span class="n">meas_tx_fnc</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meas_tt</span><span class="p">]</span>
                    <span class="n">mx_ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">tm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">tm</span> <span class="ow">in</span> <span class="n">tx_meas</span><span class="p">]</span>
                    <span class="n">my_ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">tm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">tm</span> <span class="ow">in</span> <span class="n">tx_meas</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mx_ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">meas_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meas_tt</span><span class="p">]</span>
                    <span class="n">my_ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">meas_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meas_tt</span><span class="p">]</span>
                <span class="n">meas_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">mx_ii</span><span class="p">)</span>
                <span class="n">meas_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">my_ii</span><span class="p">)</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">)</span>
            <span class="n">meas_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">meas_x</span><span class="p">)</span>
            <span class="n">meas_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">meas_y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">meas_x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">added_meas_lbl</span><span class="p">:</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                        <span class="n">meas_x</span><span class="p">,</span>
                        <span class="n">meas_y</span><span class="p">,</span>
                        <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Measurements&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                        <span class="n">meas_x</span><span class="p">,</span> <span class="n">meas_y</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;^&quot;</span>
                    <span class="p">)</span>
        <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span>
            <span class="n">f_hndl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="n">ttl</span><span class="p">,</span> <span class="n">x_lbl</span><span class="o">=</span><span class="s2">&quot;x-position&quot;</span><span class="p">,</span> <span class="n">y_lbl</span><span class="o">=</span><span class="s2">&quot;y-position&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">lgnd_loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">lgnd_loc</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">f_hndl</span></div>


<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.plot_card_dist">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.plot_card_dist">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the current cardinality distribution.</span>

<span class="sd">        This assumes that the cardinality distribution has been calculated by</span>
<span class="sd">        the class.</span>

<span class="sd">        Keywrod arguments are processed with</span>
<span class="sd">        :meth:`gncpy.plotting.init_plotting_opts`. This function</span>
<span class="sd">        implements</span>

<span class="sd">            - f_hndl</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ttl : string</span>
<span class="sd">            Title of the plot, if None a default title is generated. The default</span>
<span class="sd">            is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Matplotlib figure</span>
<span class="sd">            Instance of the matplotlib figure used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ttl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ttl</span> <span class="o">=</span> <span class="s2">&quot;Cardinality Distribution&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeWarning</span><span class="p">(</span><span class="s2">&quot;Empty Cardinality&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f_hndl</span>
        <span class="k">if</span> <span class="n">f_hndl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">))</span>
        <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span>

        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span>
            <span class="n">f_hndl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="n">ttl</span><span class="p">,</span> <span class="n">x_lbl</span><span class="o">=</span><span class="s2">&quot;Cardinality&quot;</span><span class="p">,</span> <span class="n">y_lbl</span><span class="o">=</span><span class="s2">&quot;Probability&quot;</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">f_hndl</span></div>


<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.plot_card_history">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.plot_card_history">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_card_history</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">time_units</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="s2">&quot;Cardinality History&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the cardinality history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_units : string, optional</span>
<span class="sd">            Text representing the units of time in the plot. The default is</span>
<span class="sd">            &#39;index&#39;.</span>
<span class="sd">        time : numpy array, optional</span>
<span class="sd">            Vector to use for the x-axis of the plot. If none is given then</span>
<span class="sd">            vector indices are used. The default is None.</span>
<span class="sd">        ttl : string, optional</span>
<span class="sd">            Title of the plot.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional plotting options for :meth:`gncpy.plotting.init_plotting_opts`</span>
<span class="sd">            function. Values implemented here are `f_hndl`, and any values</span>
<span class="sd">            relating to title/axis text formatting.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib figure</span>
<span class="sd">            Figure object the data was plotted on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">card_history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">state_set</span><span class="p">)</span> <span class="k">for</span> <span class="n">state_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">])</span>

        <span class="n">opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">card_history</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">card_history</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;estimated&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">useOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span>
            <span class="n">fig</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">opts</span><span class="p">,</span>
            <span class="n">ttl</span><span class="o">=</span><span class="n">ttl</span><span class="p">,</span>
            <span class="n">x_lbl</span><span class="o">=</span><span class="s2">&quot;Time (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_units</span><span class="p">),</span>
            <span class="n">y_lbl</span><span class="o">=</span><span class="s2">&quot;Cardinality&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="GeneralizedLabeledMultiBernoulli.plot_ospa2_history">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GeneralizedLabeledMultiBernoulli.plot_ospa2_history">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_ospa2_history</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time_units</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">main_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sub_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_subs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the OSPA2 history.</span>

<span class="sd">        This requires that the OSPA2 has been calcualted by the approriate</span>
<span class="sd">        function first.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_units : string, optional</span>
<span class="sd">            Text representing the units of time in the plot. The default is</span>
<span class="sd">            &#39;index&#39;.</span>
<span class="sd">        time : numpy array, optional</span>
<span class="sd">            Vector to use for the x-axis of the plot. If none is given then</span>
<span class="sd">            vector indices are used. The default is None.</span>
<span class="sd">        main_opts : dict, optional</span>
<span class="sd">            Additional plotting options for :meth:`gncpy.plotting.init_plotting_opts`</span>
<span class="sd">            function. Values implemented here are `f_hndl`, and any values</span>
<span class="sd">            relating to title/axis text formatting. The default of None implies</span>
<span class="sd">            the default options are used for the main plot.</span>
<span class="sd">        sub_opts : dict, optional</span>
<span class="sd">            Additional plotting options for :meth:`gncpy.plotting.init_plotting_opts`</span>
<span class="sd">            function. Values implemented here are `f_hndl`, and any values</span>
<span class="sd">            relating to title/axis text formatting. The default of None implies</span>
<span class="sd">            the default options are used for the sub plot.</span>
<span class="sd">        plot_subs : bool, optional</span>
<span class="sd">            Flag indicating if the component statistics (cardinality and</span>
<span class="sd">            localization) should also be plotted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        figs : dict</span>
<span class="sd">            Dictionary of matplotlib figure objects the data was plotted on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;OSPA must be calculated before plotting&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">main_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">main_opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sub_opts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">plot_subs</span><span class="p">:</span>
            <span class="n">sub_opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">()</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2"> OSPA2 (c = </span><span class="si">{:.1f}</span><span class="s2">, p = </span><span class="si">{:d}</span><span class="s2">, w=</span><span class="si">{:d}</span><span class="s2">)&quot;</span>
        <span class="n">ttl</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;win_len&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">y_lbl</span> <span class="o">=</span> <span class="s2">&quot;OSPA2&quot;</span>

        <span class="n">figs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">figs</span><span class="p">[</span><span class="s2">&quot;OSPA2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plt_ospa_hist</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span><span class="p">,</span> <span class="n">time_units</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">ttl</span><span class="p">,</span> <span class="n">y_lbl</span><span class="p">,</span> <span class="n">main_opts</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_subs</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2"> OSPA2 Components (c = </span><span class="si">{:.1f}</span><span class="s2">, p = </span><span class="si">{:d}</span><span class="s2">, w=</span><span class="si">{:d}</span><span class="s2">)&quot;</span>
            <span class="n">ttl</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;win_len&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">y_lbls</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Localiztion&quot;</span><span class="p">,</span> <span class="s2">&quot;Cardinality&quot;</span><span class="p">]</span>
            <span class="n">figs</span><span class="p">[</span><span class="s2">&quot;OSPA2_subs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plt_ospa_hist_subs</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span><span class="p">],</span>
                <span class="n">time_units</span><span class="p">,</span>
                <span class="n">time</span><span class="p">,</span>
                <span class="n">ttl</span><span class="p">,</span>
                <span class="n">y_lbls</span><span class="p">,</span>
                <span class="n">main_opts</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">figs</span></div>
</div>



<span class="k">class</span> <span class="nc">_STMGLMBBase</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_filt_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distrib</span><span class="p">):</span>
        <span class="n">filt_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">]</span>
        <span class="n">covs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">distrib</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="n">distrib</span><span class="o">.</span><span class="n">dof</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">scalings</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">filt_states</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
                <span class="c1"># no need to copy because cov is already a new object for the student&#39;s t-fitler</span>
                <span class="n">covs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span>
        <span class="k">return</span> <span class="n">filt_states</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">covs</span>

    <span class="k">def</span> <span class="nf">_gate_meas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO: check this implementation</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">scalings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">:</span>
            <span class="n">scalings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">probDensity</span><span class="o">.</span><span class="n">scalings</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">scalings</span><span class="p">):</span>
            <span class="n">meas_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">get_meas_mat</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">get_est_meas</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">meas_noise_dof</span>
                <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">dof</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">meas_noise_dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">P_zz</span> <span class="o">=</span> <span class="n">meas_mat</span> <span class="o">@</span> <span class="n">p</span> <span class="o">@</span> <span class="n">meas_mat</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">meas_noise</span>
            <span class="n">inv_P</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">P_zz</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">valid</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">innov</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">est</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">innov</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">inv_P</span> <span class="o">@</span> <span class="n">innov</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_chi2_gate</span><span class="p">:</span>
                    <span class="n">valid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="n">valid</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">meas</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">valid</span><span class="p">]</span>


<span class="c1"># Note: need inherited classes in this order for proper MRO</span>
<div class="viewcode-block" id="STMGeneralizedLabeledMultiBernoulli">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.STMGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.STMGeneralizedLabeledMultiBernoulli">[docs]</a>
<span class="k">class</span> <span class="nc">STMGeneralizedLabeledMultiBernoulli</span><span class="p">(</span>
    <span class="n">_STMGLMBBase</span><span class="p">,</span> <span class="n">GeneralizedLabeledMultiBernoulli</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of a STM-GLMB filter.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="STMGeneralizedLabeledMultiBernoulli.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.STMGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.STMGeneralizedLabeledMultiBernoulli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<span class="k">class</span> <span class="nc">_SMCGLMBBase</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">compute_prob_detection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compute_prob_survive</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_prob_detection</span> <span class="o">=</span> <span class="n">compute_prob_detection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_prob_survive</span> <span class="o">=</span> <span class="n">compute_prob_survive</span>

        <span class="c1"># for wrappers for predict/correct function to handle extra args for private functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prob_surv_args</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prob_det_args</span> <span class="o">=</span> <span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_filt_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distrib</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">init_from_dist</span><span class="p">(</span><span class="n">distrib</span><span class="p">,</span> <span class="n">make_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">filt_states</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">(),</span>
        <span class="p">]</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">distrib</span><span class="o">.</span><span class="n">mean</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">distrib</span><span class="o">.</span><span class="n">covariance</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mi">1</span><span class="p">,</span>
        <span class="p">]</span>  <span class="c1"># not needed so set to 1</span>

        <span class="k">return</span> <span class="n">filt_states</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">covs</span>

    <span class="k">def</span> <span class="nf">_calc_avg_prob_surv_death</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">avg_prob_survive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">tabidx</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="c1"># TODO: fix hack so not using &quot;private&quot; variable outside class</span>
            <span class="n">p_surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_prob_survive</span><span class="p">(</span>
                <span class="n">ent</span><span class="o">.</span><span class="n">filt_states</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;_particleDist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_prob_surv_args</span>
            <span class="p">)</span>
            <span class="n">avg_prob_survive</span><span class="p">[</span><span class="n">tabidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">filt_states</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;_particleDist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_surv</span>
            <span class="p">)</span>
        <span class="n">avg_prob_death</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">avg_prob_survive</span>

        <span class="k">return</span> <span class="n">avg_prob_survive</span><span class="p">,</span> <span class="n">avg_prob_death</span>

    <span class="k">def</span> <span class="nf">_inner_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">num_particles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>

            <span class="c1"># manually update weights to account for prob survive</span>
            <span class="c1"># TODO: fix hack so not using &quot;private&quot; variable outside class</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_prob_survive</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_prob_surv_args</span>
            <span class="p">)</span>
            <span class="n">new_weights</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">w</span> <span class="o">*</span> <span class="n">ps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">tot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">new_weights</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tot</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">w_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_weights</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">/</span> <span class="n">tot</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">new_weights</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">update_weights</span><span class="p">(</span><span class="n">w_lst</span><span class="p">)</span>

            <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
                <span class="n">new_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
            <span class="n">new_s</span> <span class="o">=</span> <span class="n">state</span>
            <span class="n">new_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span>
        <span class="k">return</span> <span class="n">new_f_state</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">new_cov</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">prob_surv_args</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prediction step of the SMC-GLMB filter.</span>

<span class="sd">        This is a wrapper for the parent class to allow for extra parameters.</span>
<span class="sd">        See :meth:`.tracker.GeneralizedLabeledMultiBernoulli.predict` for</span>
<span class="sd">        additional details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep : float</span>
<span class="sd">            Current timestep.</span>
<span class="sd">        prob_surv_args : tuple, optional</span>
<span class="sd">            Additional arguments for the `compute_prob_survive` function.</span>
<span class="sd">            The default is ().</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            See :meth:`.tracker.GeneralizedLabeledMultiBernoulli.predict`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prob_surv_args</span> <span class="o">=</span> <span class="n">prob_surv_args</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_avg_prob_det_mdet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">avg_prob_detect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">tabidx</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="c1"># TODO: fix hack so not using &quot;private&quot; variable outside class</span>
            <span class="n">p_detect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_prob_detection</span><span class="p">(</span>
                <span class="n">ent</span><span class="o">.</span><span class="n">filt_states</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;_particleDist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_prob_det_args</span>
            <span class="p">)</span>
            <span class="n">avg_prob_detect</span><span class="p">[</span><span class="n">tabidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">filt_states</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;_particleDist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_detect</span>
            <span class="p">)</span>
        <span class="n">avg_prob_miss_detect</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">avg_prob_detect</span>

        <span class="k">return</span> <span class="n">avg_prob_detect</span><span class="p">,</span> <span class="n">avg_prob_miss_detect</span>

    <span class="k">def</span> <span class="nf">_inner_correct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">,</span> <span class="n">distrib_weight</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">num_particles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cor_state</span><span class="p">,</span> <span class="n">likely</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># manually update the particle weights to account for probability of detection</span>
            <span class="c1"># TODO: fix hack so not using &quot;private&quot; variable outside class</span>
            <span class="n">pd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_prob_detection</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_prob_det_args</span>
            <span class="p">)</span>
            <span class="n">pd_weight</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">pd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">update_weights</span><span class="p">(</span>
                <span class="p">(</span><span class="n">pd_weight</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pd_weight</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="c1"># determine the partial cost, the remainder is calculated later from</span>
            <span class="c1"># the hypothesis</span>
            <span class="n">new_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">likely</span> <span class="o">*</span> <span class="n">pd_weight</span><span class="p">)</span>  <span class="c1"># same as cost in this case</span>

            <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
            <span class="n">new_s</span> <span class="o">=</span> <span class="n">cor_state</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
                <span class="n">new_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
            <span class="n">new_s</span> <span class="o">=</span> <span class="n">state</span>
            <span class="n">new_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span>
            <span class="n">new_w</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">new_f_state</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">new_c</span><span class="p">,</span> <span class="n">new_w</span>

    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">prob_det_args</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correction step of the SMC-GLMB filter.</span>

<span class="sd">        This is a wrapper for the parent class to allow for extra parameters.</span>
<span class="sd">        See :meth:`.tracker.GeneralizedLabeledMultiBernoulli.correct` for</span>
<span class="sd">        additional details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep : float</span>
<span class="sd">            Current timestep.</span>
<span class="sd">        prob_det_args : tuple, optional</span>
<span class="sd">            Additional arguments for the `compute_prob_detection` function.</span>
<span class="sd">            The default is ().</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            See :meth:`.tracker.GeneralizedLabeledMultiBernoulli.correct`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prob_det_args</span> <span class="o">=</span> <span class="n">prob_det_args</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extract_most_prob_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts themost probable states.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Implement this function for the SMC-GLMB filter</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeWarning</span>
<span class="sd">            Function must be implemented.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Not implemented for this class&quot;</span><span class="p">)</span>


<span class="c1"># Note: need inherited classes in this order for proper MRO</span>
<div class="viewcode-block" id="SMCGeneralizedLabeledMultiBernoulli">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.SMCGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.SMCGeneralizedLabeledMultiBernoulli">[docs]</a>
<span class="k">class</span> <span class="nc">SMCGeneralizedLabeledMultiBernoulli</span><span class="p">(</span>
    <span class="n">_SMCGLMBBase</span><span class="p">,</span> <span class="n">GeneralizedLabeledMultiBernoulli</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of a Sequential Monte Carlo GLMB filter.</span>

<span class="sd">    This is based on :cite:`Vo2014_LabeledRandomFiniteSetsandtheBayesMultiTargetTrackingFilter`</span>
<span class="sd">    It does not account for agents spawned from existing tracks, only agents</span>
<span class="sd">    birthed from the given birth model.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    compute_prob_detection : callable</span>
<span class="sd">        Function that takes a list of particles as the first argument and `*args`</span>
<span class="sd">        as the next. Returns the probability of detection for each particle as a list.</span>
<span class="sd">    compute_prob_survive : callable</span>
<span class="sd">        Function that takes a list of particles as the first argument and `*args` as</span>
<span class="sd">        the next. Returns the average probability of survival for each particle as a list.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SMCGeneralizedLabeledMultiBernoulli.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.SMCGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.SMCGeneralizedLabeledMultiBernoulli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="GSMGeneralizedLabeledMultiBernoulli">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GSMGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GSMGeneralizedLabeledMultiBernoulli">[docs]</a>
<span class="k">class</span> <span class="nc">GSMGeneralizedLabeledMultiBernoulli</span><span class="p">(</span><span class="n">GeneralizedLabeledMultiBernoulli</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of a GSM-GLMB filter.</span>

<span class="sd">    The implementation of the GSM-GLMB fitler does not change for different core</span>
<span class="sd">    filters (i.e. QKF GSM, SQKF GSM, UKF GSM, etc.) so this class can use any</span>
<span class="sd">    of the GSM inner filters from gncpy.filters</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GSMGeneralizedLabeledMultiBernoulli.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GSMGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GSMGeneralizedLabeledMultiBernoulli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<span class="k">class</span> <span class="nc">_IMMGLMBBase</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_filt_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distrib</span><span class="p">):</span>
        <span class="n">filt_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">distrib</span><span class="o">.</span><span class="n">covariances</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">distrib</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">distrib</span><span class="o">.</span><span class="n">covariances</span><span class="p">)):</span>
            <span class="c1"># if len(m) != 1 or len(cov) != 1:</span>
            <span class="c1">#     raise ValueError(&quot;Only one mean can be passed to IMM filters for initialization&quot;)</span>
            <span class="n">m_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">c_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">in_filt_list</span><span class="p">)):</span>
                <span class="n">m_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">c_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">initialize_states</span><span class="p">(</span><span class="n">m_list</span><span class="p">,</span> <span class="n">c_list</span><span class="p">)</span>
            <span class="n">filt_states</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">filt_states</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">covs</span>

    <span class="k">def</span> <span class="nf">_inner_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="n">new_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>
        <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">new_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">new_f_state</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">new_cov</span>

    <span class="k">def</span> <span class="nf">_inner_correct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">,</span> <span class="n">distrib_weight</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="n">cor_state</span><span class="p">,</span> <span class="n">likely</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>
        <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="n">new_s</span> <span class="o">=</span> <span class="n">cor_state</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">new_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="n">distrib_weight</span> <span class="o">*</span> <span class="n">likely</span>

        <span class="k">return</span> <span class="n">new_f_state</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">new_c</span><span class="p">,</span> <span class="n">new_w</span>


<div class="viewcode-block" id="IMMGeneralizedLabeledMultiBernoulli">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.IMMGeneralizedLabeledMultiBernoulli">[docs]</a>
<span class="k">class</span> <span class="nc">IMMGeneralizedLabeledMultiBernoulli</span><span class="p">(</span>
    <span class="n">_IMMGLMBBase</span><span class="p">,</span> <span class="n">GeneralizedLabeledMultiBernoulli</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An implementation of the IMM-GLMB algorithm.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="IMMGeneralizedLabeledMultiBernoulli.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.IMMGeneralizedLabeledMultiBernoulli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="JointGeneralizedLabeledMultiBernoulli">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.JointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.JointGeneralizedLabeledMultiBernoulli">[docs]</a>
<span class="k">class</span> <span class="nc">JointGeneralizedLabeledMultiBernoulli</span><span class="p">(</span><span class="n">GeneralizedLabeledMultiBernoulli</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements a Joint Generalized Labeled Multi-Bernoulli Filter.</span>

<span class="sd">    The Joint GLMB is designed to call predict and correct simultaneously,</span>
<span class="sd">    as a single joint prediction-correction step.</span>
<span class="sd">    Calling them asynchronously may cause poor performance.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is based on :cite:`Vo2017_AnEfficientImplementationoftheGeneralizedLabeledMultiBernoulliFilter`.</span>
<span class="sd">    It does not account for agents spawned from existing tracks, only agents</span>
<span class="sd">    birthed from the given birth model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="JointGeneralizedLabeledMultiBernoulli.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.JointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.JointGeneralizedLabeledMultiBernoulli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_old_track_tab_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_has_been_called</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">True</span>  <span class="c1"># used to denote if the update function should be called or not.</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">rng</span></div>


<div class="viewcode-block" id="JointGeneralizedLabeledMultiBernoulli.save_filter_state">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.JointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.JointGeneralizedLabeledMultiBernoulli.save_filter_state">[docs]</a>
    <span class="k">def</span> <span class="nf">save_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves filter variables so they can be restored later.</span>

<span class="sd">        Note that to pickle the resulting dictionary the :code:`dill` package</span>
<span class="sd">        may need to be used due to potential pickling of functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filt_state</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>

        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_old_track_tab_len&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_track_tab_len</span>

        <span class="k">return</span> <span class="n">filt_state</span></div>


<div class="viewcode-block" id="JointGeneralizedLabeledMultiBernoulli.load_filter_state">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.JointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.JointGeneralizedLabeledMultiBernoulli.load_filter_state">[docs]</a>
    <span class="k">def</span> <span class="nf">load_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes filter using saved filter state.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        filt_state : dict</span>
<span class="sd">            Dictionary generated by :meth:`save_filter_state`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_old_track_tab_len</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_old_track_tab_len&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="JointGeneralizedLabeledMultiBernoulli.predict">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.JointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.JointGeneralizedLabeledMultiBernoulli.predict">[docs]</a>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prediction step of the JGLMB filter.</span>

<span class="sd">        This predicts new hypothesis, and propogates them to the next time</span>
<span class="sd">        step. Because this calls</span>
<span class="sd">        the inner filter&#39;s predict function, the keyword arguments must contain</span>
<span class="sd">        any information needed by that function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            Current timestep.</span>
<span class="sd">        filt_args : dict, optional</span>
<span class="sd">            Passed to the inner filter. The default is {}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_has_been_called</span><span class="p">:</span>
            <span class="c1"># Birth Track Table</span>
            <span class="n">birth_tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_birth_tab</span><span class="p">(</span><span class="n">timestep</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">birth_tab</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Joint GLMB should call predict and correct simultaneously&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_has_been_called</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Survival Track Table</span>
        <span class="n">surv_tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_surv_tab</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>

        <span class="c1"># Prediction Track Table</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">birth_tab</span> <span class="o">+</span> <span class="n">surv_tab</span></div>


    <span class="k">def</span> <span class="nf">_unique_faster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="n">difference</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">keyind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">difference</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">mindices</span> <span class="o">=</span> <span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keyind</span><span class="p">)])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mindices</span>

    <span class="k">def</span> <span class="nf">_calc_avg_prob_surv_death</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">avg_surv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_track_tab_len</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">avg_surv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">avg_surv</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">avg_surv</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_survive</span>
        <span class="c1"># avg_surv = np.array([avg_surv]).T</span>
        <span class="n">avg_death</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">avg_surv</span>
        <span class="k">return</span> <span class="n">avg_surv</span><span class="p">,</span> <span class="n">avg_death</span>

    <span class="k">def</span> <span class="nf">_calc_avg_prob_det_mdet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">avg_detect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">))</span>
        <span class="c1"># avg_detect = np.array([avg_detect]).T</span>
        <span class="n">avg_miss</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">avg_detect</span>
        <span class="k">return</span> <span class="n">avg_detect</span><span class="p">,</span> <span class="n">avg_miss</span>

    <span class="k">def</span> <span class="nf">_gen_cor_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">num_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="n">up_tab</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">track</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># measurement updated tracks</span>
        <span class="n">all_cost_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_pred</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">))</span>
        <span class="c1"># for emm, z in enumerate(meas):</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">emm</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
                <span class="n">s_to_ii</span> <span class="o">=</span> <span class="n">num_pred</span> <span class="o">*</span> <span class="n">emm</span> <span class="o">+</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">num_pred</span>
                <span class="p">(</span><span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">],</span> <span class="n">cost</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_track_tab_entry</span><span class="p">(</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span>
                <span class="p">)</span>

                <span class="c1"># update association history with current measurement index</span>
                <span class="k">if</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">emm</span><span class="p">)</span>
                <span class="n">all_cost_m</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">emm</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="k">return</span> <span class="n">up_tab</span><span class="p">,</span> <span class="n">all_cost_m</span>

    <span class="k">def</span> <span class="nf">_gen_cor_hyps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_meas</span><span class="p">,</span>
        <span class="n">avg_prob_detect</span><span class="p">,</span>
        <span class="n">avg_prob_miss_detect</span><span class="p">,</span>
        <span class="n">avg_prob_surv</span><span class="p">,</span>
        <span class="n">avg_prob_death</span><span class="p">,</span>
        <span class="n">all_cost_m</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Define clutter</span>
        <span class="n">clutter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span>
        <span class="c1"># clutter = self.clutter_den</span>

        <span class="c1"># Joint Cost Matrix</span>
        <span class="n">joint_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">avg_prob_death</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">avg_prob_surv</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">*</span> <span class="n">avg_prob_miss_detect</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">other_jc_terms</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">((</span><span class="n">avg_prob_surv</span> <span class="o">*</span> <span class="n">avg_prob_detect</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">))</span>
            <span class="o">*</span> <span class="n">all_cost_m</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">clutter</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Full joint cost matrix</span>
        <span class="n">joint_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">joint_cost</span><span class="p">,</span> <span class="n">other_jc_terms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Gated Measurement index matrix</span>
        <span class="n">gate_meas_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">),</span> <span class="n">num_meas</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">gatemeas</span><span class="p">)):</span>
                <span class="n">gate_meas_indices</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">gatemeas</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
        <span class="n">gate_meas_indc</span> <span class="o">=</span> <span class="n">gate_meas_indices</span> <span class="o">&gt;=</span> <span class="mi">0</span>

        <span class="c1"># Component updates</span>
        <span class="n">ss_w</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">up_hyp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p_hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
            <span class="n">ss_w</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p_hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
            <span class="n">cpreds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
            <span class="n">num_births</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">)</span>
            <span class="n">num_exists</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span>
            <span class="n">num_tracks</span> <span class="o">=</span> <span class="n">num_births</span> <span class="o">+</span> <span class="n">num_exists</span>

            <span class="c1"># Hypothesis index masking</span>
            <span class="n">tindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_births</span><span class="p">),</span> <span class="n">num_births</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">))</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">lselmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">),</span> <span class="n">num_meas</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">lselmask</span><span class="p">[</span><span class="n">tindices</span><span class="p">,]</span> <span class="o">=</span> <span class="n">gate_meas_indc</span><span class="p">[</span><span class="n">tindices</span><span class="p">,]</span>

            <span class="n">keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">gate_meas_indices</span><span class="p">[</span><span class="n">lselmask</span><span class="p">])])</span>
            <span class="n">mindices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_faster</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

            <span class="n">comb_tind_cpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tindices</span><span class="p">,</span> <span class="n">cpreds</span> <span class="o">+</span> <span class="n">tindices</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">cpreds</span> <span class="o">+</span> <span class="n">mindices</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="c1"># print(joint_cost.shape)</span>
            <span class="c1"># print(tindices)</span>
            <span class="c1"># print(comb_tind_cpred)</span>
            <span class="n">cost_m</span> <span class="o">=</span> <span class="n">joint_cost</span><span class="p">[</span><span class="n">tindices</span><span class="p">][:,</span> <span class="n">comb_tind_cpred</span><span class="p">]</span>
            <span class="c1"># print(cost_m.shape)</span>
            <span class="c1"># cost_m = np.zeros((len(tindices), len(comb_tind_cpred)))</span>
            <span class="c1"># cmi = 0</span>
            <span class="c1"># for ind in tindices:</span>
            <span class="c1">#     cost_m[cmi, :] = joint_cost[ind, comb_tind_cpred]</span>
            <span class="c1">#     cmi = cmi + 1</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="n">neg_log</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cost_m</span><span class="p">)</span>

            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">req_upd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span> <span class="o">/</span> <span class="n">ss_w</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">item</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Gibbs Sampler</span>
            <span class="p">[</span><span class="n">assigns</span><span class="p">,</span> <span class="n">costs</span><span class="p">]</span> <span class="o">=</span> <span class="n">gibbs</span><span class="p">(</span><span class="n">neg_log</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="p">)</span>

            <span class="c1"># Process unique assighnments from gibbs sampler</span>
            <span class="n">assigns</span><span class="p">[</span><span class="n">assigns</span> <span class="o">&lt;</span> <span class="n">num_tracks</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">assigns</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">assigns</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">assigns</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num_tracks</span> <span class="ow">and</span> <span class="n">assigns</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_tracks</span><span class="p">:</span>
                        <span class="n">assigns</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">assigns</span><span class="p">)[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">assigns</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num_tracks</span>
                            <span class="ow">and</span> <span class="n">assigns</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_tracks</span>
                        <span class="p">):</span>
                            <span class="n">assigns</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">assigns</span><span class="p">[</span><span class="n">assigns</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_tracks</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_tracks</span>
            <span class="k">if</span> <span class="n">assigns</span><span class="p">[</span><span class="n">assigns</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">assigns</span><span class="p">[</span><span class="n">assigns</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mindices</span><span class="p">[</span>
                    <span class="n">assigns</span><span class="p">[</span><span class="n">assigns</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span>
                        <span class="n">assigns</span><span class="p">[</span><span class="n">assigns</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                    <span class="p">]</span>
                <span class="p">]</span>
            <span class="c1"># Assign updated hypotheses from gibbs sampler</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cst</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">costs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
                <span class="n">update_hyp_cmp_temp</span> <span class="o">=</span> <span class="n">assigns</span><span class="p">[</span><span class="n">c</span><span class="p">,]</span>
                <span class="n">update_hyp_cmp_idx</span> <span class="o">=</span> <span class="n">cpreds</span> <span class="o">*</span> <span class="p">(</span><span class="n">update_hyp_cmp_temp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_births</span><span class="p">)]),</span>
                    <span class="n">num_births</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]),</span>
                <span class="p">)</span>
                <span class="n">new_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
                <span class="n">new_hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span>
                    <span class="o">+</span> <span class="n">num_meas</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clutter</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                    <span class="o">-</span> <span class="n">cst</span>
                <span class="p">)</span>
                <span class="n">new_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="n">update_hyp_cmp_idx</span><span class="p">[</span><span class="n">update_hyp_cmp_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                    <span class="nb">int</span>
                <span class="p">)</span>
                <span class="n">up_hyp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hyp</span><span class="p">)</span>
        <span class="n">lse</span> <span class="o">=</span> <span class="n">log_sum_exp</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">up_hyp</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">up_hyp</span><span class="p">)):</span>
            <span class="n">up_hyp</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">up_hyp</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">-</span> <span class="n">lse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">up_hyp</span>

<div class="viewcode-block" id="JointGeneralizedLabeledMultiBernoulli.correct">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.JointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.JointGeneralizedLabeledMultiBernoulli.correct">[docs]</a>
    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correction step of the JGLMB filter.</span>

<span class="sd">        This corrects the hypotheses based on the measurements and gates the</span>
<span class="sd">        measurements according to the class settings. It also updates the</span>
<span class="sd">        cardinality distribution. Because this calls the inner filter&#39;s correct</span>
<span class="sd">        function, the keyword arguments must contain any information needed by</span>
<span class="sd">        that function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            Current timestep.</span>
<span class="sd">        meas_in : list</span>
<span class="sd">            List of Nm x 1 numpy arrays each representing a measuremnt.</span>
<span class="sd">        filt_args : dict, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters correct function.</span>
<span class="sd">            The default is {}.</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">            Fix the measurement gating</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># gating by tracks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span><span class="p">:</span>
            <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Gating not implemented yet. PLEASE TURN OFF GATING&quot;</span><span class="p">)</span>
            <span class="c1"># for ent in self._track_tab:</span>
            <span class="c1">#     ent.gatemeas = self._gate_meas(meas, ent.probDensity.means,</span>
            <span class="c1">#                                     ent.probDensity.covariances)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">:</span>
                <span class="n">ent</span><span class="o">.</span><span class="n">gatemeas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">))</span>
        <span class="c1"># Pre-calculation of average survival/death probabilities</span>
        <span class="n">avg_prob_surv</span><span class="p">,</span> <span class="n">avg_prob_death</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_avg_prob_surv_death</span><span class="p">()</span>

        <span class="c1"># Pre-calculation of average detection/missed probabilities</span>
        <span class="n">avg_prob_detect</span><span class="p">,</span> <span class="n">avg_prob_miss_detect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_avg_prob_det_mdet</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">meas</span><span class="p">))</span>
        <span class="n">num_meas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>

        <span class="c1"># missed detection tracks</span>
        <span class="p">[</span><span class="n">up_tab</span><span class="p">,</span> <span class="n">all_cost_m</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_cor_tab</span><span class="p">(</span><span class="n">num_meas</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>

        <span class="n">up_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_cor_hyps</span><span class="p">(</span>
            <span class="n">num_meas</span><span class="p">,</span>
            <span class="n">avg_prob_detect</span><span class="p">,</span>
            <span class="n">avg_prob_miss_detect</span><span class="p">,</span>
            <span class="n">avg_prob_surv</span><span class="p">,</span>
            <span class="n">avg_prob_death</span><span class="p">,</span>
            <span class="n">all_cost_m</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">up_tab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="n">up_hyp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_predictions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_updates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_has_been_called</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_old_track_tab_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="STMJointGeneralizedLabeledMultiBernoulli">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.STMJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.STMJointGeneralizedLabeledMultiBernoulli">[docs]</a>
<span class="k">class</span> <span class="nc">STMJointGeneralizedLabeledMultiBernoulli</span><span class="p">(</span>
    <span class="n">_STMGLMBBase</span><span class="p">,</span> <span class="n">JointGeneralizedLabeledMultiBernoulli</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of a STM-JGLMB class.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="STMJointGeneralizedLabeledMultiBernoulli.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.STMJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.STMJointGeneralizedLabeledMultiBernoulli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SMCJointGeneralizedLabeledMultiBernoulli">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.SMCJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.SMCJointGeneralizedLabeledMultiBernoulli">[docs]</a>
<span class="k">class</span> <span class="nc">SMCJointGeneralizedLabeledMultiBernoulli</span><span class="p">(</span>
    <span class="n">_SMCGLMBBase</span><span class="p">,</span> <span class="n">JointGeneralizedLabeledMultiBernoulli</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of a SMC-JGLMB filter.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="SMCJointGeneralizedLabeledMultiBernoulli.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.SMCJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.SMCJointGeneralizedLabeledMultiBernoulli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="GSMJointGeneralizedLabeledMultiBernoulli">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GSMJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GSMJointGeneralizedLabeledMultiBernoulli">[docs]</a>
<span class="k">class</span> <span class="nc">GSMJointGeneralizedLabeledMultiBernoulli</span><span class="p">(</span><span class="n">JointGeneralizedLabeledMultiBernoulli</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of a GSM-JGLMB filter.</span>

<span class="sd">    The implementation of the GSM-JGLMB fitler does not change for different</span>
<span class="sd">    core filters (i.e. QKF GSM, SQKF GSM, UKF GSM, etc.) so this class can use</span>
<span class="sd">    any of the GSM inner filters from gncpy.filters</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GSMJointGeneralizedLabeledMultiBernoulli.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.GSMJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.GSMJointGeneralizedLabeledMultiBernoulli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="IMMJointGeneralizedLabeledMultiBernoulli">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.IMMJointGeneralizedLabeledMultiBernoulli">[docs]</a>
<span class="k">class</span> <span class="nc">IMMJointGeneralizedLabeledMultiBernoulli</span><span class="p">(</span>
    <span class="n">_IMMGLMBBase</span><span class="p">,</span> <span class="n">JointGeneralizedLabeledMultiBernoulli</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of an IMM-JGLMB filter.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="IMMJointGeneralizedLabeledMultiBernoulli.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.IMMJointGeneralizedLabeledMultiBernoulli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="MSJointGeneralizedLabeledMultiBernoulli">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.MSJointGeneralizedLabeledMultiBernoulli">[docs]</a>
<span class="k">class</span> <span class="nc">MSJointGeneralizedLabeledMultiBernoulli</span><span class="p">(</span><span class="n">JointGeneralizedLabeledMultiBernoulli</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of the Multiple Sensor JGLMB Filter&quot;&quot;&quot;</span>

<div class="viewcode-block" id="MSJointGeneralizedLabeledMultiBernoulli.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.MSJointGeneralizedLabeledMultiBernoulli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_gen_cor_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">comb_inds</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">num_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="n">num_sens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>
        <span class="c1"># if len(meas) != len(self.filter.meas_model_list):</span>
        <span class="c1">#     raise ValueError(&quot;measurement lists must match number of measurement models&quot;)</span>
        <span class="n">up_tab</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">track</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># measurement updated tracks</span>
        <span class="n">all_cost_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_pred</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">emm</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
                <span class="n">s_to_ii</span> <span class="o">=</span> <span class="n">num_pred</span> <span class="o">*</span> <span class="n">emm</span> <span class="o">+</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">num_pred</span>
                <span class="p">(</span><span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">],</span> <span class="n">cost</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_track_tab_entry</span><span class="p">(</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comb_inds</span><span class="p">[</span><span class="n">emm</span><span class="p">])</span>
                <span class="n">all_cost_m</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">emm</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>

        <span class="k">return</span> <span class="n">up_tab</span><span class="p">,</span> <span class="n">all_cost_m</span>

    <span class="k">def</span> <span class="nf">_gen_cor_hyps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_meas</span><span class="p">,</span>
        <span class="n">avg_prob_detect</span><span class="p">,</span>
        <span class="n">avg_prob_miss_detect</span><span class="p">,</span>
        <span class="n">avg_prob_surv</span><span class="p">,</span>
        <span class="n">avg_prob_death</span><span class="p">,</span>
        <span class="n">all_cost_m</span><span class="p">,</span>
        <span class="n">meas_combs</span><span class="p">,</span>
        <span class="n">cor_tab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Define clutter</span>
        <span class="n">clutter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span>

        <span class="c1"># Joint Cost Matrix</span>
        <span class="n">joint_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">avg_prob_death</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">avg_prob_surv</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">*</span> <span class="n">avg_prob_miss_detect</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">other_jc_terms</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">((</span><span class="n">avg_prob_surv</span> <span class="o">*</span> <span class="n">avg_prob_detect</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">))</span>
            <span class="o">*</span> <span class="n">all_cost_m</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">clutter</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Full joint cost matrix for sensor s</span>
        <span class="n">joint_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">joint_cost</span><span class="p">,</span> <span class="n">other_jc_terms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">gate_meas_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">),</span> <span class="n">num_meas</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">gatemeas</span><span class="p">)):</span>
                <span class="n">gate_meas_indices</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">gatemeas</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
        <span class="n">gate_meas_indc</span> <span class="o">=</span> <span class="n">gate_meas_indices</span> <span class="o">&gt;=</span> <span class="mi">0</span>

        <span class="c1"># Component updates</span>
        <span class="n">ss_w</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">up_hyp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p_hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
            <span class="n">ss_w</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p_hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ind_lst</span> <span class="ow">in</span> <span class="n">meas_combs</span><span class="p">:</span>
                <span class="n">cpreds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>  <span class="c1"># num_pred</span>
                <span class="n">num_births</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">)</span>  <span class="c1"># num_birth_terms</span>
                <span class="n">num_exists</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span>  <span class="c1"># num_existing_tracks</span>
                <span class="n">num_tracks</span> <span class="o">=</span> <span class="n">num_births</span> <span class="o">+</span> <span class="n">num_exists</span>  <span class="c1"># num_possible_tracks</span>

                <span class="c1"># Hypothesis index masking</span>
                <span class="c1"># all birth terms and tracks included in p_hyp.track_set</span>
                <span class="n">tindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_births</span><span class="p">),</span> <span class="n">num_births</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">))</span>
                <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="c1"># lselmask = np.zeros((len(self._track_tab), len(ind_lst)), dtype=&quot;bool&quot;)</span>
                <span class="n">lselmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">),</span> <span class="n">num_meas</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
                <span class="c1"># lselmask = np.</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ind_lst</span><span class="p">):</span>
                    <span class="n">lselmask</span><span class="p">[</span><span class="n">tindices</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">gate_meas_indc</span><span class="p">[</span><span class="n">tindices</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>

                <span class="c1"># verify sort works for 3d arrays similar to 2d arrays, may have to do this list-wise</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">gate_meas_indices</span><span class="p">[</span><span class="n">lselmask</span><span class="p">])])</span>
                <span class="c1"># keys = np.array([np.sort(gate_meas_indices[:, ind_lst][lselmask])])</span>
                <span class="c1"># meas_indices</span>
                <span class="n">mindices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_faster</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

                <span class="n">comb_tind_cpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tindices</span><span class="p">,</span> <span class="n">cpreds</span> <span class="o">+</span> <span class="n">tindices</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">cpreds</span> <span class="o">+</span> <span class="n">mindices</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># comb_tind_cpred = np.append(</span>
                <span class="c1">#     np.append(tindices, cpreds + tindices), relevant_meas_inds</span>
                <span class="c1"># ).astype(int)</span>

                <span class="n">cost_m</span> <span class="o">=</span> <span class="n">joint_cost</span><span class="p">[</span><span class="n">tindices</span><span class="p">][:,</span> <span class="n">comb_tind_cpred</span><span class="p">]</span>

                <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
                    <span class="n">neg_log</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cost_m</span><span class="p">)</span>

                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">req_upd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span> <span class="o">/</span> <span class="n">ss_w</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">item</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># Gibbs Sampler</span>
                <span class="p">[</span><span class="n">assigns</span><span class="p">,</span> <span class="n">costs</span><span class="p">]</span> <span class="o">=</span> <span class="n">gibbs</span><span class="p">(</span><span class="n">neg_log</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="p">)</span>

                <span class="c1"># Process unique assignments from gibbs sampler</span>
                <span class="n">assigns</span><span class="p">[</span><span class="n">assigns</span> <span class="o">&lt;</span> <span class="n">num_tracks</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">assigns</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">assigns</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">assigns</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num_tracks</span> <span class="ow">and</span> <span class="n">assigns</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_tracks</span><span class="p">:</span>
                            <span class="n">assigns</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">assigns</span><span class="p">)[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="n">assigns</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num_tracks</span>
                                <span class="ow">and</span> <span class="n">assigns</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_tracks</span>
                            <span class="p">):</span>
                                <span class="n">assigns</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">assigns</span><span class="p">[</span><span class="n">assigns</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_tracks</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_tracks</span>
                <span class="k">if</span> <span class="n">assigns</span><span class="p">[</span><span class="n">assigns</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">assigns</span><span class="p">[</span><span class="n">assigns</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mindices</span><span class="p">[</span>
                        <span class="n">assigns</span><span class="p">[</span><span class="n">assigns</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span>
                            <span class="n">assigns</span><span class="p">[</span><span class="n">assigns</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                        <span class="p">]</span>
                    <span class="p">]</span>
                <span class="c1"># Assign updated hypotheses from gibbs sampler</span>
                <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cst</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">costs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
                    <span class="n">update_hyp_cmp_temp</span> <span class="o">=</span> <span class="n">assigns</span><span class="p">[</span><span class="n">c</span><span class="p">,]</span>
                    <span class="n">update_hyp_cmp_idx</span> <span class="o">=</span> <span class="n">cpreds</span> <span class="o">*</span> <span class="p">(</span><span class="n">update_hyp_cmp_temp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_births</span><span class="p">)]),</span>
                        <span class="n">num_births</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]),</span>
                    <span class="p">)</span>
                    <span class="n">new_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
                    <span class="n">new_hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span>
                        <span class="o">+</span> <span class="n">num_meas</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clutter</span><span class="p">)</span>
                        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                        <span class="o">-</span> <span class="n">cst</span>
                    <span class="p">)</span>
                    <span class="n">new_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="n">update_hyp_cmp_idx</span><span class="p">[</span>
                        <span class="n">update_hyp_cmp_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="n">up_hyp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hyp</span><span class="p">)</span>
        <span class="n">lse</span> <span class="o">=</span> <span class="n">log_sum_exp</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">up_hyp</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">up_hyp</span><span class="p">)):</span>
            <span class="n">up_hyp</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">up_hyp</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">-</span> <span class="n">lse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">up_hyp</span>

<div class="viewcode-block" id="MSJointGeneralizedLabeledMultiBernoulli.correct">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.MSJointGeneralizedLabeledMultiBernoulli.correct">[docs]</a>
    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correction step of the MS-JGLMB filter.</span>

<span class="sd">        This corrects the hypotheses based on the measurements and gates the</span>
<span class="sd">        measurements according to the class settings. It also updates the</span>
<span class="sd">        cardinality distribution. Because this calls the inner filter&#39;s correct</span>
<span class="sd">        function, the keyword arguments must contain any information needed by</span>
<span class="sd">        that function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            Current timestep.</span>
<span class="sd">        meas : list</span>
<span class="sd">            List of lists representing sensor measurements containing Nm x 1 numpy arrays each representing a single measurement.</span>
<span class="sd">        filt_args : dict, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters correct function.</span>
<span class="sd">            The default is {}.</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">            Fix the measurement gating</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_combs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">meas</span><span class="p">))</span>
        <span class="n">num_meas_per_sens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">meas</span><span class="p">]</span>
        <span class="n">num_meas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_combs</span><span class="p">)</span>
        <span class="n">num_sens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>
        <span class="n">mnmps</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_meas_per_sens</span><span class="p">)</span>

        <span class="n">comb_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">meas</span><span class="p">)))</span>
        <span class="n">comb_inds</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span> <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">comb_inds</span><span class="p">]</span>

        <span class="n">all_meas_combs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">comb_inds</span><span class="p">,</span> <span class="n">mnmps</span><span class="p">))</span>
        <span class="n">all_meas_combs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span> <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">all_meas_combs</span><span class="p">]</span>

        <span class="n">poss_meas_combs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_meas_combs</span><span class="p">)):</span>
            <span class="n">break_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">cur_comb</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">lst1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_meas_combs</span><span class="p">[</span><span class="n">ii</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">lst2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_meas_combs</span><span class="p">[</span><span class="n">ii</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">jj</span> <span class="o">==</span> <span class="n">kk</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lst1</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lst2</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
                            <span class="n">break_flag</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="n">break_flag</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">break_flag</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">lst1</span> <span class="ow">in</span> <span class="n">all_meas_combs</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">lst2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comb_inds</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">lst1</span> <span class="o">==</span> <span class="n">lst2</span><span class="p">:</span>
                            <span class="n">cur_comb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
                <span class="n">poss_meas_combs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_comb</span><span class="p">)</span>

        <span class="c1"># gating by tracks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span><span class="p">:</span>
            <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Gating not implemented yet. PLEASE TURN OFF GATING&quot;</span><span class="p">)</span>
            <span class="c1"># for ent in self._track_tab:</span>
            <span class="c1">#     ent.gatemeas = self._gate_meas(meas, ent.probDensity.means,</span>
            <span class="c1">#                                     ent.probDensity.covariances)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">:</span>
                <span class="n">ent</span><span class="o">.</span><span class="n">gatemeas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_combs</span><span class="p">))</span>
                <span class="c1"># ent.gatemeas = np.arange(0, len(poss_meas_combs))</span>
        <span class="c1"># Pre-calculation of average survival/death probabilities</span>
        <span class="n">avg_prob_surv</span><span class="p">,</span> <span class="n">avg_prob_death</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_avg_prob_surv_death</span><span class="p">()</span>

        <span class="c1"># Pre-calculation of average detection/missed probabilities</span>
        <span class="n">avg_prob_detect</span><span class="p">,</span> <span class="n">avg_prob_miss_detect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_avg_prob_det_mdet</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">meas</span><span class="p">))</span>
        <span class="c1"># all_combs = list(itertools.product(*meas))</span>

        <span class="c1"># missed detection tracks</span>
        <span class="p">[</span><span class="n">up_tab</span><span class="p">,</span> <span class="n">all_cost_m</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_cor_tab</span><span class="p">(</span>
            <span class="n">num_meas</span><span class="p">,</span> <span class="n">all_combs</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">comb_inds</span><span class="p">,</span> <span class="n">filt_args</span>
        <span class="p">)</span>

        <span class="n">up_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_cor_hyps</span><span class="p">(</span>
            <span class="n">num_meas</span><span class="p">,</span>
            <span class="n">avg_prob_detect</span><span class="p">,</span>
            <span class="n">avg_prob_miss_detect</span><span class="p">,</span>
            <span class="n">avg_prob_surv</span><span class="p">,</span>
            <span class="n">avg_prob_death</span><span class="p">,</span>
            <span class="n">all_cost_m</span><span class="p">,</span>
            <span class="n">poss_meas_combs</span><span class="p">,</span>
            <span class="n">cor_tab</span><span class="o">=</span><span class="n">up_tab</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">up_tab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="n">up_hyp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_predictions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_updates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_has_been_called</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_old_track_tab_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="MSIMMJointGeneralizedLabeledMultiBernoulli">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSIMMJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.MSIMMJointGeneralizedLabeledMultiBernoulli">[docs]</a>
<span class="k">class</span> <span class="nc">MSIMMJointGeneralizedLabeledMultiBernoulli</span><span class="p">(</span>
    <span class="n">_IMMGLMBBase</span><span class="p">,</span> <span class="n">MSJointGeneralizedLabeledMultiBernoulli</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An implementation of the Multi-Sensor IMM-JGLMB algorithm.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="MSIMMJointGeneralizedLabeledMultiBernoulli.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSIMMJointGeneralizedLabeledMultiBernoulli.html#carbs.swarm_estimator.tracker.MSIMMJointGeneralizedLabeledMultiBernoulli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_correct_track_tab_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">tab</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">newTab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>
        <span class="n">new_f_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_s_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_c_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">depleted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">f_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">,</span>
                <span class="n">newTab</span><span class="o">.</span><span class="n">state_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">newTab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">new_f_states</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_s_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_c_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_w</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">f_state</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ParticleDepletionError</span><span class="p">,</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ParticleEstimationDomainError</span><span class="p">,</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ExtremeMeasurementNoiseError</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">newTab</span><span class="o">.</span><span class="n">filt_states</span> <span class="o">=</span> <span class="n">new_f_states</span>
        <span class="n">newTab</span><span class="o">.</span><span class="n">state_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_s_hist</span>
        <span class="n">newTab</span><span class="o">.</span><span class="n">cov_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_c_hist</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">new_w</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">depleted</span><span class="p">:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">new_w</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">newTab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">/</span> <span class="n">cost</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">new_w</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">newTab</span><span class="p">,</span> <span class="n">cost</span></div>



<div class="viewcode-block" id="PoissonMultiBernoulliMixture">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture">[docs]</a>
<span class="k">class</span> <span class="nc">PoissonMultiBernoulliMixture</span><span class="p">(</span><span class="n">RandomFiniteSetBase</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">_TabEntry</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="p">()</span>  <span class="c1"># time step born, index of birth model born from</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distrib_weights_hist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of weights of the probDensity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># existence probability of the probDensity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filt_states</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of dictionaries from filters save function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meas_assoc_hist</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[]</span>
            <span class="p">)</span>  <span class="c1"># list indices into measurement list per time step</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">state_hist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of lists of numpy arrays for each timestep</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_hist</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[]</span>
            <span class="p">)</span>  <span class="c1"># list of lists of numpy arrays for each timestep (or None)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot; linear index corresponding to timestep, manually updated. Used</span>
<span class="sd">            to index things since timestep in label can have decimals.&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tab</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Use to avoid expensive deepcopy.&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="n">label</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distrib_weights_hist</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="n">exist_prob</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filt_states</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">tab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meas_assoc_hist</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">state_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tab</span><span class="o">.</span><span class="n">state_hist</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_hist</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">s_lst</span> <span class="k">for</span> <span class="n">s_lst</span> <span class="ow">in</span> <span class="n">tab</span><span class="o">.</span><span class="n">state_hist</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_hist</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c_lst</span> <span class="k">for</span> <span class="n">c_lst</span> <span class="ow">in</span> <span class="n">tab</span><span class="o">.</span><span class="n">cov_hist</span><span class="p">]</span>
            <span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="n">time_index</span>

            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">class</span> <span class="nc">_HypothesisHelper</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># indices in lookup table</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">num_tracks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">_ExtractHistHelper</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meas_ind_hist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covs</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="PoissonMultiBernoulliMixture.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">req_upd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gating_on</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">prune_threshold</span><span class="o">=</span><span class="mi">10</span><span class="o">**-</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">exist_threshold</span><span class="o">=</span><span class="mi">10</span><span class="o">**-</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">max_hyps</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
        <span class="n">decimal_places</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">save_measurements</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_upd</span> <span class="o">=</span> <span class="n">req_upd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span> <span class="o">=</span> <span class="n">gating_on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prune_threshold</span> <span class="o">=</span> <span class="n">prune_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exist_threshold</span> <span class="o">=</span> <span class="n">exist_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_hyps</span> <span class="o">=</span> <span class="n">max_hyps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimal_places</span> <span class="o">=</span> <span class="n">decimal_places</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span> <span class="o">=</span> <span class="n">save_measurements</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of all possible tracks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">hyp0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
        <span class="n">hyp0</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">hyp0</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="p">[</span><span class="n">hyp0</span><span class="p">]</span>  <span class="c1"># list of _HypothesisHelper objects</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># probability of having index # as cardinality</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot; linear index corresponding to timestep, manually updated. Used</span>
<span class="sd">            to index things since timestep in label can have decimals. Must</span>
<span class="sd">            be updated once per time step.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="p">[[]]</span></div>


<div class="viewcode-block" id="PoissonMultiBernoulliMixture.save_filter_state">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.save_filter_state">[docs]</a>
    <span class="k">def</span> <span class="nf">save_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves filter variables so they can be restored later.</span>

<span class="sd">        Note that to pickle the resulting dictionary the :code:`dill` package</span>
<span class="sd">        may need to be used due to potential pickling of functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filt_state</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>

        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;req_upd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">req_upd</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;gating_on&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;prune_threshold&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prune_threshold</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;exist_threshold&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exist_threshold</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;max_hyps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_hyps</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;decimal_places&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimal_places</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;save_measurements&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span>

        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_track_tab&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_extractable_hists&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_baseFilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_baseFilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="p">)</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_hypotheses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_card_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_time_index_cntr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span>

        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa2_localization&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa2_cardinality&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span>
        <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_ospa2_params&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_params</span>

        <span class="k">return</span> <span class="n">filt_state</span></div>


<div class="viewcode-block" id="PoissonMultiBernoulliMixture.load_filter_state">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.load_filter_state">[docs]</a>
    <span class="k">def</span> <span class="nf">load_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes filter using saved filter state.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        filt_state : dict</span>
<span class="sd">            Dictionary generated by :meth:`save_filter_state`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">req_upd</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;req_upd&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;gating_on&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prune_threshold</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;prune_threshold&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exist_threshold</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;exist_threshold&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_hyps</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;max_hyps&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimal_places</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;decimal_places&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;save_measurements&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_track_tab&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_extractable_hists&quot;</span><span class="p">]</span>

        <span class="n">cls_type</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_baseFilter&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cls_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span> <span class="o">=</span> <span class="n">cls_type</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_baseFilter&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_hypotheses&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_card_dist&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_time_index_cntr&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa2&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa2_localization&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;ospa2_cardinality&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span> <span class="o">=</span> <span class="n">filt_state</span><span class="p">[</span><span class="s2">&quot;_ospa2_params&quot;</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read only list of extracted states.</span>

<span class="sd">        This is a list with 1 element per timestep, and each element is a list</span>
<span class="sd">        of the best states extracted at that timestep. The order of each</span>
<span class="sd">        element corresponds to the label order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">covariances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read only list of extracted covariances.</span>

<span class="sd">        This is a list with 1 element per timestep, and each element is a list</span>
<span class="sd">        of the best covariances extracted at that timestep. The order of each</span>
<span class="sd">        element corresponds to the state order.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeWarning</span>
<span class="sd">            If the class is not saving the covariances, and returns an empty list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeWarning</span><span class="p">(</span><span class="s2">&quot;Not saving covariances&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inner filter handling dynamics, must be a gncpy.filters.BayesFilter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span>

    <span class="nd">@filter</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cardinality estimate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_filt_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distrib</span><span class="p">):</span>
        <span class="n">filt_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">distrib</span><span class="o">.</span><span class="n">covariances</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">distrib</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">distrib</span><span class="o">.</span><span class="n">covariances</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="p">,</span> <span class="n">gfilts</span><span class="o">.</span><span class="n">UnscentedKalmanFilter</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="p">,</span> <span class="n">gfilts</span><span class="o">.</span><span class="n">UKFGaussianScaleMixtureFilter</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">init_sigma_points</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">filt_states</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">filt_states</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">covs</span>

    <span class="k">def</span> <span class="nf">_inner_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="n">new_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>
        <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">new_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">new_f_state</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">new_cov</span>

    <span class="k">def</span> <span class="nf">_predict_det_tab_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tab</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">new_tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>
        <span class="n">new_f_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_s_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_c_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">f_state</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">,</span> <span class="n">new_tab</span><span class="o">.</span><span class="n">state_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="p">(</span><span class="n">new_f_states</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">new_s_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">new_c_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_predict</span><span class="p">(</span>
                <span class="n">timestep</span><span class="p">,</span> <span class="n">f_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span>
            <span class="p">)</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span> <span class="o">=</span> <span class="n">new_f_states</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">state_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_s_hist</span><span class="p">)</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">cov_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_c_hist</span><span class="p">)</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">=</span> <span class="n">new_tab</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_survive</span>
        <span class="k">return</span> <span class="n">new_tab</span>

    <span class="k">def</span> <span class="nf">_gen_pred_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">pred_tab</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_det_tab_entry</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>
            <span class="n">pred_tab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_tab</span>

<div class="viewcode-block" id="PoissonMultiBernoulliMixture.predict">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.predict">[docs]</a>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}):</span>
        <span class="c1"># all objects are propagated forward regardless of previous associations.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_pred_tab</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_calc_avg_prob_det_mdet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cor_tab</span><span class="p">):</span>
        <span class="n">avg_prob_detect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cor_tab</span><span class="p">))</span>
        <span class="n">avg_prob_miss_detect</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">avg_prob_detect</span>

        <span class="k">return</span> <span class="n">avg_prob_detect</span><span class="p">,</span> <span class="n">avg_prob_miss_detect</span>

    <span class="k">def</span> <span class="nf">_inner_correct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">,</span> <span class="n">distrib_weight</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="n">cor_state</span><span class="p">,</span> <span class="n">likely</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>
        <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="n">new_s</span> <span class="o">=</span> <span class="n">cor_state</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">new_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="n">distrib_weight</span> <span class="o">*</span> <span class="n">likely</span>

        <span class="k">return</span> <span class="n">new_f_state</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">new_c</span><span class="p">,</span> <span class="n">new_w</span>

    <span class="k">def</span> <span class="nf">_correct_track_tab_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">tab</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">new_tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>
        <span class="n">new_f_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_s_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_c_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">depleted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">f_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span><span class="p">,</span>
                <span class="n">new_tab</span><span class="o">.</span><span class="n">state_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">new_tab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">new_f_states</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_s_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_c_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_w</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">f_state</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ParticleDepletionError</span><span class="p">,</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ParticleEstimationDomainError</span><span class="p">,</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ExtremeMeasurementNoiseError</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span> <span class="o">=</span> <span class="n">new_f_states</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">state_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_s_hist</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">cov_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_c_hist</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">new_w</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">depleted</span><span class="p">:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_tab</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">new_w</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span>
                <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">new_tab</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">+</span> <span class="n">new_tab</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="c1"># new_tab.distrib_weights_hist[-1] = [w / cost for w in new_w]</span>
            <span class="n">nw_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">*</span> <span class="n">new_tab</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">new_w</span><span class="p">]</span>
            <span class="n">new_tab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">w</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nw_list</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">nw_list</span>
            <span class="p">]</span>
            <span class="n">new_tab</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">new_tab</span><span class="p">,</span> <span class="n">cost</span>

    <span class="k">def</span> <span class="nf">_correct_birth_tab_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">distrib</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">new_tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span>
        <span class="p">(</span><span class="n">filt_states</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">covs</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_filt_states</span><span class="p">(</span><span class="n">distrib</span><span class="p">)</span>

        <span class="n">new_f_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_s_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_c_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">depleted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">f_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">filt_states</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">weights</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">new_f_states</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_s_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_c_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_w</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">f_state</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ParticleDepletionError</span><span class="p">,</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ParticleEstimationDomainError</span><span class="p">,</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ExtremeMeasurementNoiseError</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span> <span class="o">=</span> <span class="n">new_f_states</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">state_hist</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_s_hist</span><span class="p">]</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">cov_hist</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_c_hist</span><span class="p">]</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">distrib_weights_hist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">new_w</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">depleted</span><span class="p">:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">new_w</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span>
            <span class="p">)</span>
            <span class="n">new_tab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="n">w</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">new_w</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">new_w</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">new_tab</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span>
                <span class="o">*</span> <span class="n">cost</span>
                <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">*</span> <span class="n">cost</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span>
        <span class="k">return</span> <span class="n">new_tab</span><span class="p">,</span> <span class="n">cost</span>

    <span class="k">def</span> <span class="nf">_gen_cor_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">num_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="n">num_birth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">)</span>
        <span class="n">up_tab</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_meas</span> <span class="o">*</span> <span class="n">num_birth</span><span class="p">)</span>

        <span class="c1"># Missed Detection Updates</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">track</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>
            <span class="n">sum_non_exist_prob</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">1</span>
                <span class="o">-</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span>
                <span class="o">+</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span>
            <span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="n">w</span> <span class="o">*</span> <span class="n">sum_non_exist_prob</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span>
            <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sum_non_exist_prob</span><span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># left_cost_m = np.zeros()</span>
        <span class="c1"># all_cost_m = np.zeros((num_pred + num_birth * num_meas, num_meas))</span>
        <span class="n">all_cost_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_meas</span><span class="p">,</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_birth</span> <span class="o">*</span> <span class="n">num_meas</span><span class="p">))</span>

        <span class="c1"># Update for all existing tracks</span>
        <span class="k">for</span> <span class="n">emm</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
                <span class="n">s_to_ii</span> <span class="o">=</span> <span class="n">num_pred</span> <span class="o">*</span> <span class="n">emm</span> <span class="o">+</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">num_pred</span>
                <span class="p">(</span><span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">],</span> <span class="n">cost</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_track_tab_entry</span><span class="p">(</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">emm</span><span class="p">)</span>
                <span class="n">all_cost_m</span><span class="p">[</span><span class="n">emm</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>

        <span class="c1"># Update for all potential new births</span>
        <span class="k">for</span> <span class="n">emm</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">b_model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">):</span>
                <span class="n">s_to_ii</span> <span class="o">=</span> <span class="p">((</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span><span class="p">)</span> <span class="o">+</span> <span class="n">emm</span> <span class="o">*</span> <span class="n">num_birth</span> <span class="o">+</span> <span class="n">ii</span>
                <span class="p">(</span><span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">],</span> <span class="n">cost</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_birth_tab_entry</span><span class="p">(</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">b_model</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">emm</span><span class="p">)</span>
                <span class="n">all_cost_m</span><span class="p">[</span><span class="n">emm</span><span class="p">,</span> <span class="n">emm</span> <span class="o">+</span> <span class="n">num_pred</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="k">return</span> <span class="n">up_tab</span><span class="p">,</span> <span class="n">all_cost_m</span>

    <span class="c1"># TODO: find some way to cherry pick the appropriate all_combs to ensure that</span>
    <span class="c1"># measurements are not duplicated before being passed to assignment</span>
    <span class="k">def</span> <span class="nf">_gen_cor_hyps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">,</span> <span class="n">avg_prob_detect</span><span class="p">,</span> <span class="n">avg_prob_miss_detect</span><span class="p">,</span> <span class="n">all_cost_m</span><span class="p">,</span> <span class="n">cor_tab</span>
    <span class="p">):</span>
        <span class="n">num_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="n">up_hyps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">num_meas</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
                <span class="n">pmd_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">avg_prob_miss_detect</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">+</span> <span class="n">pmd_log</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                <span class="n">up_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hyp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clutter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span>
            <span class="n">ss_w</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">p_hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
                <span class="n">ss_w</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p_hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">num_tracks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># all clutter</span>
                    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_pred</span><span class="p">,</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_meas</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inds</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span>
                        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_pred</span><span class="p">,</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_meas</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="p">)</span>

                <span class="n">cost_m</span> <span class="o">=</span> <span class="n">all_cost_m</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>
                <span class="n">max_row_inds</span><span class="p">,</span> <span class="n">max_col_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cost_m</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">max_row_inds</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cost_m</span><span class="p">[</span><span class="n">max_row_inds</span><span class="p">,</span> <span class="n">max_col_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
                <span class="n">min_row_inds</span><span class="p">,</span> <span class="n">min_col_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cost_m</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">min_row_inds</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cost_m</span><span class="p">[</span><span class="n">min_row_inds</span><span class="p">,</span> <span class="n">min_col_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>  <span class="c1"># 1</span>
                <span class="n">neg_log</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cost_m</span><span class="p">)</span>
                <span class="c1"># if max_row_inds.size &gt; 0:</span>
                <span class="c1">#     neg_log[max_row_inds, max_col_inds] = -np.inf</span>
                <span class="c1"># if min_row_inds.size &gt; 0:</span>
                <span class="c1">#     neg_log[min_row_inds, min_col_inds] = np.inf</span>

                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">req_upd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span> <span class="o">/</span> <span class="n">ss_w</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
                <span class="c1"># if m &lt;1:</span>
                <span class="c1">#     m=1</span>
                <span class="p">[</span><span class="n">assigns</span><span class="p">,</span> <span class="n">costs</span><span class="p">]</span> <span class="o">=</span> <span class="n">murty_m_best_all_meas_assigned</span><span class="p">(</span><span class="n">neg_log</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;assignment matrix consisting of 0 or 1 entries such that each column sums</span>
<span class="sd">                to one and each row sums to zero or one&quot;&quot;&quot;</span>  <span class="c1"># (transposed from the paper)</span>
                <span class="c1"># assigns = assigns.T</span>
                <span class="c1"># assigns = np.delete(assigns, 1, axis=0)</span>
                <span class="c1"># costs = np.delete(costs, 1, axis=0)</span>

                <span class="n">pmd_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">avg_prob_miss_detect</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">assigns</span><span class="p">,</span> <span class="n">costs</span><span class="p">):</span>
                    <span class="n">new_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
                    <span class="n">new_hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span>
                        <span class="o">+</span> <span class="n">num_meas</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clutter</span><span class="p">)</span>
                        <span class="o">+</span> <span class="n">pmd_log</span>
                        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                        <span class="o">-</span> <span class="n">c</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">num_tracks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">new_track_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">num_pred</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">num_pred</span> <span class="o">*</span> <span class="n">num_meas</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># track_inds = np.argwhere(a==1)</span>
                        <span class="n">new_track_list</span> <span class="o">=</span> <span class="p">[]</span>

                        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ms</span><span class="p">:</span>
                                <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">(</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">[(</span><span class="n">ms</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                                <span class="p">)</span>
                            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                                <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="n">num_pred</span> <span class="o">*</span> <span class="n">ms</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_pred</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="p">)</span>
                            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                                <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="n">num_pred</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ms</span> <span class="o">-</span> <span class="n">num_meas</span><span class="p">)</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">(</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span>
                                    <span class="o">-</span> <span class="p">(</span><span class="n">ms</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="p">)</span>
                            <span class="c1"># if len(p_hyp.track_set) &gt;= ms:</span>
                            <span class="c1">#     new_track_list.append(</span>
                            <span class="c1">#         (ii + 1) * num_pred + p_hyp.track_set[(ms - 1)]</span>
                            <span class="c1">#     )</span>
                            <span class="c1"># else:</span>
                            <span class="c1">#     new_track_list.append(</span>
                            <span class="c1">#         (num_meas + 1) * num_pred + ms - num_meas</span>
                            <span class="c1">#     )</span>
                        <span class="c1"># if len(a) == len(p_hyp.track_set):</span>
                        <span class="c1">#     for ii, (ms, t) in enumerate(zip(a, p_hyp.track_set)):</span>
                        <span class="c1">#         if len(p_hyp.track_set) &gt;= ms:</span>
                        <span class="c1">#             # new_track_list.append(((np.array(t)) * ms + num_pred))</span>
                        <span class="c1">#             # new_track_list.append((num_pred * ms + np.array(t)))</span>
                        <span class="c1">#             new_track_list.append(</span>
                        <span class="c1">#                 (ii + 1) * num_pred + p_hyp.track_set[(ms - 1)]</span>
                        <span class="c1">#             )</span>
                        <span class="c1">#         else:</span>
                        <span class="c1">#             new_track_list.append(</span>
                        <span class="c1">#                 num_pred * ms - ii * (num_pred - 1)</span>
                        <span class="c1">#             )</span>
                        <span class="c1"># elif len(p_hyp.track_set) &lt; len(a):</span>
                        <span class="c1">#     for ii, ms in enumerate(a):</span>
                        <span class="c1">#         if len(p_hyp.track_set) &gt;= ms:</span>
                        <span class="c1">#             # coiuld be this one, trying -1 first</span>
                        <span class="c1">#             # new_track_list.append(((np.array(p_hyp.track_set[(ms-ii)]) + num_pred) * ms))</span>
                        <span class="c1">#             # new_track_list.append(((np.array(p_hyp.track_set[(ms-1)]) + num_pred) * ms + num_meas * ii))</span>
                        <span class="c1">#             # new_track_list.append(</span>
                        <span class="c1">#             #     (ms + ii) * num_pred + p_hyp.track_set[(ms - 1)]</span>
                        <span class="c1">#             # )</span>
                        <span class="c1">#             new_track_list.append(</span>
                        <span class="c1">#                 (ii + 1) * num_pred + p_hyp.track_set[(ms - 1)]</span>
                        <span class="c1">#             )</span>
                        <span class="c1">#         elif len(p_hyp.track_set) &lt; ms:</span>
                        <span class="c1">#             new_track_list.append(</span>
                        <span class="c1">#                 num_pred * (num_meas + 1) + (ms - num_meas)</span>
                        <span class="c1">#             )</span>
                        <span class="c1">#             # new_track_list.append(num_meas * num_pred + ms)</span>
                        <span class="c1"># elif len(p_hyp.track_set) &gt; len(a):</span>
                        <span class="c1">#     # May need to modify this</span>
                        <span class="c1">#     for ii, ms in enumerate(a):</span>
                        <span class="c1">#         if len(p_hyp.track_set) &gt;= ms:</span>
                        <span class="c1">#             new_track_list.append(</span>
                        <span class="c1">#                 (ii + 1) * num_pred + p_hyp.track_set[(ms - 1)]</span>
                        <span class="c1">#             )</span>
                        <span class="c1">#             # new_track_list.append(</span>
                        <span class="c1">#             #     (ms - 1) * num_pred + p_hyp.track_set[(ms - 1)]</span>
                        <span class="c1">#             # )</span>
                        <span class="c1">#             # new_track_list.append(</span>
                        <span class="c1">#             #     ms * num_pred + p_hyp.track_set[(ms - 1)]</span>
                        <span class="c1">#             # )</span>
                        <span class="c1">#         elif len(p_hyp.track_set) &lt; ms:</span>
                        <span class="c1">#             new_track_list.append(</span>
                        <span class="c1">#                 num_pred * (num_meas + 1)</span>
                        <span class="c1">#                 + (ms - 1 - len(p_hyp.track_set))</span>
                        <span class="c1">#             )</span>

                        <span class="c1"># new_track_list = list(np.array(p_hyp.track_set) + num_pred + num_pred * a)# new_track_list = list(num_pred * a + np.array(p_hyp.track_set))</span>

                    <span class="n">new_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="n">new_track_list</span>
                    <span class="n">up_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hyp</span><span class="p">)</span>

        <span class="n">lse</span> <span class="o">=</span> <span class="n">log_sum_exp</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">up_hyps</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">up_hyps</span><span class="p">)):</span>
            <span class="n">up_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">up_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">-</span> <span class="n">lse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">up_hyps</span>

    <span class="k">def</span> <span class="nf">_clean_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">used</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">nnz_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">used</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">track_cnt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nnz_inds</span><span class="p">)</span>

        <span class="n">new_inds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nnz_inds</span><span class="p">,</span> <span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">track_cnt</span><span class="p">)]):</span>
            <span class="n">new_inds</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="c1"># new_tab = [self._TabEntry().setup(self._track_tab[ii]) for ii in nnz_inds]</span>
        <span class="n">new_tab</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">nnz_inds</span><span class="p">]</span>
        <span class="n">new_hyps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">track_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_inds</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">track_set</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="n">track_set</span>
            <span class="n">new_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hyp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">new_tab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="n">new_hyps</span>

    <span class="k">def</span> <span class="nf">_calc_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hyp_lst</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calucaltes the cardinality distribution.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hyp_lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="mi">1</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="n">card_dist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">num_tracks</span><span class="p">,</span> <span class="n">hyp_lst</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="n">hyp_lst</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hyp</span><span class="o">.</span><span class="n">num_tracks</span> <span class="o">==</span> <span class="n">ii</span><span class="p">:</span>
                    <span class="n">card</span> <span class="o">=</span> <span class="n">card</span> <span class="o">+</span> <span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span>
            <span class="n">card_dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">card_dist</span>

<div class="viewcode-block" id="PoissonMultiBernoulliMixture.correct">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.correct">[docs]</a>
    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correction step of the PMBM filter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This corrects the hypotheses based on the measurements and gates the</span>
<span class="sd">        measurements according to the class settings. It also updates the</span>
<span class="sd">        cardinality distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            Current timestep.</span>
<span class="sd">        meas : list</span>
<span class="sd">            List of Nm x 1 numpy arrays each representing a measuremnt.</span>
<span class="sd">        filt_args : dict, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters correct function.</span>
<span class="sd">            The default is {}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Gating not implemented yet. SKIPPING&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="c1"># means = []</span>
            <span class="c1"># covs = []</span>
            <span class="c1"># for ent in self._track_tab:</span>
            <span class="c1">#     means.extend(ent.probDensity.means)</span>
            <span class="c1">#     covs.extend(ent.probDensity.covariances)</span>
            <span class="c1"># meas = self._gate_meas(meas, means, covs)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">meas</span><span class="p">))</span>
        <span class="n">num_meas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>
        <span class="n">cor_tab</span><span class="p">,</span> <span class="n">all_cost_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_cor_tab</span><span class="p">(</span><span class="n">num_meas</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>

        <span class="c1"># self._add_birth_hyps(num_meas)</span>

        <span class="n">avg_prob_det</span><span class="p">,</span> <span class="n">avg_prob_mdet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_avg_prob_det_mdet</span><span class="p">(</span><span class="n">cor_tab</span><span class="p">)</span>

        <span class="n">cor_hyps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_cor_hyps</span><span class="p">(</span>
            <span class="n">num_meas</span><span class="p">,</span> <span class="n">avg_prob_det</span><span class="p">,</span> <span class="n">avg_prob_mdet</span><span class="p">,</span> <span class="n">all_cost_m</span><span class="p">,</span> <span class="n">cor_tab</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">cor_tab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="n">cor_hyps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_updates</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_extract_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">track</span><span class="p">):</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">track</span><span class="o">.</span><span class="n">state_hist</span><span class="p">)</span>
        <span class="n">covs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">track</span><span class="o">.</span><span class="n">state_hist</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">w_lst</span><span class="p">,</span> <span class="n">s_lst</span><span class="p">,</span> <span class="n">c_lst</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">track</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">,</span> <span class="n">track</span><span class="o">.</span><span class="n">state_hist</span><span class="p">,</span> <span class="n">track</span><span class="o">.</span><span class="n">cov_hist</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">w_lst</span><span class="p">)</span>
            <span class="n">states</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_lst</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
                <span class="n">covs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_lst</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">covs</span>

    <span class="k">def</span> <span class="nf">_update_extract_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_cmp</span><span class="p">):</span>
        <span class="n">used_meas_inds</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span><span class="p">)]</span>
        <span class="n">new_extract_hists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">idx_cmp</span><span class="p">]</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">track</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">trk_ind</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">trk_ind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">idx_cmp</span><span class="p">]</span><span class="o">.</span><span class="n">track_set</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ExtractHistHelper</span><span class="p">()</span>
            <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_ind_hist</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="n">time_index</span>
            <span class="p">(</span>
                <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">,</span>
                <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">covs</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_helper</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">t_inds_after_b</span><span class="p">,</span> <span class="n">meas_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_ind_hist</span>
            <span class="p">):</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">+</span> <span class="n">t_inds_after_b</span>
                <span class="k">if</span> <span class="n">meas_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">meas_ind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_meas_inds</span><span class="p">[</span><span class="n">tt</span><span class="p">]:</span>
                    <span class="n">used_meas_inds</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meas_ind</span><span class="p">)</span>
        <span class="n">good_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">existing</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t_inds_after_b</span><span class="p">,</span> <span class="n">meas_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">existing</span><span class="o">.</span><span class="n">meas_ind_hist</span><span class="p">):</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">+</span> <span class="n">t_inds_after_b</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">meas_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">meas_ind</span> <span class="ow">in</span> <span class="n">used_meas_inds</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">:</span>
                <span class="n">good_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">good_inds</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_extract_hists</span><span class="p">)</span>

<div class="viewcode-block" id="PoissonMultiBernoulliMixture.extract_states">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.extract_states">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">calc_states</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts the best state estimates.</span>

<span class="sd">        This extracts the best states from the distribution. It should be</span>
<span class="sd">        called once per time step after the correction function. This calls</span>
<span class="sd">        both the inner filters predict and correct functions so the keyword</span>
<span class="sd">        arguments must contain any additional variables needed by those</span>
<span class="sd">        functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        update : bool, optional</span>
<span class="sd">            Flag indicating if the label history should be updated. This should</span>
<span class="sd">            be done once per timestep and can be disabled if calculating states</span>
<span class="sd">            after the final timestep. The default is True.</span>
<span class="sd">        calc_states : bool, optional</span>
<span class="sd">            Flag indicating if the states should be calculated based on the</span>
<span class="sd">            label history. This only needs to be done before the states are used.</span>
<span class="sd">            It can simply be called once after the end of the simulation. The</span>
<span class="sd">            default is true.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx_cmp : int</span>
<span class="sd">            Index of the hypothesis table used when extracting states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">card</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span>
        <span class="n">tracks_per_hyp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">num_tracks</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">])</span>
        <span class="n">weight_per_hyp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tracks_per_hyp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">idx_cmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">weight_per_hyp</span> <span class="o">*</span> <span class="p">(</span><span class="n">tracks_per_hyp</span> <span class="o">==</span> <span class="n">card</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_extract_hist</span><span class="p">(</span><span class="n">idx_cmp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">calc_states</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">existing</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t_inds_after_b</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="n">existing</span><span class="o">.</span><span class="n">states</span><span class="p">,</span> <span class="n">existing</span><span class="o">.</span><span class="n">covs</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">tt</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">+</span> <span class="n">t_inds_after_b</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">update</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">calc_states</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Extracting states performed no actions&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx_cmp</span></div>


    <span class="k">def</span> <span class="nf">_prune</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes hypotheses below a threshold.</span>

<span class="sd">        This should be called once per time step after the correction and</span>
<span class="sd">        before the state extraction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find hypotheses with low association probabilities</span>
        <span class="n">temp_assoc_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)):</span>
            <span class="n">temp_assoc_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">temp_assoc_probs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span>
            <span class="p">)</span>
        <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">temp_assoc_probs</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">prune_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">keep_indices</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># For re-weighing association probabilities</span>
        <span class="n">new_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp_assoc_probs</span><span class="p">[</span><span class="n">keep_indices</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_indices</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">/</span> <span class="n">new_sum</span>
        <span class="c1"># Re-calculate cardinality</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes least likely hypotheses until a maximum number is reached.</span>

<span class="sd">        This should be called once per time step after pruning and</span>
<span class="sd">        before the state extraction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine if there are too many hypotheses</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_hyps</span><span class="p">:</span>
            <span class="n">temp_assoc_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)):</span>
                <span class="n">temp_assoc_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">temp_assoc_probs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span>
                <span class="p">)</span>
            <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">temp_assoc_probs</span><span class="p">)</span>

            <span class="c1"># Reverse order to get descending array</span>
            <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">sorted_indices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Take the top n assoc_probs, where n = max_hyps</span>
            <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_hyps</span><span class="p">):</span>
                <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keep_indices</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">sorted_indices</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span>
            <span class="c1"># Assign to class</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>

            <span class="c1"># Normalize association probabilities</span>
            <span class="n">new_sum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)):</span>
                <span class="n">new_sum</span> <span class="o">=</span> <span class="n">new_sum</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">/</span> <span class="n">new_sum</span>
                <span class="p">)</span>
            <span class="c1"># Re-calculate cardinality</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bern_prune</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes track table entries below a threshold.</span>

<span class="sd">        This should be called once per time step after the correction and</span>
<span class="sd">        before the state extraction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">exist_threshold</span><span class="p">:</span>
                <span class="n">used</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">keep_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">used</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">track_cnt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_inds</span><span class="p">)</span>

        <span class="n">new_inds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keep_inds</span><span class="p">,</span> <span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">track_cnt</span><span class="p">)]):</span>
            <span class="n">new_inds</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># loop over track table and remove pruned entries</span>
        <span class="n">new_tab</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">keep_inds</span><span class="p">]</span>
        <span class="n">new_hyps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">track_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_inds</span><span class="p">[</span><span class="n">track_ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">track_ind</span> <span class="ow">in</span> <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">track_set</span><span class="p">:</span>
                    <span class="n">track_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">track_set</span> <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="n">track_set</span>
            <span class="n">new_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hyp</span><span class="p">)</span>

        <span class="n">del_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># TODO: ADD CASE FOR NO MORE TRACKS SO THAT WE DON&#39;T REMOVE ALL HYPOTHESES</span>
        <span class="c1"># AND OR THE HYPOTHESES HAVE AN EMPTY TRACK SET RATHER THAN A TRACK SET OF NONES</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_hyps</span><span class="p">)):</span>
            <span class="n">same_inds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_hyps</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="n">jj</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">jj</span> <span class="o">==</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">del_inds</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">new_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">track_set</span> <span class="o">==</span> <span class="n">new_hyps</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">.</span><span class="n">track_set</span><span class="p">:</span>
                    <span class="n">same_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">same_inds</span><span class="p">:</span>
                <span class="n">new_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">+=</span> <span class="n">new_hyps</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span>
                <span class="n">del_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span>
        <span class="n">del_inds</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">del_inds</span><span class="p">:</span>
            <span class="n">new_hyps</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">new_tab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="n">new_hyps</span>

<div class="viewcode-block" id="PoissonMultiBernoulliMixture.cleanup">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.cleanup">[docs]</a>
    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">enable_prune</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">enable_cap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">enable_bern_prune</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">enable_extract</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">extract_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs the cleanup step of the filter.</span>

<span class="sd">        This can prune, cap, and extract states. It must be called once per</span>
<span class="sd">        timestep, even if all three functions are disabled. This is to ensure</span>
<span class="sd">        that internal counters for tracking linear timestep indices are properly</span>
<span class="sd">        incremented. If this is called with `enable_extract` set to true then</span>
<span class="sd">        the extract states method does not need to be called separately. It is</span>
<span class="sd">        recommended to call this function instead of</span>
<span class="sd">        :meth:`carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.extract_states`</span>
<span class="sd">        directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        enable_prune : bool, optional</span>
<span class="sd">            Flag indicating if prunning should be performed. The default is True.</span>
<span class="sd">        enable_cap : bool, optional</span>
<span class="sd">            Flag indicating if capping should be performed. The default is True.</span>
<span class="sd">        enable_bern_prune: bool, optional</span>
<span class="sd">            Flag indicating if bernoulli pruning should be performed. The default is True.</span>
<span class="sd">        enable_extract : bool, optional</span>
<span class="sd">            Flag indicating if state extraction should be performed. The default is True.</span>
<span class="sd">        extract_kwargs : dict, optional</span>
<span class="sd">            Additional arguments to pass to :meth:`.extract_states`. The</span>
<span class="sd">            default is None. Only used if extracting states.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">enable_prune</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prune</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">enable_cap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cap</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">enable_bern_prune</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bern_prune</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">enable_extract</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extract_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">extract_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extract_states</span><span class="p">(</span><span class="o">**</span><span class="n">extract_kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="PoissonMultiBernoulliMixture.calculate_ospa2">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.calculate_ospa2">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_ospa2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">truth</span><span class="p">,</span>
        <span class="n">c</span><span class="p">,</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">win_len</span><span class="p">,</span>
        <span class="n">true_covs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">core_method</span><span class="o">=</span><span class="n">SingleObjectDistance</span><span class="o">.</span><span class="n">MANHATTAN</span><span class="p">,</span>
        <span class="n">state_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the OSPA(2) distance between the truth at all timesteps.</span>

<span class="sd">        Wrapper for :func:`serums.distances.calculate_ospa2`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        truth : list</span>
<span class="sd">            Each element represents a timestep and is a list of N x 1 numpy array,</span>
<span class="sd">            one per true agent in the swarm.</span>
<span class="sd">        c : float</span>
<span class="sd">            Distance cutoff for considering a point properly assigned. This</span>
<span class="sd">            influences how cardinality errors are penalized. For :math:`p = 1`</span>
<span class="sd">            it is the penalty given false point estimate.</span>
<span class="sd">        p : int</span>
<span class="sd">            The power of the distance term. Higher values penalize outliers</span>
<span class="sd">            more.</span>
<span class="sd">        win_len : int</span>
<span class="sd">            Number of samples to include in window.</span>
<span class="sd">        core_method : :class:`serums.enums.SingleObjectDistance`, Optional</span>
<span class="sd">            The main distance measure to use for the localization component.</span>
<span class="sd">            The default value is :attr:`.SingleObjectDistance.MANHATTAN`.</span>
<span class="sd">        true_covs : list, Optional</span>
<span class="sd">            Each element represents a timestep and is a list of N x N numpy arrays</span>
<span class="sd">            corresonponding to the uncertainty about the true states. Note the</span>
<span class="sd">            order must be consistent with the truth data given. This is only</span>
<span class="sd">            needed for core methods :attr:`SingleObjectDistance.HELLINGER`. The defautl</span>
<span class="sd">            value is None.</span>
<span class="sd">        state_inds : list, optional</span>
<span class="sd">            Indices in the state vector to use, will be applied to the truth</span>
<span class="sd">            data as well. The default is None which means the full state is</span>
<span class="sd">            used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># error checking on optional input arguments</span>
        <span class="n">core_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_input_check</span><span class="p">(</span><span class="n">core_method</span><span class="p">,</span> <span class="n">truth</span><span class="p">,</span> <span class="n">true_covs</span><span class="p">)</span>

        <span class="c1"># setup data structures</span>
        <span class="k">if</span> <span class="n">state_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_find_s_dim</span><span class="p">(</span><span class="n">truth</span><span class="p">)</span>
            <span class="n">state_inds</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">state_dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">state_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_inds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Failed to get state dimension. SKIPPING OSPA(2) calculation&quot;</span><span class="p">)</span>

            <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;win_len&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">win_len</span>
            <span class="k">return</span>
        <span class="n">true_mat</span><span class="p">,</span> <span class="n">true_cov_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_setup_tmat</span><span class="p">(</span>
            <span class="n">truth</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">true_covs</span><span class="p">,</span> <span class="n">state_inds</span>
        <span class="p">)</span>
        <span class="n">est_mat</span><span class="p">,</span> <span class="n">est_cov_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_setup_emat</span><span class="p">(</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">state_inds</span><span class="p">)</span>

        <span class="c1"># find OSPA</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;win_len&quot;</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">calculate_ospa2</span><span class="p">(</span>
            <span class="n">est_mat</span><span class="p">,</span>
            <span class="n">true_mat</span><span class="p">,</span>
            <span class="n">c</span><span class="p">,</span>
            <span class="n">p</span><span class="p">,</span>
            <span class="n">win_len</span><span class="p">,</span>
            <span class="n">core_method</span><span class="o">=</span><span class="n">core_method</span><span class="p">,</span>
            <span class="n">true_cov_mat</span><span class="o">=</span><span class="n">true_cov_mat</span><span class="p">,</span>
            <span class="n">est_cov_mat</span><span class="o">=</span><span class="n">est_cov_mat</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PoissonMultiBernoulliMixture.plot_states">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.plot_states">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">plt_inds</span><span class="p">,</span>
        <span class="n">state_lbl</span><span class="o">=</span><span class="s2">&quot;States&quot;</span><span class="p">,</span>
        <span class="n">ttl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">state_color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_lbl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_lbl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the best estimate for the states.</span>

<span class="sd">        This assumes that the states have been extracted. It&#39;s designed to plot</span>
<span class="sd">        two of the state variables (typically x/y position). The error ellipses</span>
<span class="sd">        are calculated according to :cite:`Hoover1984_AlgorithmsforConfidenceCirclesandEllipses`</span>

<span class="sd">        Keyword arguments are processed with</span>
<span class="sd">        :meth:`gncpy.plotting.init_plotting_opts`. This function</span>
<span class="sd">        implements</span>

<span class="sd">            - f_hndl</span>
<span class="sd">            - true_states</span>
<span class="sd">            - sig_bnd</span>
<span class="sd">            - rng</span>
<span class="sd">            - meas_inds</span>
<span class="sd">            - lgnd_loc</span>
<span class="sd">            - marker</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plt_inds : list</span>
<span class="sd">            List of indices in the state vector to plot</span>
<span class="sd">        state_lbl : string</span>
<span class="sd">            Value to appear in legend for the states. Only appears if the</span>
<span class="sd">            legend is shown</span>
<span class="sd">        ttl : string, optional</span>
<span class="sd">            Title for the plot, if None a default title is generated. The default</span>
<span class="sd">            is None.</span>
<span class="sd">        x_lbl : string</span>
<span class="sd">            Label for the x-axis.</span>
<span class="sd">        y_lbl : string</span>
<span class="sd">            Label for the y-axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Matplotlib figure</span>
<span class="sd">            Instance of the matplotlib figure used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>
        <span class="n">true_states</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;true_states&quot;</span><span class="p">]</span>
        <span class="n">sig_bnd</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;sig_bnd&quot;</span><span class="p">]</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;rng&quot;</span><span class="p">]</span>
        <span class="n">meas_inds</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;meas_inds&quot;</span><span class="p">]</span>
        <span class="n">lgnd_loc</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;lgnd_loc&quot;</span><span class="p">]</span>
        <span class="n">marker</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;marker&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ttl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ttl</span> <span class="o">=</span> <span class="s2">&quot;State Estimates&quot;</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_lbl</span> <span class="o">=</span> <span class="s2">&quot;x-position&quot;</span>
        <span class="k">if</span> <span class="n">y_lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_lbl</span> <span class="o">=</span> <span class="s2">&quot;y-position&quot;</span>
        <span class="n">plt_meas</span> <span class="o">=</span> <span class="n">meas_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">show_sig</span> <span class="o">=</span> <span class="n">sig_bnd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span>

        <span class="n">s_lst</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">)</span>
        <span class="n">x_dim</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">f_hndl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># get state dimension</span>
        <span class="k">for</span> <span class="n">states</span> <span class="ow">in</span> <span class="n">s_lst</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x_dim</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                <span class="k">break</span>
        <span class="c1"># get array of all state values for each label</span>
        <span class="n">added_sig_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_true_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_state_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_meas_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">state_color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">state_color</span>
        <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">states</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_lst</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">show_sig</span><span class="p">:</span>
                <span class="n">sigs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">cov</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">]):</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">sigs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span>
                <span class="c1"># plot</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">sig</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sigs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">calc_error_ellipse</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig_bnd</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">added_sig_lbl</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$</span><span class="si">{}</span><span class="s2">\sigma$ Error Ellipses&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sig_bnd</span><span class="p">)</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">Ellipse</span><span class="p">(</span>
                            <span class="n">xy</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">,</span> <span class="n">ii</span><span class="p">],</span>
                            <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                            <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                            <span class="n">angle</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                            <span class="n">zorder</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span>
                            <span class="n">label</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">added_sig_lbl</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">Ellipse</span><span class="p">(</span>
                            <span class="n">xy</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">,</span> <span class="n">ii</span><span class="p">],</span>
                            <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                            <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                            <span class="n">angle</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                            <span class="n">zorder</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">set_clip_box</span><span class="p">(</span><span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.15</span><span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">added_state_lbl</span><span class="p">:</span>
                <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:],</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="n">state_lbl</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">added_state_lbl</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:],</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># if true states are available then plot them</span>
        <span class="k">if</span> <span class="n">true_states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">states</span> <span class="ow">in</span> <span class="n">true_states</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x_dim</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                        <span class="k">break</span>
            <span class="n">max_true</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">true_states</span><span class="p">])</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x_dim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_states</span><span class="p">),</span> <span class="n">max_true</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">states</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">true_states</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">states</span><span class="p">):</span>
                    <span class="n">x</span><span class="p">[:,</span> <span class="p">[</span><span class="n">tt</span><span class="p">],</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_true</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">added_true_lbl</span><span class="p">:</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;True Trajectories&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">added_true_lbl</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">if</span> <span class="n">plt_meas</span><span class="p">:</span>
            <span class="n">meas_x</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">meas_y</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">meas_tt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="p">:</span>
                <span class="n">mx_ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">meas_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meas_tt</span><span class="p">]</span>
                <span class="n">my_ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">meas_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meas_tt</span><span class="p">]</span>
                <span class="n">meas_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">mx_ii</span><span class="p">)</span>
                <span class="n">meas_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">my_ii</span><span class="p">)</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">)</span>
            <span class="n">meas_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">meas_x</span><span class="p">)</span>
            <span class="n">meas_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">meas_y</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">added_meas_lbl</span><span class="p">:</span>
                <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                    <span class="n">meas_x</span><span class="p">,</span>
                    <span class="n">meas_y</span><span class="p">,</span>
                    <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Measurements&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                    <span class="n">meas_x</span><span class="p">,</span>
                    <span class="n">meas_y</span><span class="p">,</span>
                    <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span><span class="n">f_hndl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="n">ttl</span><span class="p">,</span> <span class="n">x_lbl</span><span class="o">=</span><span class="n">x_lbl</span><span class="p">,</span> <span class="n">y_lbl</span><span class="o">=</span><span class="n">y_lbl</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lgnd_loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">lgnd_loc</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">f_hndl</span></div>


<div class="viewcode-block" id="PoissonMultiBernoulliMixture.plot_card_dist">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.plot_card_dist">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the current cardinality distribution.</span>

<span class="sd">        This assumes that the cardinality distribution has been calculated by</span>
<span class="sd">        the class.</span>

<span class="sd">        Keywrod arguments are processed with</span>
<span class="sd">        :meth:`gncpy.plotting.init_plotting_opts`. This function</span>
<span class="sd">        implements</span>

<span class="sd">            - f_hndl</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ttl : string</span>
<span class="sd">            Title of the plot, if None a default title is generated. The default</span>
<span class="sd">            is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Matplotlib figure</span>
<span class="sd">            Instance of the matplotlib figure used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ttl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ttl</span> <span class="o">=</span> <span class="s2">&quot;Cardinality Distribution&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeWarning</span><span class="p">(</span><span class="s2">&quot;Empty Cardinality&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f_hndl</span>
        <span class="k">if</span> <span class="n">f_hndl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">))</span>
        <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span>

        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span>
            <span class="n">f_hndl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="n">ttl</span><span class="p">,</span> <span class="n">x_lbl</span><span class="o">=</span><span class="s2">&quot;Cardinality&quot;</span><span class="p">,</span> <span class="n">y_lbl</span><span class="o">=</span><span class="s2">&quot;Probability&quot;</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">f_hndl</span></div>


<div class="viewcode-block" id="PoissonMultiBernoulliMixture.plot_card_history">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.plot_card_history">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_card_history</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">time_units</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="s2">&quot;Cardinality History&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the cardinality history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_units : string, optional</span>
<span class="sd">            Text representing the units of time in the plot. The default is</span>
<span class="sd">            &#39;index&#39;.</span>
<span class="sd">        time : numpy array, optional</span>
<span class="sd">            Vector to use for the x-axis of the plot. If none is given then</span>
<span class="sd">            vector indices are used. The default is None.</span>
<span class="sd">        ttl : string, optional</span>
<span class="sd">            Title of the plot.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional plotting options for :meth:`gncpy.plotting.init_plotting_opts`</span>
<span class="sd">            function. Values implemented here are `f_hndl`, and any values</span>
<span class="sd">            relating to title/axis text formatting.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib figure</span>
<span class="sd">            Figure object the data was plotted on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">card_history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">state_set</span><span class="p">)</span> <span class="k">for</span> <span class="n">state_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">])</span>

        <span class="n">opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">card_history</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">card_history</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;estimated&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">useOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span>
            <span class="n">fig</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">opts</span><span class="p">,</span>
            <span class="n">ttl</span><span class="o">=</span><span class="n">ttl</span><span class="p">,</span>
            <span class="n">x_lbl</span><span class="o">=</span><span class="s2">&quot;Time (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_units</span><span class="p">),</span>
            <span class="n">y_lbl</span><span class="o">=</span><span class="s2">&quot;Cardinality&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="PoissonMultiBernoulliMixture.plot_ospa2_history">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.PoissonMultiBernoulliMixture.plot_ospa2_history">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_ospa2_history</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time_units</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">main_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sub_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_subs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the OSPA2 history.</span>

<span class="sd">        This requires that the OSPA2 has been calcualted by the approriate</span>
<span class="sd">        function first.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_units : string, optional</span>
<span class="sd">            Text representing the units of time in the plot. The default is</span>
<span class="sd">            &#39;index&#39;.</span>
<span class="sd">        time : numpy array, optional</span>
<span class="sd">            Vector to use for the x-axis of the plot. If none is given then</span>
<span class="sd">            vector indices are used. The default is None.</span>
<span class="sd">        main_opts : dict, optional</span>
<span class="sd">            Additional plotting options for :meth:`gncpy.plotting.init_plotting_opts`</span>
<span class="sd">            function. Values implemented here are `f_hndl`, and any values</span>
<span class="sd">            relating to title/axis text formatting. The default of None implies</span>
<span class="sd">            the default options are used for the main plot.</span>
<span class="sd">        sub_opts : dict, optional</span>
<span class="sd">            Additional plotting options for :meth:`gncpy.plotting.init_plotting_opts`</span>
<span class="sd">            function. Values implemented here are `f_hndl`, and any values</span>
<span class="sd">            relating to title/axis text formatting. The default of None implies</span>
<span class="sd">            the default options are used for the sub plot.</span>
<span class="sd">        plot_subs : bool, optional</span>
<span class="sd">            Flag indicating if the component statistics (cardinality and</span>
<span class="sd">            localization) should also be plotted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        figs : dict</span>
<span class="sd">            Dictionary of matplotlib figure objects the data was plotted on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;OSPA must be calculated before plotting&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">main_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">main_opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sub_opts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">plot_subs</span><span class="p">:</span>
            <span class="n">sub_opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">()</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2"> OSPA2 (c = </span><span class="si">{:.1f}</span><span class="s2">, p = </span><span class="si">{:d}</span><span class="s2">, w=</span><span class="si">{:d}</span><span class="s2">)&quot;</span>
        <span class="n">ttl</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;win_len&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">y_lbl</span> <span class="o">=</span> <span class="s2">&quot;OSPA2&quot;</span>

        <span class="n">figs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">figs</span><span class="p">[</span><span class="s2">&quot;OSPA2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plt_ospa_hist</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span><span class="p">,</span> <span class="n">time_units</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">ttl</span><span class="p">,</span> <span class="n">y_lbl</span><span class="p">,</span> <span class="n">main_opts</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_subs</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2"> OSPA2 Components (c = </span><span class="si">{:.1f}</span><span class="s2">, p = </span><span class="si">{:d}</span><span class="s2">, w=</span><span class="si">{:d}</span><span class="s2">)&quot;</span>
            <span class="n">ttl</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;win_len&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">y_lbls</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Localiztion&quot;</span><span class="p">,</span> <span class="s2">&quot;Cardinality&quot;</span><span class="p">]</span>
            <span class="n">figs</span><span class="p">[</span><span class="s2">&quot;OSPA2_subs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plt_ospa_hist_subs</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span><span class="p">],</span>
                <span class="n">time_units</span><span class="p">,</span>
                <span class="n">time</span><span class="p">,</span>
                <span class="n">ttl</span><span class="p">,</span>
                <span class="n">y_lbls</span><span class="p">,</span>
                <span class="n">main_opts</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">figs</span></div>
</div>



<div class="viewcode-block" id="LabeledPoissonMultiBernoulliMixture">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.LabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.LabeledPoissonMultiBernoulliMixture">[docs]</a>
<span class="k">class</span> <span class="nc">LabeledPoissonMultiBernoulliMixture</span><span class="p">(</span><span class="n">PoissonMultiBernoulliMixture</span><span class="p">):</span>
<div class="viewcode-block" id="LabeledPoissonMultiBernoulliMixture.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.LabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.LabeledPoissonMultiBernoulliMixture.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read only list of extracted labels.</span>

<span class="sd">        This is a list with 1 element per timestep, and each element is a list</span>
<span class="sd">        of the best labels extracted at that timestep. The order of each</span>
<span class="sd">        element corresponds to the state order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span>

    <span class="k">def</span> <span class="nf">_correct_birth_tab_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">distrib</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">new_tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span>
        <span class="n">filt_states</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">covs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_filt_states</span><span class="p">(</span><span class="n">distrib</span><span class="p">)</span>

        <span class="n">new_f_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_s_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_c_hist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt_states</span><span class="p">)</span>
        <span class="n">depleted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">f_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">filt_states</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">weights</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">new_f_states</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_s_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_c_hist</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                    <span class="n">new_w</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">f_state</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ParticleDepletionError</span><span class="p">,</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ParticleEstimationDomainError</span><span class="p">,</span>
                <span class="n">gerr</span><span class="o">.</span><span class="n">ExtremeMeasurementNoiseError</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">filt_states</span> <span class="o">=</span> <span class="n">new_f_states</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">state_hist</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_s_hist</span><span class="p">]</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">cov_hist</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_c_hist</span><span class="p">]</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">distrib_weights_hist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">new_w</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">depleted</span><span class="p">:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">new_w</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span>
            <span class="p">)</span>
            <span class="n">new_tab</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="n">w</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">new_w</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">new_w</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">new_tab</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span>
                <span class="o">*</span> <span class="n">cost</span>
                <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_detection</span> <span class="o">*</span> <span class="n">cost</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">new_tab</span><span class="o">.</span><span class="n">time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span>
        <span class="k">return</span> <span class="n">new_tab</span><span class="p">,</span> <span class="n">cost</span>

    <span class="k">def</span> <span class="nf">_gen_cor_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">num_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="n">num_birth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">)</span>
        <span class="n">up_tab</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_meas</span> <span class="o">*</span> <span class="n">num_birth</span><span class="p">)</span>

        <span class="c1"># Missed Detection Updates</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">track</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>
            <span class="n">sum_non_exist_prob</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">1</span>
                <span class="o">-</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span>
                <span class="o">+</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span>
            <span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="n">w</span> <span class="o">*</span> <span class="n">sum_non_exist_prob</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span>
            <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sum_non_exist_prob</span><span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># left_cost_m = np.zeros()</span>
        <span class="c1"># all_cost_m = np.zeros((num_pred + num_birth * num_meas, num_meas))</span>
        <span class="n">all_cost_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_meas</span><span class="p">,</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_birth</span> <span class="o">*</span> <span class="n">num_meas</span><span class="p">))</span>

        <span class="c1"># Update for all existing tracks</span>
        <span class="k">for</span> <span class="n">emm</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
                <span class="n">s_to_ii</span> <span class="o">=</span> <span class="n">num_pred</span> <span class="o">*</span> <span class="n">emm</span> <span class="o">+</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">num_pred</span>
                <span class="p">(</span><span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">],</span> <span class="n">cost</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_track_tab_entry</span><span class="p">(</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">emm</span><span class="p">)</span>
                <span class="n">all_cost_m</span><span class="p">[</span><span class="n">emm</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>

        <span class="c1"># Update for all potential new births</span>
        <span class="k">for</span> <span class="n">emm</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">b_model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">):</span>
                <span class="n">s_to_ii</span> <span class="o">=</span> <span class="p">((</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span><span class="p">)</span> <span class="o">+</span> <span class="n">emm</span> <span class="o">*</span> <span class="n">num_birth</span> <span class="o">+</span> <span class="n">ii</span>
                <span class="p">(</span><span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">],</span> <span class="n">cost</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_birth_tab_entry</span><span class="p">(</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">b_model</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">emm</span><span class="p">)</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimal_places</span><span class="p">),</span> <span class="n">ii</span><span class="p">)</span>
                <span class="n">all_cost_m</span><span class="p">[</span><span class="n">emm</span><span class="p">,</span> <span class="n">emm</span> <span class="o">+</span> <span class="n">num_pred</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="k">return</span> <span class="n">up_tab</span><span class="p">,</span> <span class="n">all_cost_m</span>

    <span class="k">def</span> <span class="nf">_update_extract_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_cmp</span><span class="p">):</span>
        <span class="n">used_meas_inds</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span><span class="p">)]</span>
        <span class="n">used_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_extract_hists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">idx_cmp</span><span class="p">]</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">track</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">[</span><span class="n">trk_ind</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">trk_ind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">[</span><span class="n">idx_cmp</span><span class="p">]</span><span class="o">.</span><span class="n">track_set</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ExtractHistHelper</span><span class="p">()</span>
            <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="n">label</span>
            <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_ind_hist</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="n">time_index</span>
            <span class="p">(</span>
                <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">,</span>
                <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">covs</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_helper</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>

            <span class="n">used_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">track</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">t_inds_after_b</span><span class="p">,</span> <span class="n">meas_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_ind_hist</span>
            <span class="p">):</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="n">new_extract_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">+</span> <span class="n">t_inds_after_b</span>
                <span class="k">if</span> <span class="n">meas_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">meas_ind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_meas_inds</span><span class="p">[</span><span class="n">tt</span><span class="p">]:</span>
                    <span class="n">used_meas_inds</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meas_ind</span><span class="p">)</span>
        <span class="n">good_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">existing</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span><span class="p">):</span>
            <span class="n">used</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">used_labels</span>
            <span class="k">if</span> <span class="n">used</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">t_inds_after_b</span><span class="p">,</span> <span class="n">meas_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">existing</span><span class="o">.</span><span class="n">meas_ind_hist</span><span class="p">):</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">+</span> <span class="n">t_inds_after_b</span>
                <span class="n">used</span> <span class="o">=</span> <span class="n">meas_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">meas_ind</span> <span class="ow">in</span> <span class="n">used_meas_inds</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">:</span>
                <span class="n">good_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">good_inds</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_extract_hists</span><span class="p">)</span>

<div class="viewcode-block" id="LabeledPoissonMultiBernoulliMixture.extract_states">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.LabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.LabeledPoissonMultiBernoulliMixture.extract_states">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">calc_states</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts the best state estimates.</span>

<span class="sd">        This extracts the best states from the distribution. It should be</span>
<span class="sd">        called once per time step after the correction function. This calls</span>
<span class="sd">        both the inner filters predict and correct functions so the keyword</span>
<span class="sd">        arguments must contain any additional variables needed by those</span>
<span class="sd">        functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        update : bool, optional</span>
<span class="sd">            Flag indicating if the label history should be updated. This should</span>
<span class="sd">            be done once per timestep and can be disabled if calculating states</span>
<span class="sd">            after the final timestep. The default is True.</span>
<span class="sd">        calc_states : bool, optional</span>
<span class="sd">            Flag indicating if the states should be calculated based on the</span>
<span class="sd">            label history. This only needs to be done before the states are used.</span>
<span class="sd">            It can simply be called once after the end of the simulation. The</span>
<span class="sd">            default is true.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx_cmp : int</span>
<span class="sd">            Index of the hypothesis table used when extracting states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">card</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span><span class="p">)</span>
        <span class="n">tracks_per_hyp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">num_tracks</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">])</span>
        <span class="n">weight_per_hyp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index_cntr</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tracks_per_hyp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">idx_cmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">weight_per_hyp</span> <span class="o">*</span> <span class="p">(</span><span class="n">tracks_per_hyp</span> <span class="o">==</span> <span class="n">card</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_extract_hist</span><span class="p">(</span><span class="n">idx_cmp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">calc_states</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">existing</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extractable_hists</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t_inds_after_b</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="n">existing</span><span class="o">.</span><span class="n">states</span><span class="p">,</span> <span class="n">existing</span><span class="o">.</span><span class="n">covs</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">tt</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">b_time_index</span> <span class="o">+</span> <span class="n">t_inds_after_b</span>
                    <span class="c1"># if len(self._labels[tt]) == 0:</span>
                    <span class="c1">#     self._states[tt] = [s]</span>
                    <span class="c1">#     self._labels[tt] = [existing.label]</span>
                    <span class="c1">#     self._covs[tt] = [c]</span>
                    <span class="c1"># else:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">existing</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">update</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">calc_states</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Extracting states performed no actions&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx_cmp</span></div>


    <span class="k">def</span> <span class="nf">_ospa_setup_emat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">state_inds</span><span class="p">):</span>
        <span class="c1"># get sizes</span>
        <span class="n">num_timesteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="n">num_objs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lbl_to_ind</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lbl_to_ind</span><span class="p">:</span>
                    <span class="n">lbl_to_ind</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_objs</span>
                    <span class="n">num_objs</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># create matrices</span>
        <span class="n">est_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">num_objs</span><span class="p">))</span>
        <span class="n">est_cov_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">num_objs</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="p">(</span><span class="n">lbl_lst</span><span class="p">,</span> <span class="n">s_lst</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lbl_lst</span><span class="p">,</span> <span class="n">s_lst</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">obj_num</span> <span class="o">=</span> <span class="n">lbl_to_ind</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]</span>
                <span class="n">est_mat</span><span class="p">[:,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">obj_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">state_inds</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="p">(</span><span class="n">lbl_lst</span><span class="p">,</span> <span class="n">c_lst</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariances</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lbl_lst</span><span class="p">,</span> <span class="n">c_lst</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">est_cov_mat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">lbl_to_ind</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">state_inds</span><span class="p">][</span>
                        <span class="p">:,</span> <span class="n">state_inds</span>
                    <span class="p">]</span>
        <span class="k">return</span> <span class="n">est_mat</span><span class="p">,</span> <span class="n">est_cov_mat</span>

<div class="viewcode-block" id="LabeledPoissonMultiBernoulliMixture.calculate_ospa2">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.LabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.LabeledPoissonMultiBernoulliMixture.calculate_ospa2">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_ospa2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">truth</span><span class="p">,</span>
        <span class="n">c</span><span class="p">,</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">win_len</span><span class="p">,</span>
        <span class="n">true_covs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">core_method</span><span class="o">=</span><span class="n">SingleObjectDistance</span><span class="o">.</span><span class="n">MANHATTAN</span><span class="p">,</span>
        <span class="n">state_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the OSPA(2) distance between the truth at all timesteps.</span>

<span class="sd">        Wrapper for :func:`serums.distances.calculate_ospa2`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        truth : list</span>
<span class="sd">            Each element represents a timestep and is a list of N x 1 numpy array,</span>
<span class="sd">            one per true agent in the swarm.</span>
<span class="sd">        c : float</span>
<span class="sd">            Distance cutoff for considering a point properly assigned. This</span>
<span class="sd">            influences how cardinality errors are penalized. For :math:`p = 1`</span>
<span class="sd">            it is the penalty given false point estimate.</span>
<span class="sd">        p : int</span>
<span class="sd">            The power of the distance term. Higher values penalize outliers</span>
<span class="sd">            more.</span>
<span class="sd">        win_len : int</span>
<span class="sd">            Number of samples to include in window.</span>
<span class="sd">        core_method : :class:`serums.enums.SingleObjectDistance`, Optional</span>
<span class="sd">            The main distance measure to use for the localization component.</span>
<span class="sd">            The default value is :attr:`.SingleObjectDistance.MANHATTAN`.</span>
<span class="sd">        true_covs : list, Optional</span>
<span class="sd">            Each element represents a timestep and is a list of N x N numpy arrays</span>
<span class="sd">            corresonponding to the uncertainty about the true states. Note the</span>
<span class="sd">            order must be consistent with the truth data given. This is only</span>
<span class="sd">            needed for core methods :attr:`SingleObjectDistance.HELLINGER`. The defautl</span>
<span class="sd">            value is None.</span>
<span class="sd">        state_inds : list, optional</span>
<span class="sd">            Indices in the state vector to use, will be applied to the truth</span>
<span class="sd">            data as well. The default is None which means the full state is</span>
<span class="sd">            used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># error checking on optional input arguments</span>
        <span class="n">core_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_input_check</span><span class="p">(</span><span class="n">core_method</span><span class="p">,</span> <span class="n">truth</span><span class="p">,</span> <span class="n">true_covs</span><span class="p">)</span>

        <span class="c1"># setup data structures</span>
        <span class="k">if</span> <span class="n">state_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_find_s_dim</span><span class="p">(</span><span class="n">truth</span><span class="p">)</span>
            <span class="n">state_inds</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">state_dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">state_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_inds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Failed to get state dimension. SKIPPING OSPA(2) calculation&quot;</span><span class="p">)</span>

            <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;win_len&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">win_len</span>
            <span class="k">return</span>
        <span class="n">true_mat</span><span class="p">,</span> <span class="n">true_cov_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_setup_tmat</span><span class="p">(</span>
            <span class="n">truth</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">true_covs</span><span class="p">,</span> <span class="n">state_inds</span>
        <span class="p">)</span>
        <span class="n">est_mat</span><span class="p">,</span> <span class="n">est_cov_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ospa_setup_emat</span><span class="p">(</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">state_inds</span><span class="p">)</span>

        <span class="c1"># find OSPA</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_localization</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ospa2_cardinality</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ospa2_params</span><span class="p">[</span><span class="s2">&quot;win_len&quot;</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">calculate_ospa2</span><span class="p">(</span>
            <span class="n">est_mat</span><span class="p">,</span>
            <span class="n">true_mat</span><span class="p">,</span>
            <span class="n">c</span><span class="p">,</span>
            <span class="n">p</span><span class="p">,</span>
            <span class="n">win_len</span><span class="p">,</span>
            <span class="n">core_method</span><span class="o">=</span><span class="n">core_method</span><span class="p">,</span>
            <span class="n">true_cov_mat</span><span class="o">=</span><span class="n">true_cov_mat</span><span class="p">,</span>
            <span class="n">est_cov_mat</span><span class="o">=</span><span class="n">est_cov_mat</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="LabeledPoissonMultiBernoulliMixture.plot_states_labels">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.LabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.LabeledPoissonMultiBernoulliMixture.plot_states_labels">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_states_labels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">plt_inds</span><span class="p">,</span>
        <span class="n">ttl</span><span class="o">=</span><span class="s2">&quot;Labeled State Trajectories&quot;</span><span class="p">,</span>
        <span class="n">x_lbl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_lbl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">meas_tx_fnc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the best estimate for the states and labels.</span>

<span class="sd">        This assumes that the states have been extracted. It&#39;s designed to plot</span>
<span class="sd">        two of the state variables (typically x/y position). The error ellipses</span>
<span class="sd">        are calculated according to :cite:`Hoover1984_AlgorithmsforConfidenceCirclesandEllipses`</span>

<span class="sd">        Keywrod arguments are processed with</span>
<span class="sd">        :meth:`gncpy.plotting.init_plotting_opts`. This function</span>
<span class="sd">        implements</span>

<span class="sd">            - f_hndl</span>
<span class="sd">            - true_states</span>
<span class="sd">            - sig_bnd</span>
<span class="sd">            - rng</span>
<span class="sd">            - meas_inds</span>
<span class="sd">            - lgnd_loc</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plt_inds : list</span>
<span class="sd">            List of indices in the state vector to plot</span>
<span class="sd">        ttl : string, optional</span>
<span class="sd">            Title of the plot.</span>
<span class="sd">        x_lbl : string, optional</span>
<span class="sd">            X-axis label for the plot.</span>
<span class="sd">        y_lbl : string, optional</span>
<span class="sd">            Y-axis label for the plot.</span>
<span class="sd">        meas_tx_fnc : callable, optional</span>
<span class="sd">            Takes in the measurement vector as an Nm x 1 numpy array and</span>
<span class="sd">            returns a numpy array representing the states to plot (size 2). The</span>
<span class="sd">            default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Matplotlib figure</span>
<span class="sd">            Instance of the matplotlib figure used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">init_plotting_opts</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;f_hndl&quot;</span><span class="p">]</span>
        <span class="n">true_states</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;true_states&quot;</span><span class="p">]</span>
        <span class="n">sig_bnd</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;sig_bnd&quot;</span><span class="p">]</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;rng&quot;</span><span class="p">]</span>
        <span class="n">meas_inds</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;meas_inds&quot;</span><span class="p">]</span>
        <span class="n">lgnd_loc</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;lgnd_loc&quot;</span><span class="p">]</span>
        <span class="n">mrkr</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;marker&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_lbl</span> <span class="o">=</span> <span class="s2">&quot;x-position&quot;</span>
        <span class="k">if</span> <span class="n">y_lbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_lbl</span> <span class="o">=</span> <span class="s2">&quot;y-position&quot;</span>
        <span class="n">meas_specs_given</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">meas_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas_inds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="n">meas_tx_fnc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">plt_meas</span> <span class="o">=</span> <span class="n">meas_specs_given</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span>
        <span class="n">show_sig</span> <span class="o">=</span> <span class="n">sig_bnd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span>

        <span class="n">s_lst</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="n">l_lst</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">x_dim</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">f_hndl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f_hndl</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># get state dimension</span>
        <span class="k">for</span> <span class="n">states</span> <span class="ow">in</span> <span class="n">s_lst</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x_dim</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                <span class="k">break</span>
        <span class="c1"># get unique labels</span>
        <span class="n">u_lbls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lbls</span> <span class="ow">in</span> <span class="n">l_lst</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lbls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">lbls</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">u_lbls</span><span class="p">:</span>
                    <span class="n">u_lbls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u_lbls</span><span class="p">))</span>

        <span class="c1"># get array of all state values for each label</span>
        <span class="n">added_sig_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_true_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_state_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">added_meas_lbl</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">c_idx</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">u_lbls</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x_dim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_lst</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">show_sig</span><span class="p">:</span>
                <span class="n">sigs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_lst</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">lbls</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l_lst</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lbls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">lbls</span><span class="p">:</span>
                    <span class="n">ii</span> <span class="o">=</span> <span class="n">lbls</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">s_lst</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">[:,</span> <span class="p">[</span><span class="n">tt</span><span class="p">]]</span> <span class="o">=</span> <span class="n">s_lst</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">show_sig</span><span class="p">:</span>
                        <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                            <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                            <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                            <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covs</span><span class="p">[</span><span class="n">tt</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">sig</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">sigs</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span>
            <span class="c1"># plot</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">c_idx</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">show_sig</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">sig</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sigs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">pltUtil</span><span class="o">.</span><span class="n">calc_error_ellipse</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig_bnd</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">added_sig_lbl</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$</span><span class="si">{}</span><span class="s2">\sigma$ Error Ellipses&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sig_bnd</span><span class="p">)</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">Ellipse</span><span class="p">(</span>
                            <span class="n">xy</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">,</span> <span class="n">tt</span><span class="p">],</span>
                            <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                            <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                            <span class="n">angle</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                            <span class="n">zorder</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span>
                            <span class="n">label</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">added_sig_lbl</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">Ellipse</span><span class="p">(</span>
                            <span class="n">xy</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">,</span> <span class="n">tt</span><span class="p">],</span>
                            <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                            <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                            <span class="n">angle</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                            <span class="n">zorder</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">set_clip_box</span><span class="p">(</span><span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="n">color</span><span class="p">,</span>
                <span class="s2">&quot;markeredgecolor&quot;</span><span class="p">:</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
                <span class="s2">&quot;marker&quot;</span><span class="p">:</span> <span class="n">mrkr</span><span class="p">,</span>
                <span class="s2">&quot;ls&quot;</span><span class="p">:</span> <span class="s2">&quot;--&quot;</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">added_state_lbl</span><span class="p">:</span>
                <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;States&quot;</span>
                <span class="c1"># f_hndl.axes[0].scatter(x[plt_inds[0], :], x[plt_inds[1], :],</span>
                <span class="c1">#                        color=color, edgecolors=&#39;k&#39;,</span>
                <span class="c1">#                        label=&#39;States&#39;)</span>
                <span class="n">added_state_lbl</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># else:</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:],</span> <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span> <span class="o">**</span><span class="n">settings</span><span class="p">)</span>

            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lbl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
            <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
                <span class="n">tmp</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span>
            <span class="p">)</span>
        <span class="c1"># if true states are available then plot them</span>
        <span class="k">if</span> <span class="n">true_states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">true_states</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">x_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">states</span> <span class="ow">in</span> <span class="n">true_states</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x_dim</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                        <span class="k">break</span>
            <span class="n">max_true</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">true_states</span><span class="p">])</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x_dim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_states</span><span class="p">),</span> <span class="n">max_true</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">states</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">true_states</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">states</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">[:,</span> <span class="p">[</span><span class="n">tt</span><span class="p">],</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_true</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">added_true_lbl</span><span class="p">:</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;True Trajectories&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">added_true_lbl</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">plt_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">if</span> <span class="n">plt_meas</span><span class="p">:</span>
            <span class="n">meas_x</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">meas_y</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">meas_tt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">meas_tx_fnc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tx_meas</span> <span class="o">=</span> <span class="p">[</span><span class="n">meas_tx_fnc</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meas_tt</span><span class="p">]</span>
                    <span class="n">mx_ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">tm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">tm</span> <span class="ow">in</span> <span class="n">tx_meas</span><span class="p">]</span>
                    <span class="n">my_ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">tm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">tm</span> <span class="ow">in</span> <span class="n">tx_meas</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mx_ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">meas_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meas_tt</span><span class="p">]</span>
                    <span class="n">my_ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">meas_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meas_tt</span><span class="p">]</span>
                <span class="n">meas_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">mx_ii</span><span class="p">)</span>
                <span class="n">meas_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">my_ii</span><span class="p">)</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span> <span class="o">/</span> <span class="mi">255</span><span class="p">)</span>
            <span class="n">meas_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">meas_x</span><span class="p">)</span>
            <span class="n">meas_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">meas_y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">meas_x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">added_meas_lbl</span><span class="p">:</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                        <span class="n">meas_x</span><span class="p">,</span>
                        <span class="n">meas_y</span><span class="p">,</span>
                        <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Measurements&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                        <span class="n">meas_x</span><span class="p">,</span> <span class="n">meas_y</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;^&quot;</span>
                    <span class="p">)</span>
        <span class="n">f_hndl</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pltUtil</span><span class="o">.</span><span class="n">set_title_label</span><span class="p">(</span>
            <span class="n">f_hndl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">ttl</span><span class="o">=</span><span class="n">ttl</span><span class="p">,</span> <span class="n">x_lbl</span><span class="o">=</span><span class="s2">&quot;x-position&quot;</span><span class="p">,</span> <span class="n">y_lbl</span><span class="o">=</span><span class="s2">&quot;y-position&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">lgnd_loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">lgnd_loc</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">f_hndl</span></div>
</div>



<span class="k">class</span> <span class="nc">_STMPMBMBase</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_filt_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distrib</span><span class="p">):</span>
        <span class="n">filt_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">]</span>
        <span class="n">covs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">distrib</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="n">distrib</span><span class="o">.</span><span class="n">dof</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">scalings</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">filt_states</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
                <span class="c1"># no need to copy because cov is already a new object for the student&#39;s t-fitler</span>
                <span class="n">covs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span>
        <span class="k">return</span> <span class="n">filt_states</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">covs</span>

    <span class="k">def</span> <span class="nf">_gate_meas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO: check this implementation</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">scalings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">:</span>
            <span class="n">scalings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">probDensity</span><span class="o">.</span><span class="n">scalings</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">scalings</span><span class="p">):</span>
            <span class="n">meas_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">get_meas_mat</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">get_est_meas</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">meas_noise_dof</span>
                <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">dof</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">meas_noise_dof</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">P_zz</span> <span class="o">=</span> <span class="n">meas_mat</span> <span class="o">@</span> <span class="n">p</span> <span class="o">@</span> <span class="n">meas_mat</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">meas_noise</span>
            <span class="n">inv_P</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">P_zz</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">valid</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">innov</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">est</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">innov</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">inv_P</span> <span class="o">@</span> <span class="n">innov</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_chi2_gate</span><span class="p">:</span>
                    <span class="n">valid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="n">valid</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">meas</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">valid</span><span class="p">]</span>


<div class="viewcode-block" id="STMPoissonMultiBernoulliMixture">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.STMPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.STMPoissonMultiBernoulliMixture">[docs]</a>
<span class="k">class</span> <span class="nc">STMPoissonMultiBernoulliMixture</span><span class="p">(</span><span class="n">_STMPMBMBase</span><span class="p">,</span> <span class="n">PoissonMultiBernoulliMixture</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of a STM-PMBM filter.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="STMPoissonMultiBernoulliMixture.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.STMPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.STMPoissonMultiBernoulliMixture.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="STMLabeledPoissonMultiBernoulliMixture">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.STMLabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.STMLabeledPoissonMultiBernoulliMixture">[docs]</a>
<span class="k">class</span> <span class="nc">STMLabeledPoissonMultiBernoulliMixture</span><span class="p">(</span>
    <span class="n">_STMPMBMBase</span><span class="p">,</span> <span class="n">LabeledPoissonMultiBernoulliMixture</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of a STM-LPMBM filter.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="STMLabeledPoissonMultiBernoulliMixture.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.STMLabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.STMLabeledPoissonMultiBernoulliMixture.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<span class="k">class</span> <span class="nc">_SMCPMBMBase</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">compute_prob_detection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compute_prob_survive</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_prob_detection</span> <span class="o">=</span> <span class="n">compute_prob_detection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_prob_survive</span> <span class="o">=</span> <span class="n">compute_prob_survive</span>

        <span class="c1"># for wrappers for predict/correct function to handle extra args for private functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prob_surv_args</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prob_det_args</span> <span class="o">=</span> <span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_filt_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distrib</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">init_from_dist</span><span class="p">(</span><span class="n">distrib</span><span class="p">,</span> <span class="n">make_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">filt_states</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">(),</span>
        <span class="p">]</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">distrib</span><span class="o">.</span><span class="n">mean</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">distrib</span><span class="o">.</span><span class="n">covariance</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mi">1</span><span class="p">,</span>
        <span class="p">]</span>  <span class="c1"># not needed so set to 1</span>

        <span class="k">return</span> <span class="n">filt_states</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">covs</span>

    <span class="k">def</span> <span class="nf">_calc_avg_prob_surv_death</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">avg_prob_survive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">tabidx</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="c1"># TODO: fix hack so not using &quot;private&quot; variable outside class</span>
            <span class="n">p_surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_prob_survive</span><span class="p">(</span>
                <span class="n">ent</span><span class="o">.</span><span class="n">filt_states</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;_particleDist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_prob_surv_args</span>
            <span class="p">)</span>
            <span class="n">avg_prob_survive</span><span class="p">[</span><span class="n">tabidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">filt_states</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;_particleDist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_surv</span>
            <span class="p">)</span>
        <span class="n">avg_prob_death</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">avg_prob_survive</span>

        <span class="k">return</span> <span class="n">avg_prob_survive</span><span class="p">,</span> <span class="n">avg_prob_death</span>

    <span class="k">def</span> <span class="nf">_inner_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">num_particles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>

            <span class="c1"># manually update weights to account for prob survive</span>
            <span class="c1"># TODO: fix hack so not using &quot;private&quot; variable outside class</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_prob_survive</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_prob_surv_args</span>
            <span class="p">)</span>
            <span class="n">new_weights</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">w</span> <span class="o">*</span> <span class="n">ps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">tot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">new_weights</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tot</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">w_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_weights</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">/</span> <span class="n">tot</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">new_weights</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">update_weights</span><span class="p">(</span><span class="n">w_lst</span><span class="p">)</span>

            <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
                <span class="n">new_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
            <span class="n">new_s</span> <span class="o">=</span> <span class="n">state</span>
            <span class="n">new_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span>
        <span class="k">return</span> <span class="n">new_f_state</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">new_cov</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">prob_surv_args</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prediction step of the SMC-GLMB filter.</span>

<span class="sd">        This is a wrapper for the parent class to allow for extra parameters.</span>
<span class="sd">        See :meth:`.tracker.GeneralizedLabeledMultiBernoulli.predict` for</span>
<span class="sd">        additional details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep : float</span>
<span class="sd">            Current timestep.</span>
<span class="sd">        prob_surv_args : tuple, optional</span>
<span class="sd">            Additional arguments for the `compute_prob_survive` function.</span>
<span class="sd">            The default is ().</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            See :meth:`.tracker.GeneralizedLabeledMultiBernoulli.predict`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prob_surv_args</span> <span class="o">=</span> <span class="n">prob_surv_args</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_avg_prob_det_mdet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cor_tab</span><span class="p">):</span>
        <span class="n">avg_prob_detect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cor_tab</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">tabidx</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cor_tab</span><span class="p">):</span>
            <span class="c1"># TODO: fix hack so not using &quot;private&quot; variable outside class</span>
            <span class="n">p_detect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_prob_detection</span><span class="p">(</span>
                <span class="n">ent</span><span class="o">.</span><span class="n">filt_states</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;_particleDist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_prob_det_args</span>
            <span class="p">)</span>
            <span class="n">avg_prob_detect</span><span class="p">[</span><span class="n">tabidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">filt_states</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;_particleDist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_detect</span>
            <span class="p">)</span>
        <span class="n">avg_prob_miss_detect</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">avg_prob_detect</span>

        <span class="k">return</span> <span class="n">avg_prob_detect</span><span class="p">,</span> <span class="n">avg_prob_miss_detect</span>

    <span class="k">def</span> <span class="nf">_inner_correct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">,</span> <span class="n">distrib_weight</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">num_particles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cor_state</span><span class="p">,</span> <span class="n">likely</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># manually update the particle weights to account for probability of detection</span>
            <span class="c1"># TODO: fix hack so not using &quot;private&quot; variable outside class</span>
            <span class="n">pd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_prob_detection</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_prob_det_args</span>
            <span class="p">)</span>
            <span class="n">pd_weight</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">pd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">_particleDist</span><span class="o">.</span><span class="n">update_weights</span><span class="p">(</span>
                <span class="p">(</span><span class="n">pd_weight</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pd_weight</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="c1"># determine the partial cost, the remainder is calculated later from</span>
            <span class="c1"># the hypothesis</span>
            <span class="n">new_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">likely</span> <span class="o">*</span> <span class="n">pd_weight</span><span class="p">)</span>  <span class="c1"># same as cost in this case</span>

            <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
            <span class="n">new_s</span> <span class="o">=</span> <span class="n">cor_state</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
                <span class="n">new_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
            <span class="n">new_s</span> <span class="o">=</span> <span class="n">state</span>
            <span class="n">new_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span>
            <span class="n">new_w</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">new_f_state</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">new_c</span><span class="p">,</span> <span class="n">new_w</span>

    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">prob_det_args</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correction step of the SMC-GLMB filter.</span>

<span class="sd">        This is a wrapper for the parent class to allow for extra parameters.</span>
<span class="sd">        See :meth:`.tracker.GeneralizedLabeledMultiBernoulli.correct` for</span>
<span class="sd">        additional details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep : float</span>
<span class="sd">            Current timestep.</span>
<span class="sd">        prob_det_args : tuple, optional</span>
<span class="sd">            Additional arguments for the `compute_prob_detection` function.</span>
<span class="sd">            The default is ().</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            See :meth:`.tracker.GeneralizedLabeledMultiBernoulli.correct`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prob_det_args</span> <span class="o">=</span> <span class="n">prob_det_args</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extract_most_prob_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts themost probable states.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Implement this function for the SMC-GLMB filter</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeWarning</span>
<span class="sd">            Function must be implemented.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Not implemented for this class&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="SMCPoissonMultiBernoulliMixture">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.SMCPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.SMCPoissonMultiBernoulliMixture">[docs]</a>
<span class="k">class</span> <span class="nc">SMCPoissonMultiBernoulliMixture</span><span class="p">(</span><span class="n">_SMCPMBMBase</span><span class="p">,</span> <span class="n">PoissonMultiBernoulliMixture</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of a Sequential Monte Carlo PMBM filter.</span>

<span class="sd">    This filter does not account for agents spawned from existing tracks, only agents</span>
<span class="sd">    birthed from the given birth model.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    compute_prob_detection : callable</span>
<span class="sd">        Function that takes a list of particles as the first argument and `*args`</span>
<span class="sd">        as the next. Returns the probability of detection for each particle as a list.</span>
<span class="sd">    compute_prob_survive : callable</span>
<span class="sd">        Function that takes a list of particles as the first argument and `*args` as</span>
<span class="sd">        the next. Returns the average probability of survival for each particle as a list.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SMCPoissonMultiBernoulliMixture.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.SMCPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.SMCPoissonMultiBernoulliMixture.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SMCLabeledPoissonMultiBernoulliMixture">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.SMCLabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.SMCLabeledPoissonMultiBernoulliMixture">[docs]</a>
<span class="k">class</span> <span class="nc">SMCLabeledPoissonMultiBernoulliMixture</span><span class="p">(</span>
    <span class="n">_SMCPMBMBase</span><span class="p">,</span> <span class="n">LabeledPoissonMultiBernoulliMixture</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of a Sequential Monte Carlo LPMBM filter.</span>

<span class="sd">    This filter does not account for agents spawned from existing tracks, only agents</span>
<span class="sd">    birthed from the given birth model.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    compute_prob_detection : callable</span>
<span class="sd">        Function that takes a list of particles as the first argument and `*args`</span>
<span class="sd">        as the next. Returns the probability of detection for each particle as a list.</span>
<span class="sd">    compute_prob_survive : callable</span>
<span class="sd">        Function that takes a list of particles as the first argument and `*args` as</span>
<span class="sd">        the next. Returns the average probability of survival for each particle as a list.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SMCLabeledPoissonMultiBernoulliMixture.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.SMCLabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.SMCLabeledPoissonMultiBernoulliMixture.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<span class="k">class</span> <span class="nc">_IMMPMBMBase</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_init_filt_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distrib</span><span class="p">):</span>
        <span class="n">filt_states</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">distrib</span><span class="o">.</span><span class="n">covariances</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">distrib</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">distrib</span><span class="o">.</span><span class="n">covariances</span><span class="p">)):</span>
            <span class="c1"># if len(m) != 1 or len(cov) != 1:</span>
            <span class="c1">#     raise ValueError(&quot;Only one mean can be passed to IMM filters for initialization&quot;)</span>
            <span class="n">m_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">c_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">in_filt_list</span><span class="p">)):</span>
                <span class="n">m_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">c_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">initialize_states</span><span class="p">(</span><span class="n">m_list</span><span class="p">,</span> <span class="n">c_list</span><span class="p">)</span>
            <span class="n">filt_states</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseFilter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">filt_states</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">covs</span>

    <span class="k">def</span> <span class="nf">_inner_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="n">new_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>
        <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">new_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">new_f_state</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">new_cov</span>

    <span class="k">def</span> <span class="nf">_inner_correct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">filt_state</span><span class="p">,</span> <span class="n">distrib_weight</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">filt_args</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">load_filter_state</span><span class="p">(</span><span class="n">filt_state</span><span class="p">)</span>
        <span class="n">cor_state</span><span class="p">,</span> <span class="n">likely</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="o">**</span><span class="n">filt_args</span><span class="p">)</span>
        <span class="n">new_f_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">save_filter_state</span><span class="p">()</span>
        <span class="n">new_s</span> <span class="o">=</span> <span class="n">cor_state</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covs</span><span class="p">:</span>
            <span class="n">new_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="n">distrib_weight</span> <span class="o">*</span> <span class="n">likely</span>

        <span class="k">return</span> <span class="n">new_f_state</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">new_c</span><span class="p">,</span> <span class="n">new_w</span>


<div class="viewcode-block" id="IMMPoissonMultiBernoulliMixture">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.IMMPoissonMultiBernoulliMixture">[docs]</a>
<span class="k">class</span> <span class="nc">IMMPoissonMultiBernoulliMixture</span><span class="p">(</span><span class="n">_IMMPMBMBase</span><span class="p">,</span> <span class="n">PoissonMultiBernoulliMixture</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An implementation of the IMM-PMBM algorithm.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="IMMPoissonMultiBernoulliMixture.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.IMMPoissonMultiBernoulliMixture.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="IMMLabeledPoissonMultiBernoulliMixture">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMLabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.IMMLabeledPoissonMultiBernoulliMixture">[docs]</a>
<span class="k">class</span> <span class="nc">IMMLabeledPoissonMultiBernoulliMixture</span><span class="p">(</span>
    <span class="n">_IMMPMBMBase</span><span class="p">,</span> <span class="n">LabeledPoissonMultiBernoulliMixture</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An implementation of the IMM-LPMBM algorithm.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="IMMLabeledPoissonMultiBernoulliMixture.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.IMMLabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.IMMLabeledPoissonMultiBernoulliMixture.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="MSPoissonMultiBernoulliMixture">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.MSPoissonMultiBernoulliMixture">[docs]</a>
<span class="k">class</span> <span class="nc">MSPoissonMultiBernoulliMixture</span><span class="p">(</span><span class="n">PoissonMultiBernoulliMixture</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An Implementation of the Multiple Sensor PMBM Filter.&quot;&quot;&quot;</span>

    <span class="c1"># Need measurement association history to incorporate meas inds from each sensor</span>
<div class="viewcode-block" id="MSPoissonMultiBernoulliMixture.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.MSPoissonMultiBernoulliMixture.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="n">selfself</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_gen_cor_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">comb_inds</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">num_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="n">num_birth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">)</span>
        <span class="n">up_tab</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_meas</span> <span class="o">*</span> <span class="n">num_birth</span><span class="p">)</span>

        <span class="c1"># Missed Detection Updates</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">track</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>
            <span class="n">sum_non_exist_prob</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">1</span>
                <span class="o">-</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span>
                <span class="o">+</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span>
            <span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="n">w</span> <span class="o">*</span> <span class="n">sum_non_exist_prob</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span>
            <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sum_non_exist_prob</span><span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># left_cost_m = np.zeros()</span>
        <span class="c1"># all_cost_m = np.zeros((num_pred + num_birth * num_meas, num_meas))</span>
        <span class="n">all_cost_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_meas</span><span class="p">,</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_birth</span> <span class="o">*</span> <span class="n">num_meas</span><span class="p">))</span>

        <span class="c1"># Update for all existing tracks</span>
        <span class="k">for</span> <span class="n">emm</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
                <span class="n">s_to_ii</span> <span class="o">=</span> <span class="n">num_pred</span> <span class="o">*</span> <span class="n">emm</span> <span class="o">+</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">num_pred</span>
                <span class="p">(</span><span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">],</span> <span class="n">cost</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_track_tab_entry</span><span class="p">(</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comb_inds</span><span class="p">[</span><span class="n">emm</span><span class="p">])</span>
                <span class="n">all_cost_m</span><span class="p">[</span><span class="n">emm</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>

        <span class="c1"># Update for all potential new births</span>
        <span class="k">for</span> <span class="n">emm</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">b_model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">):</span>
                <span class="n">s_to_ii</span> <span class="o">=</span> <span class="p">((</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span><span class="p">)</span> <span class="o">+</span> <span class="n">emm</span> <span class="o">*</span> <span class="n">num_birth</span> <span class="o">+</span> <span class="n">ii</span>
                <span class="p">(</span><span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">],</span> <span class="n">cost</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_birth_tab_entry</span><span class="p">(</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">b_model</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comb_inds</span><span class="p">[</span><span class="n">emm</span><span class="p">])</span>
                <span class="n">all_cost_m</span><span class="p">[</span><span class="n">emm</span><span class="p">,</span> <span class="n">emm</span> <span class="o">+</span> <span class="n">num_pred</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="k">return</span> <span class="n">up_tab</span><span class="p">,</span> <span class="n">all_cost_m</span>

    <span class="k">def</span> <span class="nf">_gen_cor_hyps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_meas</span><span class="p">,</span>
        <span class="n">avg_prob_detect</span><span class="p">,</span>
        <span class="n">avg_prob_miss_detect</span><span class="p">,</span>
        <span class="n">all_cost_m</span><span class="p">,</span>
        <span class="n">meas_combs</span><span class="p">,</span>
        <span class="n">cor_tab</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">num_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="n">up_hyps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">meas_combs</span><span class="p">:</span>
            <span class="n">meas_combs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">all_cost_m</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># n_obj_for_tracks =</span>
        <span class="k">if</span> <span class="n">num_meas</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
                <span class="n">pmd_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">avg_prob_miss_detect</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">+</span> <span class="n">pmd_log</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                <span class="n">up_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hyp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clutter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span>
            <span class="n">ss_w</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">p_hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
                <span class="n">ss_w</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p_hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ind_lst</span> <span class="ow">in</span> <span class="n">meas_combs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas_combs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">num_tracks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># all clutter</span>
                            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_pred</span><span class="p">,</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_meas</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">inds</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span>
                                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_pred</span><span class="p">,</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_meas</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                            <span class="p">)</span>
                        <span class="n">cost_m</span> <span class="o">=</span> <span class="n">all_cost_m</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">num_tracks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># all clutter</span>
                            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_pred</span><span class="p">,</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_lst</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">inds</span> <span class="o">=</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">num_pred</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ind_lst</span><span class="p">]</span>
                        <span class="n">tcm</span> <span class="o">=</span> <span class="n">all_cost_m</span><span class="p">[</span>
                            <span class="p">:,</span> <span class="n">inds</span>
                        <span class="p">]</span>  <span class="c1"># error is certainly caused here. I&#39;m going to bed now because it&#39;s past 11.</span>
                        <span class="n">cost_m</span> <span class="o">=</span> <span class="n">tcm</span><span class="p">[</span><span class="n">ind_lst</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">max_row_inds</span><span class="p">,</span> <span class="n">max_col_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cost_m</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">max_row_inds</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">cost_m</span><span class="p">[</span><span class="n">max_row_inds</span><span class="p">,</span> <span class="n">max_col_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
                    <span class="n">min_row_inds</span><span class="p">,</span> <span class="n">min_col_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cost_m</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">min_row_inds</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">cost_m</span><span class="p">[</span><span class="n">min_row_inds</span><span class="p">,</span> <span class="n">min_col_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>  <span class="c1"># 1</span>
                    <span class="n">neg_log</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cost_m</span><span class="p">)</span>

                    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">req_upd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span> <span class="o">/</span> <span class="n">ss_w</span><span class="p">)</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

                    <span class="p">[</span><span class="n">assigns</span><span class="p">,</span> <span class="n">costs</span><span class="p">]</span> <span class="o">=</span> <span class="n">murty_m_best_all_meas_assigned</span><span class="p">(</span><span class="n">neg_log</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

                    <span class="n">pmd_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">avg_prob_miss_detect</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">assigns</span><span class="p">,</span> <span class="n">costs</span><span class="p">):</span>
                        <span class="n">new_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
                        <span class="n">new_hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span>
                            <span class="o">+</span> <span class="n">num_meas</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clutter</span><span class="p">)</span>
                            <span class="o">+</span> <span class="n">pmd_log</span>
                            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                            <span class="o">-</span> <span class="n">c</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">num_tracks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">new_track_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">num_pred</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">num_pred</span> <span class="o">*</span> <span class="n">num_meas</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># track_inds = np.argwhere(a==1)</span>
                            <span class="n">new_track_list</span> <span class="o">=</span> <span class="p">[]</span>

                            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ms</span><span class="p">:</span>
                                    <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="p">(</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">[(</span><span class="n">ms</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                                    <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">num_pred</span> <span class="o">*</span> <span class="n">ms</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_pred</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                                    <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">num_pred</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ms</span> <span class="o">-</span> <span class="n">num_meas</span><span class="p">)</span>
                                    <span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="p">(</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span>
                                        <span class="o">-</span> <span class="p">(</span><span class="n">ms</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                                    <span class="p">)</span>
                            <span class="c1"># if len(a) == len(p_hyp.track_set):</span>
                            <span class="c1">#     for ii, (ms, t) in enumerate(zip(a, p_hyp.track_set)):</span>
                            <span class="c1">#         if len(p_hyp.track_set) &gt;= ms:</span>
                            <span class="c1">#             # new_track_list.append(((np.array(t)) * ms + num_pred))</span>
                            <span class="c1">#             new_track_list.append(</span>
                            <span class="c1">#                 (num_pred * (ind_lst[ii] + 1) + np.array(t))</span>
                            <span class="c1">#             )</span>
                            <span class="c1">#             # new_track_list.append((num_pred * ms + np.array(t)))</span>
                            <span class="c1">#         else:</span>
                            <span class="c1">#             # new_track_list.append(num_pred * ms - ind_lst[ii] * (num_pred - 1))</span>
                            <span class="c1">#             new_track_list.append(</span>
                            <span class="c1">#                 num_pred * (ind_lst[ii] + 1)</span>
                            <span class="c1">#                 - ii * (num_pred - 1)</span>
                            <span class="c1">#             )</span>
                            <span class="c1"># elif len(p_hyp.track_set) &lt; len(a):</span>
                            <span class="c1">#     for ii, ms in enumerate(a):</span>
                            <span class="c1">#         if len(p_hyp.track_set) &gt;= ms:</span>
                            <span class="c1">#             new_track_list.append(</span>
                            <span class="c1">#                 (1 + ind_lst[ii]) * num_pred</span>
                            <span class="c1">#                 + p_hyp.track_set[(ms - 1)]</span>
                            <span class="c1">#             )</span>
                            <span class="c1">#         elif len(p_hyp.track_set) &lt; ms:</span>
                            <span class="c1">#             new_track_list.append(</span>
                            <span class="c1">#                 num_pred * (num_meas + 1) + (ind_lst[ii])</span>
                            <span class="c1">#             )</span>
                            <span class="c1"># elif len(p_hyp.track_set) &gt; len(a):</span>
                            <span class="c1">#     # May need to modify this</span>
                            <span class="c1">#     for ii, ms in enumerate(a):</span>
                            <span class="c1">#         if len(p_hyp.track_set) &gt;= ms:</span>
                            <span class="c1">#             new_track_list.append(</span>
                            <span class="c1">#                 ms * num_pred + p_hyp.track_set[(ms - 1)]</span>
                            <span class="c1">#             )</span>
                            <span class="c1">#         elif len(p_hyp.track_set) &lt; ms:</span>
                            <span class="c1">#             new_track_list.append(</span>
                            <span class="c1">#                 num_pred * (num_meas + 1) + (ms - num_meas)</span>
                            <span class="c1">#             )</span>

                            <span class="c1"># new_track_list = list(np.array(p_hyp.track_set) + num_pred + num_pred * a)# new_track_list = list(num_pred * a + np.array(p_hyp.track_set))</span>

                        <span class="n">new_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="n">new_track_list</span>
                        <span class="n">up_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hyp</span><span class="p">)</span>

        <span class="n">lse</span> <span class="o">=</span> <span class="n">log_sum_exp</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">up_hyps</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">up_hyps</span><span class="p">)):</span>
            <span class="n">up_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">up_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">-</span> <span class="n">lse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">up_hyps</span>

<div class="viewcode-block" id="MSPoissonMultiBernoulliMixture.correct">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.MSPoissonMultiBernoulliMixture.correct">[docs]</a>
    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correction step of the MS-PMBM filter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This corrects the hypotheses based on the measurements and gates the</span>
<span class="sd">        measurements according to the class settings. It also updates the</span>
<span class="sd">        cardinality distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            Current timestep.</span>
<span class="sd">        meas : list</span>
<span class="sd">            List of Nm x 1 numpy arrays each representing a measuremnt.</span>
<span class="sd">        filt_args : dict, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters correct function.</span>
<span class="sd">            The default is {}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_combs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">meas</span><span class="p">))</span>
        <span class="c1"># TODO: Add method for only single measurements to be assoc&#39;d i.e. all_combs needs to include single measurement options</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Gating not implemented yet. SKIPPING&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="c1"># means = []</span>
            <span class="c1"># covs = []</span>
            <span class="c1"># for ent in self._track_tab:</span>
            <span class="c1">#     means.extend(ent.probDensity.means)</span>
            <span class="c1">#     covs.extend(ent.probDensity.covariances)</span>
            <span class="c1"># meas = self._gate_meas(meas, means, covs)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">meas</span><span class="p">))</span>

        <span class="c1"># get matrix of indices in all_combs</span>
        <span class="n">num_meas_per_sens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">meas</span><span class="p">]</span>
        <span class="n">num_meas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_combs</span><span class="p">)</span>
        <span class="n">num_sens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>
        <span class="n">mnmps</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_meas_per_sens</span><span class="p">)</span>
        <span class="n">comb_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">meas</span><span class="p">)))</span>
        <span class="n">comb_inds</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span> <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">comb_inds</span><span class="p">]</span>
        <span class="n">min_meas_in_sens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">meas</span><span class="p">])</span>

        <span class="n">all_meas_combs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">comb_inds</span><span class="p">,</span> <span class="n">mnmps</span><span class="p">))</span>
        <span class="n">all_meas_combs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span> <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">all_meas_combs</span><span class="p">]</span>

        <span class="n">poss_meas_combs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_meas_combs</span><span class="p">)):</span>
            <span class="n">break_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">cur_comb</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">lst1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_meas_combs</span><span class="p">[</span><span class="n">ii</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">lst2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_meas_combs</span><span class="p">[</span><span class="n">ii</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">jj</span> <span class="o">==</span> <span class="n">kk</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lst1</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lst2</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
                            <span class="n">break_flag</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="n">break_flag</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">break_flag</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">lst1</span> <span class="ow">in</span> <span class="n">all_meas_combs</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">lst2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comb_inds</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">lst1</span> <span class="o">==</span> <span class="n">lst2</span><span class="p">:</span>
                            <span class="n">cur_comb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
                <span class="n">poss_meas_combs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_comb</span><span class="p">)</span>

        <span class="n">cor_tab</span><span class="p">,</span> <span class="n">all_cost_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_cor_tab</span><span class="p">(</span>
            <span class="n">num_meas</span><span class="p">,</span> <span class="n">all_combs</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">comb_inds</span><span class="p">,</span> <span class="n">filt_args</span>
        <span class="p">)</span>

        <span class="c1"># self._add_birth_hyps(num_meas)</span>

        <span class="n">avg_prob_det</span><span class="p">,</span> <span class="n">avg_prob_mdet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_avg_prob_det_mdet</span><span class="p">(</span><span class="n">cor_tab</span><span class="p">)</span>

        <span class="n">cor_hyps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_cor_hyps</span><span class="p">(</span>
            <span class="n">num_meas</span><span class="p">,</span> <span class="n">avg_prob_det</span><span class="p">,</span> <span class="n">avg_prob_mdet</span><span class="p">,</span> <span class="n">all_cost_m</span><span class="p">,</span> <span class="n">poss_meas_combs</span><span class="p">,</span> <span class="n">cor_tab</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">cor_tab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="n">cor_hyps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_updates</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="MSLabeledPoissonMultiBernoulliMixture">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSLabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.MSLabeledPoissonMultiBernoulliMixture">[docs]</a>
<span class="k">class</span> <span class="nc">MSLabeledPoissonMultiBernoulliMixture</span><span class="p">(</span><span class="n">LabeledPoissonMultiBernoulliMixture</span><span class="p">):</span>
<div class="viewcode-block" id="MSLabeledPoissonMultiBernoulliMixture.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSLabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.MSLabeledPoissonMultiBernoulliMixture.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_gen_cor_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_meas</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">comb_inds</span><span class="p">,</span> <span class="n">filt_args</span><span class="p">):</span>
        <span class="n">num_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="n">num_birth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">)</span>
        <span class="n">up_tab</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_meas</span> <span class="o">*</span> <span class="n">num_birth</span><span class="p">)</span>

        <span class="c1"># Missed Detection Updates</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">track</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TabEntry</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>
            <span class="n">sum_non_exist_prob</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">1</span>
                <span class="o">-</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span>
                <span class="o">+</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span>
            <span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="n">w</span> <span class="o">*</span> <span class="n">sum_non_exist_prob</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">distrib_weights_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">exist_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob_miss_detection</span>
            <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sum_non_exist_prob</span><span class="p">)</span>
            <span class="n">up_tab</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">all_cost_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_meas</span><span class="p">,</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_birth</span> <span class="o">*</span> <span class="n">num_meas</span><span class="p">))</span>

        <span class="c1"># Update for all existing tracks</span>
        <span class="k">for</span> <span class="n">emm</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">):</span>
                <span class="n">s_to_ii</span> <span class="o">=</span> <span class="n">num_pred</span> <span class="o">*</span> <span class="n">emm</span> <span class="o">+</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">num_pred</span>
                <span class="p">(</span><span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">],</span> <span class="n">cost</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_track_tab_entry</span><span class="p">(</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comb_inds</span><span class="p">[</span><span class="n">emm</span><span class="p">])</span>
                <span class="n">all_cost_m</span><span class="p">[</span><span class="n">emm</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>

        <span class="c1"># Update for all potential new births</span>
        <span class="k">for</span> <span class="n">emm</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meas</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">b_model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">birth_terms</span><span class="p">):</span>
                <span class="n">s_to_ii</span> <span class="o">=</span> <span class="p">((</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span><span class="p">)</span> <span class="o">+</span> <span class="n">emm</span> <span class="o">*</span> <span class="n">num_birth</span> <span class="o">+</span> <span class="n">ii</span>
                <span class="p">(</span><span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">],</span> <span class="n">cost</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_birth_tab_entry</span><span class="p">(</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">b_model</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">filt_args</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">meas_assoc_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comb_inds</span><span class="p">[</span><span class="n">emm</span><span class="p">])</span>
                    <span class="n">up_tab</span><span class="p">[</span><span class="n">s_to_ii</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimal_places</span><span class="p">),</span> <span class="n">ii</span><span class="p">)</span>
                <span class="n">all_cost_m</span><span class="p">[</span><span class="n">emm</span><span class="p">,</span> <span class="n">emm</span> <span class="o">+</span> <span class="n">num_pred</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="k">return</span> <span class="n">up_tab</span><span class="p">,</span> <span class="n">all_cost_m</span>

    <span class="k">def</span> <span class="nf">_gen_cor_hyps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_meas</span><span class="p">,</span>
        <span class="n">avg_prob_detect</span><span class="p">,</span>
        <span class="n">avg_prob_miss_detect</span><span class="p">,</span>
        <span class="n">all_cost_m</span><span class="p">,</span>
        <span class="n">meas_combs</span><span class="p">,</span>
        <span class="n">cor_tab</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">num_pred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span><span class="p">)</span>
        <span class="n">up_hyps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">meas_combs</span><span class="p">:</span>
            <span class="n">meas_combs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">all_cost_m</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># n_obj_for_tracks =</span>
        <span class="k">if</span> <span class="n">num_meas</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
                <span class="n">pmd_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">avg_prob_miss_detect</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">+</span> <span class="n">pmd_log</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                <span class="n">up_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hyp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clutter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clutter_den</span>
            <span class="n">ss_w</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">p_hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
                <span class="n">ss_w</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p_hyp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ind_lst</span> <span class="ow">in</span> <span class="n">meas_combs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas_combs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">num_tracks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># all clutter</span>
                            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_pred</span><span class="p">,</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_meas</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">inds</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span>
                                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_pred</span><span class="p">,</span> <span class="n">num_pred</span> <span class="o">+</span> <span class="n">num_meas</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                            <span class="p">)</span>
                        <span class="n">cost_m</span> <span class="o">=</span> <span class="n">all_cost_m</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># TODO Change this process so it works when we can&#39;t just arange through to the end. I think we add num_pred to the indices in ind_lst</span>
                        <span class="k">if</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">num_tracks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># all clutter</span>
                            <span class="c1"># inds = np.arange(num_pred, num_pred + len(ind_lst)).tolist()</span>
                            <span class="n">inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">num_pred</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_lst</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">inds</span> <span class="o">=</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">num_pred</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ind_lst</span><span class="p">]</span>
                        <span class="n">tcm</span> <span class="o">=</span> <span class="n">all_cost_m</span><span class="p">[</span>
                            <span class="p">:,</span> <span class="n">inds</span>
                        <span class="p">]</span>  <span class="c1"># error is certainly caused here. I&#39;m going to bed now because it&#39;s past 11.</span>
                        <span class="n">cost_m</span> <span class="o">=</span> <span class="n">tcm</span><span class="p">[</span><span class="n">ind_lst</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">max_row_inds</span><span class="p">,</span> <span class="n">max_col_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cost_m</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">max_row_inds</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">cost_m</span><span class="p">[</span><span class="n">max_row_inds</span><span class="p">,</span> <span class="n">max_col_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
                    <span class="n">min_row_inds</span><span class="p">,</span> <span class="n">min_col_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cost_m</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">min_row_inds</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">cost_m</span><span class="p">[</span><span class="n">min_row_inds</span><span class="p">,</span> <span class="n">min_col_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>  <span class="c1"># 1</span>
                    <span class="n">neg_log</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cost_m</span><span class="p">)</span>

                    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">req_upd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span> <span class="o">/</span> <span class="n">ss_w</span><span class="p">)</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

                    <span class="p">[</span><span class="n">assigns</span><span class="p">,</span> <span class="n">costs</span><span class="p">]</span> <span class="o">=</span> <span class="n">murty_m_best_all_meas_assigned</span><span class="p">(</span><span class="n">neg_log</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

                    <span class="n">pmd_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">avg_prob_miss_detect</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">assigns</span><span class="p">,</span> <span class="n">costs</span><span class="p">):</span>
                        <span class="n">new_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HypothesisHelper</span><span class="p">()</span>
                        <span class="n">new_hyp</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">clutter_rate</span>
                            <span class="o">+</span> <span class="n">num_meas</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clutter</span><span class="p">)</span>
                            <span class="o">+</span> <span class="n">pmd_log</span>
                            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">assoc_prob</span><span class="p">)</span>
                            <span class="o">-</span> <span class="n">c</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">num_tracks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># new_track_list = list(num_pred * a + num_pred * num_meas)</span>
                            <span class="c1"># new_track_list = list(num_pred * a + num_pred * num_meas)</span>
                            <span class="n">new_track_list</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                                <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">(</span><span class="n">ind_lst</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_pred</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_pred</span> <span class="o">*</span> <span class="n">num_meas</span><span class="p">)</span>
                                <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># track_inds = np.argwhere(a==1)</span>
                            <span class="n">new_track_list</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ms</span><span class="p">:</span>
                                    <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="p">(</span><span class="n">ind_lst</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pred</span>
                                        <span class="o">+</span> <span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">[(</span><span class="n">ms</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                                    <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">num_pred</span> <span class="o">*</span> <span class="n">ms</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_pred</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                                    <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">num_pred</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ind_lst</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
                                    <span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">new_track_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">num_pred</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                                        <span class="o">-</span> <span class="p">(</span><span class="n">ms</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_hyp</span><span class="o">.</span><span class="n">track_set</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                                    <span class="p">)</span>

                            <span class="c1"># if len(a) == len(p_hyp.track_set):</span>
                            <span class="c1">#     for ii, (ms, t) in enumerate(zip(a, p_hyp.track_set)):</span>
                            <span class="c1">#         if len(p_hyp.track_set) &gt;= ms:</span>
                            <span class="c1">#             # new_track_list.append(((np.array(t)) * ms + num_pred))</span>
                            <span class="c1">#             new_track_list.append(</span>
                            <span class="c1">#                 (num_pred * (ind_lst[ii] + 1) + np.array(t))</span>
                            <span class="c1">#             )</span>
                            <span class="c1">#             # new_track_list.append((num_pred * ms + np.array(t)))</span>
                            <span class="c1">#         else:</span>
                            <span class="c1">#             # new_track_list.append(num_pred * ms - ind_lst[ii] * (num_pred - 1))</span>
                            <span class="c1">#             new_track_list.append(</span>
                            <span class="c1">#                 num_pred * (ind_lst[ii] + 1) + t + ms</span>
                            <span class="c1">#                 # num_pred * (ms + 1) + ind_lst[ii]</span>
                            <span class="c1">#                 # num_pred * (ind_lst[ii] + 1)</span>
                            <span class="c1">#                 # - ii * (num_pred - 1)</span>
                            <span class="c1">#             )</span>
                            <span class="c1"># elif len(p_hyp.track_set) &lt; len(a):</span>
                            <span class="c1">#     for ii, ms in enumerate(a):</span>
                            <span class="c1">#         if len(p_hyp.track_set) &gt;= ms:</span>
                            <span class="c1">#             new_track_list.append(</span>
                            <span class="c1">#                 (1 + ind_lst[ii]) * num_pred</span>
                            <span class="c1">#                 + p_hyp.track_set[(ms - 1)]</span>
                            <span class="c1">#             )</span>
                            <span class="c1">#         elif len(p_hyp.track_set) &lt; ms:</span>
                            <span class="c1">#             new_track_list.append(</span>
                            <span class="c1">#                 num_pred * (num_meas + 1) + (ind_lst[ii])</span>
                            <span class="c1">#             )</span>
                            <span class="c1"># elif len(p_hyp.track_set) &gt; len(a):</span>
                            <span class="c1">#     # May need to modify this</span>
                            <span class="c1">#     for ii, ms in enumerate(a):</span>
                            <span class="c1">#         if len(p_hyp.track_set) &gt;= ms:</span>
                            <span class="c1">#             # new_track_list.append(</span>
                            <span class="c1">#             #     ms * num_pred + p_hyp.track_set[(ms - 1)]</span>
                            <span class="c1">#             # )</span>
                            <span class="c1">#             new_track_list.append(</span>
                            <span class="c1">#                 (1 + ind_lst[ii]) * num_pred</span>
                            <span class="c1">#                 + p_hyp.track_set[(ms - 1)]</span>
                            <span class="c1">#             )</span>
                            <span class="c1">#         elif len(p_hyp.track_set) &lt; ms:</span>
                            <span class="c1">#             new_track_list.append(</span>
                            <span class="c1">#                 num_pred * (num_meas + 1) - (ms - len(p_hyp.track_set) - 1)</span>
                            <span class="c1">#             )</span>

                            <span class="c1"># new_track_list = list(np.array(p_hyp.track_set) + num_pred + num_pred * a)# new_track_list = list(num_pred * a + np.array(p_hyp.track_set))</span>

                        <span class="n">new_hyp</span><span class="o">.</span><span class="n">track_set</span> <span class="o">=</span> <span class="n">new_track_list</span>
                        <span class="n">up_hyps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hyp</span><span class="p">)</span>

        <span class="n">lse</span> <span class="o">=</span> <span class="n">log_sum_exp</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">up_hyps</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">up_hyps</span><span class="p">)):</span>
            <span class="n">up_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">up_hyps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">assoc_prob</span> <span class="o">-</span> <span class="n">lse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">up_hyps</span>

<div class="viewcode-block" id="MSLabeledPoissonMultiBernoulliMixture.correct">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSLabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.MSLabeledPoissonMultiBernoulliMixture.correct">[docs]</a>
    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">meas</span><span class="p">,</span> <span class="n">filt_args</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correction step of the MS-PMBM filter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This corrects the hypotheses based on the measurements and gates the</span>
<span class="sd">        measurements according to the class settings. It also updates the</span>
<span class="sd">        cardinality distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestep: float</span>
<span class="sd">            Current timestep.</span>
<span class="sd">        meas : list</span>
<span class="sd">            List of Nm x 1 numpy arrays each representing a measuremnt.</span>
<span class="sd">        filt_args : dict, optional</span>
<span class="sd">            keyword arguments to pass to the inner filters correct function.</span>
<span class="sd">            The default is {}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sens_len_lst = []</span>
        <span class="c1"># for sens in meas:</span>
        <span class="c1">#     temp_lst = np.array([len(x) for x in sens])</span>
        <span class="c1">#     if np.all(temp_lst==0):</span>
        <span class="c1">#         sens_len_lst.append(0)</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         sens_len_lst.append(len(sens))</span>
        <span class="c1">#     if len(sens[-1]) != 0:</span>
        <span class="c1">#         sens.append(np.array([]))</span>
        <span class="n">all_combs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">meas</span><span class="p">))</span>
        <span class="c1"># all_combs.pop(-1)</span>

        <span class="c1"># for ii, c in enumerate(all_combs):</span>
        <span class="c1">#     if np.all([len(tmplst) == 0 for tmplst in c]):</span>
        <span class="c1">#         all_combs.pop(ii)</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         continue</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gating_on</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Gating not implemented yet. SKIPPING&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="c1"># means = []</span>
            <span class="c1"># covs = []</span>
            <span class="c1"># for ent in self._track_tab:</span>
            <span class="c1">#     means.extend(ent.probDensity.means)</span>
            <span class="c1">#     covs.extend(ent.probDensity.covariances)</span>
            <span class="c1"># meas = self._gate_meas(meas, means, covs)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_measurements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meas_tab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">meas</span><span class="p">))</span>

        <span class="c1"># get matrix of indices in all_combs somehow</span>
        <span class="n">num_meas_per_sens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">meas</span><span class="p">]</span>
        <span class="n">num_meas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_combs</span><span class="p">)</span>
        <span class="n">num_sens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>
        <span class="c1"># NEED TO ITERATE THROUGH THIS</span>
        <span class="c1"># SHOULD GO FROM CURR MNMPS AND STOP WHEN IT HITS 0.</span>
        <span class="c1"># THEN WE&#39;LL GET COMBINATIONS OF ALL POSSIBLE MEASUREMENTS FOR ALL POSSIBLE PERMUTATIONS</span>
        <span class="n">mnmps</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_meas_per_sens</span><span class="p">)</span>

        <span class="c1"># find a way to make this list of lists not list of tuples</span>
        <span class="n">comb_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">meas</span><span class="p">)))</span>
        <span class="n">comb_inds</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span> <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">comb_inds</span><span class="p">]</span>
        <span class="c1"># pop_lst = []</span>
        <span class="c1"># for ii in range(len(comb_inds)):</span>
        <span class="c1">#     for jj in range(len(comb_inds[ii])):</span>
        <span class="c1">#         if comb_inds[ii][jj] &gt;= sens_len_lst[jj]:</span>
        <span class="c1">#             comb_inds[ii][jj] = np.nan</span>
        <span class="c1">#     if np.all(np.isnan(comb_inds[ii])):</span>
        <span class="c1">#         pop_lst.append(ii)</span>
        <span class="c1"># for ind in pop_lst:</span>
        <span class="c1">#     comb_inds.pop(ind)</span>
        <span class="n">min_meas_in_sens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">meas</span><span class="p">])</span>

        <span class="n">all_meas_combs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">comb_inds</span><span class="p">,</span> <span class="n">mnmps</span><span class="p">))</span>
        <span class="n">all_meas_combs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span> <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">all_meas_combs</span><span class="p">]</span>

        <span class="n">poss_meas_combs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># for ii in range(len(all_combs)):</span>
        <span class="c1">#     poss_meas_combs.append([ii])</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_meas_combs</span><span class="p">)):</span>
            <span class="n">break_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">cur_comb</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">lst1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_meas_combs</span><span class="p">[</span><span class="n">ii</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">lst2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_meas_combs</span><span class="p">[</span><span class="n">ii</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">jj</span> <span class="o">==</span> <span class="n">kk</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lst1</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lst2</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
                            <span class="n">break_flag</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="n">break_flag</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">break_flag</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">lst1</span> <span class="ow">in</span> <span class="n">all_meas_combs</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">lst2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comb_inds</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">lst1</span> <span class="o">==</span> <span class="n">lst2</span><span class="p">:</span>
                            <span class="n">cur_comb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
                <span class="n">poss_meas_combs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_comb</span><span class="p">)</span>

        <span class="n">cor_tab</span><span class="p">,</span> <span class="n">all_cost_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_cor_tab</span><span class="p">(</span>
            <span class="n">num_meas</span><span class="p">,</span> <span class="n">all_combs</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">comb_inds</span><span class="p">,</span> <span class="n">filt_args</span>
        <span class="p">)</span>

        <span class="c1"># self._add_birth_hyps(num_meas)</span>

        <span class="n">avg_prob_det</span><span class="p">,</span> <span class="n">avg_prob_mdet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_avg_prob_det_mdet</span><span class="p">(</span><span class="n">cor_tab</span><span class="p">)</span>

        <span class="n">cor_hyps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_cor_hyps</span><span class="p">(</span>
            <span class="n">num_meas</span><span class="p">,</span> <span class="n">avg_prob_det</span><span class="p">,</span> <span class="n">avg_prob_mdet</span><span class="p">,</span> <span class="n">all_cost_m</span><span class="p">,</span> <span class="n">poss_meas_combs</span><span class="p">,</span> <span class="n">cor_tab</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_tab</span> <span class="o">=</span> <span class="n">cor_tab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span> <span class="o">=</span> <span class="n">cor_hyps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_card_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_card_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypotheses</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_updates</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="MSIMMPoissonMultiBernoulliMixture">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSIMMPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.MSIMMPoissonMultiBernoulliMixture">[docs]</a>
<span class="k">class</span> <span class="nc">MSIMMPoissonMultiBernoulliMixture</span><span class="p">(</span><span class="n">_IMMPMBMBase</span><span class="p">,</span> <span class="n">MSPoissonMultiBernoulliMixture</span><span class="p">):</span>
<div class="viewcode-block" id="MSIMMPoissonMultiBernoulliMixture.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSIMMPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.MSIMMPoissonMultiBernoulliMixture.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="MSIMMLabeledPoissonMultiBernoulliMixture">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSIMMLabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.MSIMMLabeledPoissonMultiBernoulliMixture">[docs]</a>
<span class="k">class</span> <span class="nc">MSIMMLabeledPoissonMultiBernoulliMixture</span><span class="p">(</span>
    <span class="n">_IMMPMBMBase</span><span class="p">,</span> <span class="n">MSLabeledPoissonMultiBernoulliMixture</span>
<span class="p">):</span>
<div class="viewcode-block" id="MSIMMLabeledPoissonMultiBernoulliMixture.__init__">
<a class="viewcode-back" href="../../../_autosummary/carbs/swarm_estimator/tracker/carbs.swarm_estimator.tracker.MSIMMLabeledPoissonMultiBernoulliMixture.html#carbs.swarm_estimator.tracker.MSIMMLabeledPoissonMultiBernoulliMixture.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Jordan D Larson.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>